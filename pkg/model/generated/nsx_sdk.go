// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package resources

import "encoding/json"
import "fmt"
import "reflect"

// Allows more granular policies for application workloads
type ApplicationConnectivityStrategy struct {
	// App connectivity strategies
	ApplicationConnectivityStrategy *ApplicationConnectivityStrategyApplicationConnectivityStrategy `json:"application_connectivity_strategy,omitempty" yaml:"application_connectivity_strategy,omitempty" mapstructure:"application_connectivity_strategy,omitempty"`

	// Based on the value of the app connectivity strategy, a default rule is created
	// for the security policy. The rule id is internally assigned by the system for
	// this default rule.
	DefaultApplicationRuleId *int `json:"default_application_rule_id,omitempty" yaml:"default_application_rule_id,omitempty" mapstructure:"default_application_rule_id,omitempty"`

	// Flag to enable packet logging. Default is deactivated.
	LoggingEnabled bool `json:"logging_enabled,omitempty" yaml:"logging_enabled,omitempty" mapstructure:"logging_enabled,omitempty"`
}

type ApplicationConnectivityStrategyApplicationConnectivityStrategy string

const ApplicationConnectivityStrategyApplicationConnectivityStrategyALLOWEGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "ALLOW_EGRESS"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyALLOWINGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "ALLOW_INGRESS"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyALLOWINTRA ApplicationConnectivityStrategyApplicationConnectivityStrategy = "ALLOW_INTRA"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyDROPEGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "DROP_EGRESS"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyDROPINGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "DROP_INGRESS"

var enumValues_ApplicationConnectivityStrategyApplicationConnectivityStrategy = []interface{}{
	"ALLOW_INTRA",
	"ALLOW_EGRESS",
	"ALLOW_INGRESS",
	"DROP_INGRESS",
	"DROP_EGRESS",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApplicationConnectivityStrategyApplicationConnectivityStrategy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApplicationConnectivityStrategyApplicationConnectivityStrategy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApplicationConnectivityStrategyApplicationConnectivityStrategy, v)
	}
	*j = ApplicationConnectivityStrategyApplicationConnectivityStrategy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApplicationConnectivityStrategy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ApplicationConnectivityStrategy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["logging_enabled"]; !ok || v == nil {
		plain.LoggingEnabled = false
	}
	*j = ApplicationConnectivityStrategy(plain)
	return nil
}

// Represents an object on the desired state
type ChildPolicyConfigResource struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// MarkForOverride corresponds to the JSON schema field "mark_for_override".
	MarkForOverride bool `json:"mark_for_override,omitempty" yaml:"mark_for_override,omitempty" mapstructure:"mark_for_override,omitempty"`

	// If this field is set to true, delete operation is triggered on the intent tree.
	// This resource along with its all children in intent tree will be deleted. This
	// is a cascade delete and should only be used if intent object along with its all
	// children are to be deleted. This does not support deletion of single non-leaf
	// node within the tree and should be used carefully.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// RequestParameter corresponds to the JSON schema field "request_parameter".
	RequestParameter *PolicyRequestParameter `json:"request_parameter,omitempty" yaml:"request_parameter,omitempty" mapstructure:"request_parameter,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChildPolicyConfigResource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ChildPolicyConfigResource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["mark_for_override"]; !ok || v == nil {
		plain.MarkForOverride = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = ChildPolicyConfigResource(plain)
	return nil
}

// Represents the leaf level condition. Evaluation of the condition expression will
// be case insensitive.
type Condition struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// List of members to be excluded from the condition. This field is applicable
	// only for condition representing the list of malicious IPs. Only
	// IPAddressExpression and PathExpression are supported. The PathExpression should
	// have paths of Groups that of the group_type IPAddress. Multiple PathExpressions
	// are not supported here.
	Exclude *ExcludedMembersList `json:"exclude,omitempty" yaml:"exclude,omitempty" mapstructure:"exclude,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *ConditionKey `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// For global groups (groups created from Global Manager), the supported Member
	// Types are - VirtualMachine, Segment, SegmentPort, Group, DVPG and DVPort. For
	// local groups (groups created on the local policy manager), the supported member
	// types are IPSet, VirtualMachine, LogicalPort, LogicalSwitch, Segment,
	// SegmentPort, Pod, Service, Namespace, TransportNode, Group, DVPG, DVPort,
	// KubernetesCluster, KubernetesNamespace, AntreaEgress, AntreaIPPool,
	// KubernetesIngress, KubernetesGateway, KubernetesService and KubernetesNode.
	MemberType *ConditionMemberType `json:"member_type,omitempty" yaml:"member_type,omitempty" mapstructure:"member_type,omitempty"`

	// Operator is made non-mandatory to support Segment and SegmentPort tag based
	// expression. To evaluate expression for other types, operator value should be
	// provided.
	Operator *ConditionOperator `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ConditionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Default operator when not specified explicitly would be considered as EQUALS.
	// If value for Condition is empty, then condition will not be evaluated. For
	// example, Condition with key as Tag and value as "|tag" would be evaluated for
	// tag value not for empty scope value.
	ScopeOperator *ConditionScopeOperator `json:"scope_operator,omitempty" yaml:"scope_operator,omitempty" mapstructure:"scope_operator,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type ConditionKey string

const ConditionKeyALL ConditionKey = "ALL"
const ConditionKeyComputerName ConditionKey = "ComputerName"
const ConditionKeyGroupType ConditionKey = "GroupType"
const ConditionKeyIPAddress ConditionKey = "IPAddress"
const ConditionKeyName ConditionKey = "Name"
const ConditionKeyNodeType ConditionKey = "NodeType"
const ConditionKeyOSName ConditionKey = "OSName"
const ConditionKeyPodCidr ConditionKey = "PodCidr"
const ConditionKeyTag ConditionKey = "Tag"

var enumValues_ConditionKey = []interface{}{
	"Tag",
	"Name",
	"OSName",
	"ComputerName",
	"NodeType",
	"GroupType",
	"ALL",
	"IPAddress",
	"PodCidr",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionKey) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionKey {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionKey, v)
	}
	*j = ConditionKey(v)
	return nil
}

type ConditionMemberType string

const ConditionMemberTypeAntreaEgress ConditionMemberType = "AntreaEgress"
const ConditionMemberTypeAntreaIPPool ConditionMemberType = "AntreaIPPool"
const ConditionMemberTypeDVPG ConditionMemberType = "DVPG"
const ConditionMemberTypeDVPort ConditionMemberType = "DVPort"
const ConditionMemberTypeGroup ConditionMemberType = "Group"
const ConditionMemberTypeIPAddress ConditionMemberType = "IPAddress"
const ConditionMemberTypeIPSet ConditionMemberType = "IPSet"
const ConditionMemberTypeKubernetesCluster ConditionMemberType = "KubernetesCluster"
const ConditionMemberTypeKubernetesGateway ConditionMemberType = "KubernetesGateway"
const ConditionMemberTypeKubernetesIngress ConditionMemberType = "KubernetesIngress"
const ConditionMemberTypeKubernetesNamespace ConditionMemberType = "KubernetesNamespace"
const ConditionMemberTypeKubernetesNode ConditionMemberType = "KubernetesNode"
const ConditionMemberTypeKubernetesService ConditionMemberType = "KubernetesService"
const ConditionMemberTypeLogicalPort ConditionMemberType = "LogicalPort"
const ConditionMemberTypeLogicalSwitch ConditionMemberType = "LogicalSwitch"
const ConditionMemberTypeNamespace ConditionMemberType = "Namespace"
const ConditionMemberTypePod ConditionMemberType = "Pod"
const ConditionMemberTypeSegment ConditionMemberType = "Segment"
const ConditionMemberTypeSegmentPort ConditionMemberType = "SegmentPort"
const ConditionMemberTypeService ConditionMemberType = "Service"
const ConditionMemberTypeTransportNode ConditionMemberType = "TransportNode"
const ConditionMemberTypeVirtualMachine ConditionMemberType = "VirtualMachine"
const ConditionMemberTypeVpcSubnet ConditionMemberType = "VpcSubnet"
const ConditionMemberTypeVpcSubnetPort ConditionMemberType = "VpcSubnetPort"

var enumValues_ConditionMemberType = []interface{}{
	"IPSet",
	"VirtualMachine",
	"LogicalPort",
	"LogicalSwitch",
	"Segment",
	"SegmentPort",
	"Pod",
	"Service",
	"Namespace",
	"TransportNode",
	"Group",
	"DVPG",
	"DVPort",
	"IPAddress",
	"VpcSubnet",
	"KubernetesCluster",
	"KubernetesNamespace",
	"AntreaEgress",
	"AntreaIPPool",
	"KubernetesIngress",
	"KubernetesGateway",
	"KubernetesService",
	"KubernetesNode",
	"VpcSubnetPort",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionMemberType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionMemberType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionMemberType, v)
	}
	*j = ConditionMemberType(v)
	return nil
}

type ConditionOperator string

const ConditionOperatorCONTAINS ConditionOperator = "CONTAINS"
const ConditionOperatorENDSWITH ConditionOperator = "ENDSWITH"
const ConditionOperatorEQUALS ConditionOperator = "EQUALS"
const ConditionOperatorIN ConditionOperator = "IN"
const ConditionOperatorMATCHES ConditionOperator = "MATCHES"
const ConditionOperatorNOTEQUALS ConditionOperator = "NOTEQUALS"
const ConditionOperatorNOTIN ConditionOperator = "NOTIN"
const ConditionOperatorSTARTSWITH ConditionOperator = "STARTSWITH"

var enumValues_ConditionOperator = []interface{}{
	"EQUALS",
	"CONTAINS",
	"STARTSWITH",
	"ENDSWITH",
	"NOTEQUALS",
	"NOTIN",
	"MATCHES",
	"IN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionOperator, v)
	}
	*j = ConditionOperator(v)
	return nil
}

type ConditionResourceType string

const ConditionResourceTypeCondition ConditionResourceType = "Condition"
const ConditionResourceTypeConjunctionOperator ConditionResourceType = "ConjunctionOperator"
const ConditionResourceTypeExternalIDExpression ConditionResourceType = "ExternalIDExpression"
const ConditionResourceTypeIPAddressExpression ConditionResourceType = "IPAddressExpression"
const ConditionResourceTypeIdentityGroupExpression ConditionResourceType = "IdentityGroupExpression"
const ConditionResourceTypeMACAddressExpression ConditionResourceType = "MACAddressExpression"
const ConditionResourceTypeNestedExpression ConditionResourceType = "NestedExpression"
const ConditionResourceTypePathExpression ConditionResourceType = "PathExpression"

var enumValues_ConditionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionResourceType, v)
	}
	*j = ConditionResourceType(v)
	return nil
}

type ConditionScopeOperator string

const ConditionScopeOperatorEQUALS ConditionScopeOperator = "EQUALS"
const ConditionScopeOperatorNOTEQUALS ConditionScopeOperator = "NOTEQUALS"

var enumValues_ConditionScopeOperator = []interface{}{
	"EQUALS",
	"NOTEQUALS",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionScopeOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionScopeOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionScopeOperator, v)
	}
	*j = ConditionScopeOperator(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Condition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Condition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	if plain.Value != nil && len(*plain.Value) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "value", 1)
	}
	*j = Condition(plain)
	return nil
}

type DiscoveredResourceScope struct {
	// Specifies the scope id of discovered resource.
	ScopeId *string `json:"scope_id,omitempty" yaml:"scope_id,omitempty" mapstructure:"scope_id,omitempty"`

	// Type of the scope for the discovered resource.
	ScopeType *DiscoveredResourceScopeScopeType `json:"scope_type,omitempty" yaml:"scope_type,omitempty" mapstructure:"scope_type,omitempty"`
}

type DiscoveredResourceScopeScopeType string

const DiscoveredResourceScopeScopeTypeCONTAINERCLUSTER DiscoveredResourceScopeScopeType = "CONTAINER_CLUSTER"
const DiscoveredResourceScopeScopeTypeVPC DiscoveredResourceScopeScopeType = "VPC"

var enumValues_DiscoveredResourceScopeScopeType = []interface{}{
	"CONTAINER_CLUSTER",
	"VPC",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DiscoveredResourceScopeScopeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DiscoveredResourceScopeScopeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DiscoveredResourceScopeScopeType, v)
	}
	*j = DiscoveredResourceScopeScopeType(v)
	return nil
}

type EpochMsTimestamp int

// Represents the list of members that need to be excluded
type ExcludedMembersList struct {
	// IpAddressExpression corresponds to the JSON schema field
	// "ip_address_expression".
	IpAddressExpression *IPAddressExpression `json:"ip_address_expression,omitempty" yaml:"ip_address_expression,omitempty" mapstructure:"ip_address_expression,omitempty"`

	// Paths can be only IP address based groups. Upto 50 paths are allowed.
	PathExpression *PathExpression `json:"path_expression,omitempty" yaml:"path_expression,omitempty" mapstructure:"path_expression,omitempty"`
}

// All the nodes of the expression extend from this abstract class. This is present
// for extensibility.
type Expression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ExpressionResourceType string

const ExpressionResourceTypeCondition ExpressionResourceType = "Condition"
const ExpressionResourceTypeConjunctionOperator ExpressionResourceType = "ConjunctionOperator"
const ExpressionResourceTypeExternalIDExpression ExpressionResourceType = "ExternalIDExpression"
const ExpressionResourceTypeIPAddressExpression ExpressionResourceType = "IPAddressExpression"
const ExpressionResourceTypeIdentityGroupExpression ExpressionResourceType = "IdentityGroupExpression"
const ExpressionResourceTypeMACAddressExpression ExpressionResourceType = "MACAddressExpression"
const ExpressionResourceTypeNestedExpression ExpressionResourceType = "NestedExpression"
const ExpressionResourceTypePathExpression ExpressionResourceType = "PathExpression"

var enumValues_ExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExpressionResourceType, v)
	}
	*j = ExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Expression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Expression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Expression(plain)
	return nil
}

// Group.
type Group struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// The expression list must follow below criteria:   1. A non-empty expression
	// list, must be of odd size. In a list, with   indices starting from 0, all
	// non-conjunction expressions must be at   even indices, separated by a
	// conjunction expression at odd   indices.   2. The total of ConditionExpression
	// and NestedExpression in a list   should not exceed 5.   3. The total of
	// IPAddressExpression, MACAddressExpression, external   IDs in an
	// ExternalIDExpression and paths in a PathExpression must not exceed   the
	// defined Config Max limit for the form-factor of Manager nodes.   4. Each
	// expression must be a valid Expression. See the definition of   the Expression
	// type for more information.
	Expression []Expression `json:"expression,omitempty" yaml:"expression,omitempty" mapstructure:"expression,omitempty"`

	// Extended Expression allows additional higher level context to be specified for
	// grouping criteria. (e.g. user AD group) This field allow users to specified
	// user context as the source of a firewall rule for IDFW feature. Current version
	// only support a single IdentityGroupExpression. In the future, this might expand
	// to support other conjunction and non-conjunction expression.  The extended
	// expression list must follow below criteria: 1. Contains a single
	// IdentityGroupExpression. No conjunction expression is supported. 2. No other
	// non-conjunction expression is supported, except for IdentityGroupExpression. 3.
	// Each expression must be a valid Expression. See the definition of the
	// Expression type for more information. 4. Extended expression are implicitly AND
	// with expression. 5. No nesting can be supported if this value is used. 6. If a
	// Group is using extended expression, this group must be the only member in the
	// source field of an communication map.
	ExtendedExpression []Expression `json:"extended_expression,omitempty" yaml:"extended_expression,omitempty" mapstructure:"extended_expression,omitempty"`

	// Group type can be specified during create and update of a group. Empty group
	// type indicates a 'generic' group, ie group can include any entity from the
	// valid GroupMemberType.
	GroupType []GroupTypes `json:"group_type,omitempty" yaml:"group_type,omitempty" mapstructure:"group_type,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// If true, indicates that this is a remote reference group. Such group will have
	// span different from the its parent domain. Default value is false.
	Reference bool `json:"reference,omitempty" yaml:"reference,omitempty" mapstructure:"reference,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// State corresponds to the JSON schema field "state".
	State *GroupState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type GroupState string

const GroupStateFAILURE GroupState = "FAILURE"
const GroupStateINPROGRESS GroupState = "IN_PROGRESS"
const GroupStateSUCCESS GroupState = "SUCCESS"

var enumValues_GroupState = []interface{}{
	"IN_PROGRESS",
	"SUCCESS",
	"FAILURE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GroupState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GroupState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GroupState, v)
	}
	*j = GroupState(v)
	return nil
}

type GroupTypes string

const GroupTypesANTREA GroupTypes = "ANTREA"
const GroupTypesIPAddress GroupTypes = "IPAddress"

var enumValues_GroupTypes = []interface{}{
	"IPAddress",
	"ANTREA",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GroupTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GroupTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GroupTypes, v)
	}
	*j = GroupTypes(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Group) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Group
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.ExtendedExpression) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "extended_expression", 1)
	}
	if len(plain.GroupType) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "group_type", 1)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if v, ok := raw["reference"]; !ok || v == nil {
		plain.Reference = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Group(plain)
	return nil
}

// Guest virtual machine details include OS name and computer name of guest VM.
type GuestInfo struct {
	// Computer name of guest virtual machine, which is set inside guest OS. Currently
	// this is supported for guests on ESXi that have VMware Tools installed.
	ComputerName *string `json:"computer_name,omitempty" yaml:"computer_name,omitempty" mapstructure:"computer_name,omitempty"`

	// OS name of guest virtual machine. Currently this is supported for guests on
	// ESXi that have VMware Tools installed.
	OsName *string `json:"os_name,omitempty" yaml:"os_name,omitempty" mapstructure:"os_name,omitempty"`
}

// Represents IP address expressions in the form of an array, to support addition
// of IP addresses in a group.If duplicate IP Addresses are provided these will be
// filtered out and only unique IP Addresses will be considered. Avoid creating
// groups with multiple IPAddressExpression.In future releases, group will be
// restricted to contain a single IPAddressExpression. To group IPAddresses, use
// nested groups instead of multiple IPAddressExpressions.
type IPAddressExpression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// This array can consist of a single IP address, IP address range or a subnet.
	// Its type can be of either IPv4 or IPv6. Both IPv4 and IPv6 addresses within one
	// expression is not allowed. Supported list of formats are, "192.168.1.1",
	// "192.168.1.1-192.168.1.100", "192.168.0.0/24", "fe80::250:56ff:fe83:318c",
	// "fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c",
	// "fe80::250:56ff:fe83:318c/64". The max limit for number of IP addresses applies
	// across all expressions in a group. Please refer to Config Max limits
	// specification document for a given environment.
	IpAddresses []IPElement `json:"ip_addresses,omitempty" yaml:"ip_addresses,omitempty" mapstructure:"ip_addresses,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *IPAddressExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type IPAddressExpressionResourceType string

const IPAddressExpressionResourceTypeCondition IPAddressExpressionResourceType = "Condition"
const IPAddressExpressionResourceTypeConjunctionOperator IPAddressExpressionResourceType = "ConjunctionOperator"
const IPAddressExpressionResourceTypeExternalIDExpression IPAddressExpressionResourceType = "ExternalIDExpression"
const IPAddressExpressionResourceTypeIPAddressExpression IPAddressExpressionResourceType = "IPAddressExpression"
const IPAddressExpressionResourceTypeIdentityGroupExpression IPAddressExpressionResourceType = "IdentityGroupExpression"
const IPAddressExpressionResourceTypeMACAddressExpression IPAddressExpressionResourceType = "MACAddressExpression"
const IPAddressExpressionResourceTypeNestedExpression IPAddressExpressionResourceType = "NestedExpression"
const IPAddressExpressionResourceTypePathExpression IPAddressExpressionResourceType = "PathExpression"

var enumValues_IPAddressExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IPAddressExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IPAddressExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IPAddressExpressionResourceType, v)
	}
	*j = IPAddressExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IPAddressExpression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain IPAddressExpression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if plain.IpAddresses != nil && len(plain.IpAddresses) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "ip_addresses", 1)
	}
	if len(plain.IpAddresses) > 25000 {
		return fmt.Errorf("field %s length: must be <= %d", "ip_addresses", 25000)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = IPAddressExpression(plain)
	return nil
}

// IPElement can be a single IP address, IP address range or a Subnet. Its type can
// be of IPv4 or IPv6. Supported list of formats are "192.168.1.1",
// "192.168.1.1-192.168.1.100", "192.168.0.0/24", "fe80::250:56ff:fe83:318c",
// "fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c",
// "fe80::250:56ff:fe83:318c/64"
type IPElement string

// Represents policy path expressions in the form of an array, to support addition
// of objects like groups, segments and policy logical ports in a group.
type PathExpression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This array can consist of one or more policy paths. Only policy paths of
	// groups, segments and policy logical ports are allowed.
	Paths []string `json:"paths,omitempty" yaml:"paths,omitempty" mapstructure:"paths,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *PathExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type PathExpressionResourceType string

const PathExpressionResourceTypeCondition PathExpressionResourceType = "Condition"
const PathExpressionResourceTypeConjunctionOperator PathExpressionResourceType = "ConjunctionOperator"
const PathExpressionResourceTypeExternalIDExpression PathExpressionResourceType = "ExternalIDExpression"
const PathExpressionResourceTypeIPAddressExpression PathExpressionResourceType = "IPAddressExpression"
const PathExpressionResourceTypeIdentityGroupExpression PathExpressionResourceType = "IdentityGroupExpression"
const PathExpressionResourceTypeMACAddressExpression PathExpressionResourceType = "MACAddressExpression"
const PathExpressionResourceTypeNestedExpression PathExpressionResourceType = "NestedExpression"
const PathExpressionResourceTypePathExpression PathExpressionResourceType = "PathExpression"

var enumValues_PathExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PathExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PathExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PathExpressionResourceType, v)
	}
	*j = PathExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PathExpression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PathExpression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if plain.Paths != nil && len(plain.Paths) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "paths", 1)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = PathExpression(plain)
	return nil
}

// Optional API Request Parameter to be used in HAPI.
type PolicyRequestParameter struct {
	// The type of this request parameter.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`
}

type ResourceLink struct {
	// Action corresponds to the JSON schema field "action".
	Action *string `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Href corresponds to the JSON schema field "href".
	Href *string `json:"href,omitempty" yaml:"href,omitempty" mapstructure:"href,omitempty"`

	// Custom relation type (follows RFC 5988 where appropriate definitions exist)
	Rel *string `json:"rel,omitempty" yaml:"rel,omitempty" mapstructure:"rel,omitempty"`
}

// A weak reference to an NSX resource.
type ResourceReference struct {
	// Will be set to false if the referenced NSX resource has been deleted.
	IsValid *bool `json:"is_valid,omitempty" yaml:"is_valid,omitempty" mapstructure:"is_valid,omitempty"`

	// Display name of the NSX resource.
	TargetDisplayName *string `json:"target_display_name,omitempty" yaml:"target_display_name,omitempty" mapstructure:"target_display_name,omitempty"`

	// Identifier of the NSX resource.
	TargetId *string `json:"target_id,omitempty" yaml:"target_id,omitempty" mapstructure:"target_id,omitempty"`

	// Type of the NSX resource.
	TargetType *string `json:"target_type,omitempty" yaml:"target_type,omitempty" mapstructure:"target_type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceReference) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ResourceReference
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.TargetDisplayName != nil && len(*plain.TargetDisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "target_display_name", 255)
	}
	if plain.TargetId != nil && len(*plain.TargetId) > 64 {
		return fmt.Errorf("field %s length: must be <= %d", "target_id", 64)
	}
	if plain.TargetType != nil && len(*plain.TargetType) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "target_type", 255)
	}
	*j = ResourceReference(plain)
	return nil
}

// A rule indicates the action to be performed for various types of traffic flowing
// between workload groups.
type Rule struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// The action to be applied to all the services The JUMP_TO_APPLICATION action is
	// only supported for rules created in the Environment category. Once a match is
	// hit then the rule processing will jump to the rules present in the Application
	// category, skipping all further rules in the Environment category. If no rules
	// match in the Application category then the default application rule will be
	// hit. This is applicable only for DFW.
	Action *RuleAction `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// We need paths as duplicate names may exist for groups under different domains.
	// Along with paths we support IP Address of type IPv4 and IPv6. IP Address can be
	// in one of the format(CIDR, IP Address, Range of IP Address). In order to
	// specify all groups, use the constant "ANY". This is case insensitive. If "ANY"
	// is used, it should be the ONLY element in the group array. Error will be thrown
	// if ANY is used in conjunction with other values.
	DestinationGroups []string `json:"destination_groups,omitempty" yaml:"destination_groups,omitempty" mapstructure:"destination_groups,omitempty"`

	// If set to true, the rule gets applied on all the groups that are NOT part of
	// the destination groups. If false, the rule applies to the destination groups
	DestinationsExcluded bool `json:"destinations_excluded,omitempty" yaml:"destinations_excluded,omitempty" mapstructure:"destinations_excluded,omitempty"`

	// Define direction of traffic.
	Direction RuleDirection `json:"direction,omitempty" yaml:"direction,omitempty" mapstructure:"direction,omitempty"`

	// Flag to deactivate the rule. Default is activated.
	Disabled bool `json:"disabled,omitempty" yaml:"disabled,omitempty" mapstructure:"disabled,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Type of IP packet that should be matched while enforcing the rule. The value is
	// set to IPV4_IPV6 for Layer3 rule if not specified. For Layer2/Ether rule the
	// value must be null.
	IpProtocol *RuleIpProtocol `json:"ip_protocol,omitempty" yaml:"ip_protocol,omitempty" mapstructure:"ip_protocol,omitempty"`

	// A flag to indicate whether rule is a default rule.
	IsDefault *bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// Flag to enable packet logging. Default is deactivated.
	Logged bool `json:"logged,omitempty" yaml:"logged,omitempty" mapstructure:"logged,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// Text for additional notes on changes.
	Notes *string `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Holds the list of layer 7 service profile paths. These profiles accept
	// attributes and sub-attributes of various network services (e.g. L4 AppId,
	// encryption algorithm, domain name, etc) as key value pairs. Instead of Layer 7
	// service profiles you can use a L7 access profile. One of either Layer 7 service
	// profiles or L7 Access Profile can be used in firewall rule. In case of L7
	// access profile only one is allowed.
	Profiles []string `json:"profiles,omitempty" yaml:"profiles,omitempty" mapstructure:"profiles,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// This is a unique 4 byte positive number that is assigned by the system.  This
	// rule id is passed all the way down to the data path. The first 1GB (1000 to
	// 2^30) will be shared by GM and LM with zebra style striped number space. For
	// E.g 1000 to (1Million -1) by LM, (1M - 2M-1) by GM and so on.
	RuleId *int `json:"rule_id,omitempty" yaml:"rule_id,omitempty" mapstructure:"rule_id,omitempty"`

	// The list of policy paths where the rule is applied LR/Edge/T0/T1/LRP etc. Note
	// that a given rule can be applied on multiple LRs/LRPs.
	Scope []string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// This field is used to resolve conflicts between multiple Rules under Security
	// or Gateway Policy for a Domain If no sequence number is specified in the
	// payload, a value of 0 is assigned by default. If there are multiple rules with
	// the same sequence number then their order is not deterministic. If a specific
	// order of rules is desired, then one has to specify unique sequence numbers or
	// use the POST request on the rule entity with a query parameter action=revise to
	// let the framework assign a sequence number
	SequenceNumber *int `json:"sequence_number,omitempty" yaml:"sequence_number,omitempty" mapstructure:"sequence_number,omitempty"`

	// In order to specify raw services this can be used, along with services which
	// contains path to services. This can be empty or null.
	ServiceEntries []ServiceEntry `json:"service_entries,omitempty" yaml:"service_entries,omitempty" mapstructure:"service_entries,omitempty"`

	// In order to specify all services, use the constant "ANY". This is case
	// insensitive. If "ANY" is used, it should be the ONLY element in the services
	// array. Error will be thrown if ANY is used in conjunction with other values.
	Services []string `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`

	// We need paths as duplicate names may exist for groups under different domains.
	// Along with paths we support IP Address of type IPv4 and IPv6. IP Address can be
	// in one of the format(CIDR, IP Address, Range of IP Address). In order to
	// specify all groups, use the constant "ANY". This is case insensitive. If "ANY"
	// is used, it should be the ONLY element in the group array. Error will be thrown
	// if ANY is used in conjunction with other values.
	SourceGroups []string `json:"source_groups,omitempty" yaml:"source_groups,omitempty" mapstructure:"source_groups,omitempty"`

	// If set to true, the rule gets applied on all the groups that are NOT part of
	// the source groups. If false, the rule applies to the source groups
	SourcesExcluded bool `json:"sources_excluded,omitempty" yaml:"sources_excluded,omitempty" mapstructure:"sources_excluded,omitempty"`

	// User level field which will be printed in CLI and packet logs. Even though
	// there is no limitation on length of a tag, internally tag will get truncated
	// after 32 characters.
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type RuleAction string

const RuleActionALLOW RuleAction = "ALLOW"
const RuleActionDROP RuleAction = "DROP"
const RuleActionJUMPTOAPPLICATION RuleAction = "JUMP_TO_APPLICATION"
const RuleActionREJECT RuleAction = "REJECT"

var enumValues_RuleAction = []interface{}{
	"ALLOW",
	"DROP",
	"REJECT",
	"JUMP_TO_APPLICATION",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RuleAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RuleAction, v)
	}
	*j = RuleAction(v)
	return nil
}

type RuleDirection string

const RuleDirectionIN RuleDirection = "IN"
const RuleDirectionINOUT RuleDirection = "IN_OUT"
const RuleDirectionOUT RuleDirection = "OUT"

var enumValues_RuleDirection = []interface{}{
	"IN",
	"OUT",
	"IN_OUT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleDirection) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RuleDirection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RuleDirection, v)
	}
	*j = RuleDirection(v)
	return nil
}

type RuleIpProtocol string

const RuleIpProtocolIPV4 RuleIpProtocol = "IPV4"
const RuleIpProtocolIPV4IPV6 RuleIpProtocol = "IPV4_IPV6"
const RuleIpProtocolIPV6 RuleIpProtocol = "IPV6"

var enumValues_RuleIpProtocol = []interface{}{
	"IPV4",
	"IPV6",
	"IPV4_IPV6",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleIpProtocol) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RuleIpProtocol {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RuleIpProtocol, v)
	}
	*j = RuleIpProtocol(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Rule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Rule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if len(plain.DestinationGroups) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "destination_groups", 128)
	}
	if v, ok := raw["destinations_excluded"]; !ok || v == nil {
		plain.DestinationsExcluded = false
	}
	if v, ok := raw["direction"]; !ok || v == nil {
		plain.Direction = "IN_OUT"
	}
	if v, ok := raw["disabled"]; !ok || v == nil {
		plain.Disabled = false
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["logged"]; !ok || v == nil {
		plain.Logged = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if plain.Notes != nil && len(*plain.Notes) > 2048 {
		return fmt.Errorf("field %s length: must be <= %d", "notes", 2048)
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Profiles) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "profiles", 128)
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if len(plain.ServiceEntries) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "service_entries", 128)
	}
	if len(plain.Services) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "services", 128)
	}
	if len(plain.SourceGroups) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "source_groups", 128)
	}
	if v, ok := raw["sources_excluded"]; !ok || v == nil {
		plain.SourcesExcluded = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Rule(plain)
	return nil
}

// Ordered list of Rules.
type SecurityPolicy struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// This field indicates the application connectivity policy for the security
	// policy.
	ApplicationConnectivityStrategy []ApplicationConnectivityStrategy `json:"application_connectivity_strategy,omitempty" yaml:"application_connectivity_strategy,omitempty" mapstructure:"application_connectivity_strategy,omitempty"`

	// - Distributed Firewall - Policy framework provides five pre-defined categories
	// for classifying a security policy. They are "Ethernet","Emergency",
	// "Infrastructure" "Environment" and "Application". There is a pre-determined
	// order in which the policy framework manages the priority of these security
	// policies. Ethernet category is for supporting layer 2 firewall rules. The other
	// four categories are applicable for layer 3 rules. Amongst them, the Emergency
	// category has the highest priority followed by Infrastructure, Environment and
	// then Application rules. Administrator can choose to categorize a security
	// policy into the above categories or can choose to leave it empty. If empty it
	// will have the least precedence w.r.t the above four categories. - Edge Firewall
	// - Policy Framework for Edge Firewall provides six pre-defined categories
	// "Emergency", "SystemRules", "SharedPreRules", "LocalGatewayRules",
	// "AutoServiceRules" and "Default", in order of priority of rules. All categories
	// are allowed for Gatetway Policies that belong to 'default' Domain. However, for
	// user created domains, category is restricted to "SharedPreRules" or
	// "LocalGatewayRules" only. Also, the users can add/modify/delete rules from only
	// the "SharedPreRules" and "LocalGatewayRules" categories. If user doesn't
	// specify the category then defaulted to "Rules". System generated category is
	// used by NSX created rules, for example BFD rules. Autoplumbed category used by
	// NSX verticals to autoplumb data path rules. Finally, "Default" category is the
	// placeholder default rules with lowest in the order of priority.
	Category *string `json:"category,omitempty" yaml:"category,omitempty" mapstructure:"category,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Comments for security policy lock/unlock.
	Comments *string `json:"comments,omitempty" yaml:"comments,omitempty" mapstructure:"comments,omitempty"`

	// This field indicates the default connectivity policy for the security policy.
	// Based on the connectivity preference, a default rule for this security policy
	// will be created. An appropriate action will be set on the rule based on the
	// value of the connectivity preference. If NONE is selected or no connectivity
	// preference is specified, then no default rule for the security policy gets
	// created. The default rule that gets created will be a any-any rule and applied
	// to entities specified in the scope of the security policy. Specifying the
	// connectivity_preference without specifying the scope is not allowed. The scope
	// has to be a Group and one cannot specify IPAddress directly in the group that
	// is used as scope. This default rule is only applicable for the Layer3 security
	// policies. ALLOWLIST - Adds a default drop rule. Administrator can then use
	// "allow" rules to allow traffic between groups DENYLIST - Adds a default allow
	// rule. Admin can then use "drop" rules to block traffic between groups
	// ALLOWLIST_ENABLE_LOGGING - Allowlisting with logging enabled
	// DENYLIST_ENABLE_LOGGING - Denylisting with logging enabled NONE - No default
	// rule is created.
	ConnectivityPreference *SecurityPolicyConnectivityPreference `json:"connectivity_preference,omitempty" yaml:"connectivity_preference,omitempty" mapstructure:"connectivity_preference,omitempty"`

	// This field indicates the default connectivity policy for the security policy.
	// Based on the connectivity strategy, a default rule for this security policy
	// will be created. An appropriate action will be set on the rule based on the
	// value of the connectivity strategy. If NONE is selected or no connectivity
	// strategy is specified, then no default rule for the security policy gets
	// created. The default rule that gets created will be a any-any rule and applied
	// to entities specified in the scope of the security policy. Specifying the
	// connectivity_strategy without specifying the scope is not allowed. The scope
	// has to be a Group and one cannot specify IPAddress directly in the group that
	// is used as scope. This default rule is only applicable for the Layer3 security
	// policies. This property is deprecated. Use the type connectivity_preference
	// instead. WHITELIST - Adds a default drop rule. Administrator can then use
	// "allow" rules (aka whitelist) to allow traffic between groups BLACKLIST - Adds
	// a default allow rule. Admin can then use "drop" rules (aka blacklist) to block
	// traffic between groups WHITELIST_ENABLE_LOGGING - Whitelising with logging
	// enabled BLACKLIST_ENABLE_LOGGING - Blacklisting with logging enabled NONE - No
	// default rule is created.
	ConnectivityStrategy *SecurityPolicyConnectivityStrategy `json:"connectivity_strategy,omitempty" yaml:"connectivity_strategy,omitempty" mapstructure:"connectivity_strategy,omitempty"`

	// Based on the value of the connectivity strategy, a default rule is created for
	// the security policy. The rule id is internally assigned by the system for this
	// default rule.
	DefaultRuleId *int `json:"default_rule_id,omitempty" yaml:"default_rule_id,omitempty" mapstructure:"default_rule_id,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// This field is to indicate the internal sequence number of a policy with respect
	// to the policies across categories.
	InternalSequenceNumber *int `json:"internal_sequence_number,omitempty" yaml:"internal_sequence_number,omitempty" mapstructure:"internal_sequence_number,omitempty"`

	// A flag to indicate whether policy is a default policy.
	IsDefault *bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// ID of the user who last modified the lock for the secruity policy.
	LockModifiedBy *string `json:"lock_modified_by,omitempty" yaml:"lock_modified_by,omitempty" mapstructure:"lock_modified_by,omitempty"`

	// SecurityPolicy locked/unlocked time in epoch milliseconds.
	LockModifiedTime *EpochMsTimestamp `json:"lock_modified_time,omitempty" yaml:"lock_modified_time,omitempty" mapstructure:"lock_modified_time,omitempty"`

	// Indicates whether a security policy should be locked. If the security policy is
	// locked by a user, then no other user would be able to modify this security
	// policy. Once the user releases the lock, other users can update this security
	// policy.
	Locked bool `json:"locked,omitempty" yaml:"locked,omitempty" mapstructure:"locked,omitempty"`

	// This property is deprecated. Flag to enable logging for all the rules in the
	// security policy. If the value is true then logging will be enabled for all the
	// rules in the security policy. If the value is false, then the rule level
	// logging value will be honored.
	LoggingEnabled bool `json:"logging_enabled,omitempty" yaml:"logging_enabled,omitempty" mapstructure:"logging_enabled,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// The count of rules in the policy.
	RuleCount *int `json:"rule_count,omitempty" yaml:"rule_count,omitempty" mapstructure:"rule_count,omitempty"`

	// Rules corresponds to the JSON schema field "rules".
	Rules []Rule `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// Provides a mechanism to apply the rules in this policy for a specified time
	// duration.
	SchedulerPath *string `json:"scheduler_path,omitempty" yaml:"scheduler_path,omitempty" mapstructure:"scheduler_path,omitempty"`

	// The list of group paths where the rules in this policy will get applied. This
	// scope will take precedence over rule level scope. Supported only for security
	// and redirection policies. In case of RedirectionPolicy, it is expected only
	// when the policy is NS and redirecting to service chain.
	Scope []string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// This field is used to resolve conflicts between security policies across
	// domains. In order to change the sequence number of a policy one can fire a POST
	// request on the policy entity with a query parameter action=revise The sequence
	// number field will reflect the value of the computed sequence number upon
	// execution of the above mentioned POST request. For scenarios where the
	// administrator is using a template to update several security policies, the only
	// way to set the sequence number is to explicitly specify the sequence number for
	// each security policy. If no sequence number is specified in the payload, a
	// value of 0 is assigned by default. If there are multiple policies with the same
	// sequence number then their order is not deterministic. If a specific order of
	// policies is desired, then one has to specify unique sequence numbers or use the
	// POST request on the policy entity with a query parameter action=revise to let
	// the framework assign a sequence number. The value of sequence number must be
	// between 0 and 999,999.
	SequenceNumber *int `json:"sequence_number,omitempty" yaml:"sequence_number,omitempty" mapstructure:"sequence_number,omitempty"`

	// Stateful or Stateless nature of security policy is enforced on all rules in
	// this security policy. When it is stateful, the state of the network connects
	// are tracked and a stateful packet inspection is performed. Layer3 security
	// policies can be stateful or stateless. By default, they are stateful. Layer2
	// security policies can only be stateless.
	Stateful *bool `json:"stateful,omitempty" yaml:"stateful,omitempty" mapstructure:"stateful,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Ensures that a 3 way TCP handshake is done before the data packets are sent.
	// tcp_strict=true is supported only for stateful security policies. If the
	// tcp_strict flag is not specified and the security policy is stateful, then
	// tcp_strict will be set to true.
	TcpStrict *bool `json:"tcp_strict,omitempty" yaml:"tcp_strict,omitempty" mapstructure:"tcp_strict,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type SecurityPolicyConnectivityPreference string

const SecurityPolicyConnectivityPreferenceALLOWLIST SecurityPolicyConnectivityPreference = "ALLOWLIST"
const SecurityPolicyConnectivityPreferenceALLOWLISTENABLELOGGING SecurityPolicyConnectivityPreference = "ALLOWLIST_ENABLE_LOGGING"
const SecurityPolicyConnectivityPreferenceDENYLIST SecurityPolicyConnectivityPreference = "DENYLIST"
const SecurityPolicyConnectivityPreferenceDENYLISTENABLELOGGING SecurityPolicyConnectivityPreference = "DENYLIST_ENABLE_LOGGING"
const SecurityPolicyConnectivityPreferenceNONE SecurityPolicyConnectivityPreference = "NONE"

var enumValues_SecurityPolicyConnectivityPreference = []interface{}{
	"ALLOWLIST",
	"DENYLIST",
	"ALLOWLIST_ENABLE_LOGGING",
	"DENYLIST_ENABLE_LOGGING",
	"NONE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SecurityPolicyConnectivityPreference) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SecurityPolicyConnectivityPreference {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SecurityPolicyConnectivityPreference, v)
	}
	*j = SecurityPolicyConnectivityPreference(v)
	return nil
}

type SecurityPolicyConnectivityStrategy string

const SecurityPolicyConnectivityStrategyBLACKLIST SecurityPolicyConnectivityStrategy = "BLACKLIST"
const SecurityPolicyConnectivityStrategyBLACKLISTENABLELOGGING SecurityPolicyConnectivityStrategy = "BLACKLIST_ENABLE_LOGGING"
const SecurityPolicyConnectivityStrategyNONE SecurityPolicyConnectivityStrategy = "NONE"
const SecurityPolicyConnectivityStrategyWHITELIST SecurityPolicyConnectivityStrategy = "WHITELIST"
const SecurityPolicyConnectivityStrategyWHITELISTENABLELOGGING SecurityPolicyConnectivityStrategy = "WHITELIST_ENABLE_LOGGING"

var enumValues_SecurityPolicyConnectivityStrategy = []interface{}{
	"WHITELIST",
	"BLACKLIST",
	"WHITELIST_ENABLE_LOGGING",
	"BLACKLIST_ENABLE_LOGGING",
	"NONE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SecurityPolicyConnectivityStrategy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SecurityPolicyConnectivityStrategy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SecurityPolicyConnectivityStrategy, v)
	}
	*j = SecurityPolicyConnectivityStrategy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SecurityPolicy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SecurityPolicy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.ApplicationConnectivityStrategy) > 3 {
		return fmt.Errorf("field %s length: must be <= %d", "application_connectivity_strategy", 3)
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["locked"]; !ok || v == nil {
		plain.Locked = false
	}
	if v, ok := raw["logging_enabled"]; !ok || v == nil {
		plain.LoggingEnabled = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = SecurityPolicy(plain)
	return nil
}

// The server will populate this field when returing the resource. Ignored on PUT
// and POST.
type SelfResourceLink struct {
	// Action corresponds to the JSON schema field "action".
	Action *string `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Href corresponds to the JSON schema field "href".
	Href *string `json:"href,omitempty" yaml:"href,omitempty" mapstructure:"href,omitempty"`

	// Custom relation type (follows RFC 5988 where appropriate definitions exist)
	Rel *string `json:"rel,omitempty" yaml:"rel,omitempty" mapstructure:"rel,omitempty"`
}

type ServiceEntry struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ServiceEntryResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ServiceEntryResourceType string

const ServiceEntryResourceTypeALGTypeServiceEntry ServiceEntryResourceType = "ALGTypeServiceEntry"
const ServiceEntryResourceTypeEtherTypeServiceEntry ServiceEntryResourceType = "EtherTypeServiceEntry"
const ServiceEntryResourceTypeICMPTypeServiceEntry ServiceEntryResourceType = "ICMPTypeServiceEntry"
const ServiceEntryResourceTypeIGMPTypeServiceEntry ServiceEntryResourceType = "IGMPTypeServiceEntry"
const ServiceEntryResourceTypeIPProtocolServiceEntry ServiceEntryResourceType = "IPProtocolServiceEntry"
const ServiceEntryResourceTypeL4PortSetServiceEntry ServiceEntryResourceType = "L4PortSetServiceEntry"
const ServiceEntryResourceTypeNestedServiceServiceEntry ServiceEntryResourceType = "NestedServiceServiceEntry"

var enumValues_ServiceEntryResourceType = []interface{}{
	"IPProtocolServiceEntry",
	"IGMPTypeServiceEntry",
	"ICMPTypeServiceEntry",
	"ALGTypeServiceEntry",
	"L4PortSetServiceEntry",
	"EtherTypeServiceEntry",
	"NestedServiceServiceEntry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServiceEntryResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ServiceEntryResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ServiceEntryResourceType, v)
	}
	*j = ServiceEntryResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServiceEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ServiceEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = ServiceEntry(plain)
	return nil
}

type Tag struct {
	// Tag searches may optionally be restricted by scope
	Scope string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// Identifier meaningful to user with maximum length of 256 characters
	Tag string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tag) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Tag
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["scope"]; !ok || v == nil {
		plain.Scope = ""
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if v, ok := raw["tag"]; !ok || v == nil {
		plain.Tag = ""
	}
	*j = Tag(plain)
	return nil
}

type VirtualMachine struct {
	// Timestamp of last modification
	LastSyncTime *EpochMsTimestamp `json:"_last_sync_time,omitempty" yaml:"_last_sync_time,omitempty" mapstructure:"_last_sync_time,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// ComputeIds corresponds to the JSON schema field "compute_ids".
	ComputeIds []string `json:"compute_ids,omitempty" yaml:"compute_ids,omitempty" mapstructure:"compute_ids,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// ExternalId corresponds to the JSON schema field "external_id".
	ExternalId *string `json:"external_id,omitempty" yaml:"external_id,omitempty" mapstructure:"external_id,omitempty"`

	// Guest virtual machine details include OS name, computer name of guest VM.
	// Currently this is supported for guests on ESXi that have VMware Tools
	// installed.
	GuestInfo *GuestInfo `json:"guest_info,omitempty" yaml:"guest_info,omitempty" mapstructure:"guest_info,omitempty"`

	// HostId corresponds to the JSON schema field "host_id".
	HostId *string `json:"host_id,omitempty" yaml:"host_id,omitempty" mapstructure:"host_id,omitempty"`

	// LocalIdOnHost corresponds to the JSON schema field "local_id_on_host".
	LocalIdOnHost *string `json:"local_id_on_host,omitempty" yaml:"local_id_on_host,omitempty" mapstructure:"local_id_on_host,omitempty"`

	// PowerState corresponds to the JSON schema field "power_state".
	PowerState *VirtualMachinePowerState `json:"power_state,omitempty" yaml:"power_state,omitempty" mapstructure:"power_state,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Specifies runtime details of virtual machine.
	RuntimeInfo *VirtualMachineRuntimeInfo `json:"runtime_info,omitempty" yaml:"runtime_info,omitempty" mapstructure:"runtime_info,omitempty"`

	// Specifies list of scope of discovered resource. e.g. if VHC path is associated
	// with principal identity, who owns the discovered resource, then scope id will
	// be VHC path and scope type will be VHC.
	Scope []DiscoveredResourceScope `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// Source corresponds to the JSON schema field "source".
	Source *ResourceReference `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *VirtualMachineType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// If UPT enabled is true for any virtual network interface of the virtual
	// machine, then this property is true for the virtual machine.
	Uptv2Enabled *bool `json:"uptv2_enabled,omitempty" yaml:"uptv2_enabled,omitempty" mapstructure:"uptv2_enabled,omitempty"`
}

type VirtualMachinePowerState string

const VirtualMachinePowerStateUNKNOWN VirtualMachinePowerState = "UNKNOWN"
const VirtualMachinePowerStateVMRUNNING VirtualMachinePowerState = "VM_RUNNING"
const VirtualMachinePowerStateVMSTOPPED VirtualMachinePowerState = "VM_STOPPED"
const VirtualMachinePowerStateVMSUSPENDED VirtualMachinePowerState = "VM_SUSPENDED"

var enumValues_VirtualMachinePowerState = []interface{}{
	"VM_RUNNING",
	"VM_STOPPED",
	"VM_SUSPENDED",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualMachinePowerState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VirtualMachinePowerState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VirtualMachinePowerState, v)
	}
	*j = VirtualMachinePowerState(v)
	return nil
}

// Specifies details of runtime for a virtual machine
type VirtualMachineRuntimeInfo struct {
	// Specifies list of runtime details of virtual network interfaces of virtual
	// machine.
	VifRuntimeInfo []VirtualNetworkInterfaceRuntimeInfo `json:"vif_runtime_info,omitempty" yaml:"vif_runtime_info,omitempty" mapstructure:"vif_runtime_info,omitempty"`
}

type VirtualMachineType string

const VirtualMachineTypeEDGE VirtualMachineType = "EDGE"
const VirtualMachineTypeINTELLIGENCE VirtualMachineType = "INTELLIGENCE"
const VirtualMachineTypeMP VirtualMachineType = "MP"
const VirtualMachineTypeREGULAR VirtualMachineType = "REGULAR"
const VirtualMachineTypeSERVICE VirtualMachineType = "SERVICE"
const VirtualMachineTypeUNKNOWN VirtualMachineType = "UNKNOWN"
const VirtualMachineTypeVCSYSTEM VirtualMachineType = "VC_SYSTEM"

var enumValues_VirtualMachineType = []interface{}{
	"EDGE",
	"SERVICE",
	"REGULAR",
	"MP",
	"INTELLIGENCE",
	"VC_SYSTEM",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualMachineType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VirtualMachineType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VirtualMachineType, v)
	}
	*j = VirtualMachineType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualMachine) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VirtualMachine
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = VirtualMachine(plain)
	return nil
}

// Runtime details of virtual network interface of virtual machine.
type VirtualNetworkInterfaceRuntimeInfo struct {
	// ExternalId corresponds to the JSON schema field "external_id".
	ExternalId *string `json:"external_id,omitempty" yaml:"external_id,omitempty" mapstructure:"external_id,omitempty"`

	// This flag specifies whether UPTv2 (Universal Pass-through version 2) is active
	// on the virtual network interface or not. If TRUE, then the virtual network
	// interface works in the pass-through mode. If FALSE, then the virtual network
	// interface still has network connectivity but works in emulated mode and
	// pass-through is not enabled. This flag is NONE, if it is not applicable.
	Uptv2Active *VirtualNetworkInterfaceRuntimeInfoUptv2Active `json:"uptv2_active,omitempty" yaml:"uptv2_active,omitempty" mapstructure:"uptv2_active,omitempty"`
}

type VirtualNetworkInterfaceRuntimeInfoUptv2Active string

const VirtualNetworkInterfaceRuntimeInfoUptv2ActiveNONE VirtualNetworkInterfaceRuntimeInfoUptv2Active = "NONE"

var enumValues_VirtualNetworkInterfaceRuntimeInfoUptv2Active = []interface{}{
	"NONE",
	true,
	false,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualNetworkInterfaceRuntimeInfoUptv2Active) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VirtualNetworkInterfaceRuntimeInfoUptv2Active {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VirtualNetworkInterfaceRuntimeInfoUptv2Active, v)
	}
	*j = VirtualNetworkInterfaceRuntimeInfoUptv2Active(v)
	return nil
}
