// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package resources

import "encoding/json"
import "fmt"
import "reflect"

// Allows more granular policies for application workloads
type ApplicationConnectivityStrategy struct {
	// App connectivity strategies
	ApplicationConnectivityStrategy *ApplicationConnectivityStrategyApplicationConnectivityStrategy `json:"application_connectivity_strategy,omitempty" yaml:"application_connectivity_strategy,omitempty" mapstructure:"application_connectivity_strategy,omitempty"`

	// Based on the value of the app connectivity strategy, a default rule is created
	// for the security policy. The rule id is internally assigned by the system for
	// this default rule.
	DefaultApplicationRuleId *int `json:"default_application_rule_id,omitempty" yaml:"default_application_rule_id,omitempty" mapstructure:"default_application_rule_id,omitempty"`

	// Flag to enable packet logging. Default is deactivated.
	LoggingEnabled bool `json:"logging_enabled,omitempty" yaml:"logging_enabled,omitempty" mapstructure:"logging_enabled,omitempty"`
}

type ApplicationConnectivityStrategyApplicationConnectivityStrategy string

const ApplicationConnectivityStrategyApplicationConnectivityStrategyALLOWEGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "ALLOW_EGRESS"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyALLOWINGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "ALLOW_INGRESS"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyALLOWINTRA ApplicationConnectivityStrategyApplicationConnectivityStrategy = "ALLOW_INTRA"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyDROPEGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "DROP_EGRESS"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyDROPINGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "DROP_INGRESS"

var enumValues_ApplicationConnectivityStrategyApplicationConnectivityStrategy = []interface{}{
	"ALLOW_INTRA",
	"ALLOW_EGRESS",
	"ALLOW_INGRESS",
	"DROP_INGRESS",
	"DROP_EGRESS",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApplicationConnectivityStrategyApplicationConnectivityStrategy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApplicationConnectivityStrategyApplicationConnectivityStrategy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApplicationConnectivityStrategyApplicationConnectivityStrategy, v)
	}
	*j = ApplicationConnectivityStrategyApplicationConnectivityStrategy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApplicationConnectivityStrategy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ApplicationConnectivityStrategy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["logging_enabled"]; !ok || v == nil {
		plain.LoggingEnabled = false
	}
	*j = ApplicationConnectivityStrategy(plain)
	return nil
}

// The Attached interface is only effective for the segment port on Bare metal
// server.
type AttachedInterfaceEntry struct {
	// AppIntfName corresponds to the JSON schema field "app_intf_name".
	AppIntfName *string `json:"app_intf_name,omitempty" yaml:"app_intf_name,omitempty" mapstructure:"app_intf_name,omitempty"`

	// DefaultGateway corresponds to the JSON schema field "default_gateway".
	DefaultGateway *IPAddress `json:"default_gateway,omitempty" yaml:"default_gateway,omitempty" mapstructure:"default_gateway,omitempty"`

	// IP configuration on migrate_intf will migrate to app_intf_name. It is used for
	// Management and Application sharing the same IP.
	MigrateIntf *string `json:"migrate_intf,omitempty" yaml:"migrate_intf,omitempty" mapstructure:"migrate_intf,omitempty"`

	// RoutingTable corresponds to the JSON schema field "routing_table".
	RoutingTable []string `json:"routing_table,omitempty" yaml:"routing_table,omitempty" mapstructure:"routing_table,omitempty"`
}

// configuration parameters for Bridge Profile
type BridgeProfileConfig struct {
	// Same bridge profile can be configured on different segments. Each bridge
	// profile on a segment must unique.
	BridgeProfilePath *string `json:"bridge_profile_path,omitempty" yaml:"bridge_profile_path,omitempty" mapstructure:"bridge_profile_path,omitempty"`

	// The name of the switching uplink teaming policy for the bridge endpoint. This
	// name corresponds to one of the switching uplink teaming policy names listed in
	// the VLAN transport zone specified by the property "vlan_transport_zone_path".
	// When this property is not specified, the default teaming policy of the
	// host-switch is assigned. Do not set a value when the 'bridge_profile_path' is
	// the path of L2DistributedBridgeEndpointProfile.
	UplinkTeamingPolicyName *string `json:"uplink_teaming_policy_name,omitempty" yaml:"uplink_teaming_policy_name,omitempty" mapstructure:"uplink_teaming_policy_name,omitempty"`

	// VLAN specification for bridge endpoint. Either VLAN ID or VLAN ranges can be
	// specified. Not both.
	VlanIds []string `json:"vlan_ids,omitempty" yaml:"vlan_ids,omitempty" mapstructure:"vlan_ids,omitempty"`

	// The path of the VLAN transport zone that represents the underlay L2 zone in
	// which the VLANs will be bridged to overlay segments. A unique VLAN transport
	// zone should be assigned to each underlay L2 zone when needed for bridging. If
	// two VLANs in two underlay L2 zones are combined together as one L2
	// broadcast-domain by certain L2 extension, the two underlay L2 zones still
	// should have two different VLAN transport zones assigned to them. It is optional
	// for distributed-bridging but required for other bridging modes. If it is not
	// given, the distributed bridge will span all ESX transport nodes in the overlay
	// transport zone of the segment that contains this profile.
	VlanTransportZonePath *string `json:"vlan_transport_zone_path,omitempty" yaml:"vlan_transport_zone_path,omitempty" mapstructure:"vlan_transport_zone_path,omitempty"`
}

// Represents an object on the desired state
type ChildPolicyConfigResource struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// MarkForOverride corresponds to the JSON schema field "mark_for_override".
	MarkForOverride bool `json:"mark_for_override,omitempty" yaml:"mark_for_override,omitempty" mapstructure:"mark_for_override,omitempty"`

	// If this field is set to true, delete operation is triggered on the intent tree.
	// This resource along with its all children in intent tree will be deleted. This
	// is a cascade delete and should only be used if intent object along with its all
	// children are to be deleted. This does not support deletion of single non-leaf
	// node within the tree and should be used carefully.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// RequestParameter corresponds to the JSON schema field "request_parameter".
	RequestParameter *PolicyRequestParameter `json:"request_parameter,omitempty" yaml:"request_parameter,omitempty" mapstructure:"request_parameter,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChildPolicyConfigResource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ChildPolicyConfigResource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["mark_for_override"]; !ok || v == nil {
		plain.MarkForOverride = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = ChildPolicyConfigResource(plain)
	return nil
}

// Represents the leaf level condition. Evaluation of the condition expression will
// be case insensitive.
type Condition struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// List of members to be excluded from the condition. This field is applicable
	// only for condition representing the list of malicious IPs. Only
	// IPAddressExpression and PathExpression are supported. The PathExpression should
	// have paths of Groups that of the group_type IPAddress. Multiple PathExpressions
	// are not supported here.
	Exclude *ExcludedMembersList `json:"exclude,omitempty" yaml:"exclude,omitempty" mapstructure:"exclude,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *ConditionKey `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// For global groups (groups created from Global Manager), the supported Member
	// Types are - VirtualMachine, Segment, SegmentPort, Group, DVPG and DVPort. For
	// local groups (groups created on the local policy manager), the supported member
	// types are IPSet, VirtualMachine, LogicalPort, LogicalSwitch, Segment,
	// SegmentPort, Pod, Service, Namespace, TransportNode, Group, DVPG, DVPort,
	// KubernetesCluster, KubernetesNamespace, AntreaEgress, AntreaIPPool,
	// KubernetesIngress, KubernetesGateway, KubernetesService and KubernetesNode.
	MemberType *ConditionMemberType `json:"member_type,omitempty" yaml:"member_type,omitempty" mapstructure:"member_type,omitempty"`

	// Operator is made non-mandatory to support Segment and SegmentPort tag based
	// expression. To evaluate expression for other types, operator value should be
	// provided.
	Operator *ConditionOperator `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ConditionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Default operator when not specified explicitly would be considered as EQUALS.
	// If value for Condition is empty, then condition will not be evaluated. For
	// example, Condition with key as Tag and value as "|tag" would be evaluated for
	// tag value not for empty scope value.
	ScopeOperator *ConditionScopeOperator `json:"scope_operator,omitempty" yaml:"scope_operator,omitempty" mapstructure:"scope_operator,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type ConditionKey string

const ConditionKeyALL ConditionKey = "ALL"
const ConditionKeyComputerName ConditionKey = "ComputerName"
const ConditionKeyGroupType ConditionKey = "GroupType"
const ConditionKeyIPAddress ConditionKey = "IPAddress"
const ConditionKeyName ConditionKey = "Name"
const ConditionKeyNodeType ConditionKey = "NodeType"
const ConditionKeyOSName ConditionKey = "OSName"
const ConditionKeyPodCidr ConditionKey = "PodCidr"
const ConditionKeyTag ConditionKey = "Tag"

var enumValues_ConditionKey = []interface{}{
	"Tag",
	"Name",
	"OSName",
	"ComputerName",
	"NodeType",
	"GroupType",
	"ALL",
	"IPAddress",
	"PodCidr",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionKey) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionKey {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionKey, v)
	}
	*j = ConditionKey(v)
	return nil
}

type ConditionMemberType string

const ConditionMemberTypeAntreaEgress ConditionMemberType = "AntreaEgress"
const ConditionMemberTypeAntreaIPPool ConditionMemberType = "AntreaIPPool"
const ConditionMemberTypeDVPG ConditionMemberType = "DVPG"
const ConditionMemberTypeDVPort ConditionMemberType = "DVPort"
const ConditionMemberTypeGroup ConditionMemberType = "Group"
const ConditionMemberTypeIPAddress ConditionMemberType = "IPAddress"
const ConditionMemberTypeIPSet ConditionMemberType = "IPSet"
const ConditionMemberTypeKubernetesCluster ConditionMemberType = "KubernetesCluster"
const ConditionMemberTypeKubernetesGateway ConditionMemberType = "KubernetesGateway"
const ConditionMemberTypeKubernetesIngress ConditionMemberType = "KubernetesIngress"
const ConditionMemberTypeKubernetesNamespace ConditionMemberType = "KubernetesNamespace"
const ConditionMemberTypeKubernetesNode ConditionMemberType = "KubernetesNode"
const ConditionMemberTypeKubernetesService ConditionMemberType = "KubernetesService"
const ConditionMemberTypeLogicalPort ConditionMemberType = "LogicalPort"
const ConditionMemberTypeLogicalSwitch ConditionMemberType = "LogicalSwitch"
const ConditionMemberTypeNamespace ConditionMemberType = "Namespace"
const ConditionMemberTypePod ConditionMemberType = "Pod"
const ConditionMemberTypeSegment ConditionMemberType = "Segment"
const ConditionMemberTypeSegmentPort ConditionMemberType = "SegmentPort"
const ConditionMemberTypeService ConditionMemberType = "Service"
const ConditionMemberTypeTransportNode ConditionMemberType = "TransportNode"
const ConditionMemberTypeVirtualMachine ConditionMemberType = "VirtualMachine"
const ConditionMemberTypeVpcSubnet ConditionMemberType = "VpcSubnet"
const ConditionMemberTypeVpcSubnetPort ConditionMemberType = "VpcSubnetPort"

var enumValues_ConditionMemberType = []interface{}{
	"IPSet",
	"VirtualMachine",
	"LogicalPort",
	"LogicalSwitch",
	"Segment",
	"SegmentPort",
	"Pod",
	"Service",
	"Namespace",
	"TransportNode",
	"Group",
	"DVPG",
	"DVPort",
	"IPAddress",
	"VpcSubnet",
	"KubernetesCluster",
	"KubernetesNamespace",
	"AntreaEgress",
	"AntreaIPPool",
	"KubernetesIngress",
	"KubernetesGateway",
	"KubernetesService",
	"KubernetesNode",
	"VpcSubnetPort",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionMemberType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionMemberType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionMemberType, v)
	}
	*j = ConditionMemberType(v)
	return nil
}

type ConditionOperator string

const ConditionOperatorCONTAINS ConditionOperator = "CONTAINS"
const ConditionOperatorENDSWITH ConditionOperator = "ENDSWITH"
const ConditionOperatorEQUALS ConditionOperator = "EQUALS"
const ConditionOperatorIN ConditionOperator = "IN"
const ConditionOperatorMATCHES ConditionOperator = "MATCHES"
const ConditionOperatorNOTEQUALS ConditionOperator = "NOTEQUALS"
const ConditionOperatorNOTIN ConditionOperator = "NOTIN"
const ConditionOperatorSTARTSWITH ConditionOperator = "STARTSWITH"

var enumValues_ConditionOperator = []interface{}{
	"EQUALS",
	"CONTAINS",
	"STARTSWITH",
	"ENDSWITH",
	"NOTEQUALS",
	"NOTIN",
	"MATCHES",
	"IN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionOperator, v)
	}
	*j = ConditionOperator(v)
	return nil
}

type ConditionResourceType string

const ConditionResourceTypeCondition ConditionResourceType = "Condition"
const ConditionResourceTypeConjunctionOperator ConditionResourceType = "ConjunctionOperator"
const ConditionResourceTypeExternalIDExpression ConditionResourceType = "ExternalIDExpression"
const ConditionResourceTypeIPAddressExpression ConditionResourceType = "IPAddressExpression"
const ConditionResourceTypeIdentityGroupExpression ConditionResourceType = "IdentityGroupExpression"
const ConditionResourceTypeMACAddressExpression ConditionResourceType = "MACAddressExpression"
const ConditionResourceTypeNestedExpression ConditionResourceType = "NestedExpression"
const ConditionResourceTypePathExpression ConditionResourceType = "PathExpression"

var enumValues_ConditionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionResourceType, v)
	}
	*j = ConditionResourceType(v)
	return nil
}

type ConditionScopeOperator string

const ConditionScopeOperatorEQUALS ConditionScopeOperator = "EQUALS"
const ConditionScopeOperatorNOTEQUALS ConditionScopeOperator = "NOTEQUALS"

var enumValues_ConditionScopeOperator = []interface{}{
	"EQUALS",
	"NOTEQUALS",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionScopeOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionScopeOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionScopeOperator, v)
	}
	*j = ConditionScopeOperator(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Condition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Condition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	if plain.Value != nil && len(*plain.Value) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "value", 1)
	}
	*j = Condition(plain)
	return nil
}

type ConfigurationStateElement struct {
	// FailureCode corresponds to the JSON schema field "failure_code".
	FailureCode *int `json:"failure_code,omitempty" yaml:"failure_code,omitempty" mapstructure:"failure_code,omitempty"`

	// FailureMessage corresponds to the JSON schema field "failure_message".
	FailureMessage *string `json:"failure_message,omitempty" yaml:"failure_message,omitempty" mapstructure:"failure_message,omitempty"`

	// State corresponds to the JSON schema field "state".
	State *ConfigurationStateElementState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// SubSystemAddress corresponds to the JSON schema field "sub_system_address".
	SubSystemAddress *string `json:"sub_system_address,omitempty" yaml:"sub_system_address,omitempty" mapstructure:"sub_system_address,omitempty"`

	// SubSystemId corresponds to the JSON schema field "sub_system_id".
	SubSystemId *string `json:"sub_system_id,omitempty" yaml:"sub_system_id,omitempty" mapstructure:"sub_system_id,omitempty"`

	// SubSystemName corresponds to the JSON schema field "sub_system_name".
	SubSystemName *string `json:"sub_system_name,omitempty" yaml:"sub_system_name,omitempty" mapstructure:"sub_system_name,omitempty"`

	// SubSystemType corresponds to the JSON schema field "sub_system_type".
	SubSystemType *string `json:"sub_system_type,omitempty" yaml:"sub_system_type,omitempty" mapstructure:"sub_system_type,omitempty"`
}

type ConfigurationStateElementState string

const ConfigurationStateElementStateADVANCEDCONFIGEDITFAILED ConfigurationStateElementState = "ADVANCED_CONFIG_EDIT_FAILED"
const ConfigurationStateElementStateADVANCEDCONFIGEDITPENDING ConfigurationStateElementState = "ADVANCED_CONFIG_EDIT_PENDING"
const ConfigurationStateElementStateAPPLIANCEINTERNALERROR ConfigurationStateElementState = "APPLIANCE_INTERNAL_ERROR"
const ConfigurationStateElementStateCOMPUTEMANAGERNOTFOUND ConfigurationStateElementState = "COMPUTE_MANAGER_NOT_FOUND"
const ConfigurationStateElementStateCONFIGUREUPTONVMFAILED ConfigurationStateElementState = "CONFIGURE_UPT_ON_VM_FAILED"
const ConfigurationStateElementStateDATAPATHCONFIGURATIONEDITFAILED ConfigurationStateElementState = "DATAPATH_CONFIGURATION_EDIT_FAILED"
const ConfigurationStateElementStateDELETEFAILEDFORDIFFERENTMOREFID ConfigurationStateElementState = "DELETE_FAILED_FOR_DIFFERENT_MOREF_ID"
const ConfigurationStateElementStateDELETEFAILEDFORNONLCMEDGE ConfigurationStateElementState = "DELETE_FAILED_FOR_NON_LCM_EDGE"
const ConfigurationStateElementStateDELETEFAILEDONVMNOTFOUND ConfigurationStateElementState = "DELETE_FAILED_ON_VM_NOT_FOUND"
const ConfigurationStateElementStateDELETEINPROGRESS ConfigurationStateElementState = "DELETE_IN_PROGRESS"
const ConfigurationStateElementStateDELETEVMINREDEPLOYFAILED ConfigurationStateElementState = "DELETE_VM_IN_REDEPLOY_FAILED"
const ConfigurationStateElementStateDEPLOYVMINREDEPLOYFAILED ConfigurationStateElementState = "DEPLOY_VM_IN_REDEPLOY_FAILED"
const ConfigurationStateElementStateDUPLICATEPNICSINTEAMINGSWITHMULTIPLEUPLINKSANDFAILOVERORDER ConfigurationStateElementState = "DUPLICATE_PNICS_IN_TEAMINGS_WITH_MULTIPLE_UPLINKS_AND_FAILOVER_ORDER"
const ConfigurationStateElementStateDUPLICATEVLANSSHARINGSAMEPNIC ConfigurationStateElementState = "DUPLICATE_VLANS_SHARING_SAME_PNIC"
const ConfigurationStateElementStateDUPLICATEVLANSSHARINGSAMEPNICMULTIPLEUPLINKSINNAMEDTEAMINGNOTSUPPORTEDIFUPLINKINDEFAULTTEAMING ConfigurationStateElementState = "DUPLICATE_VLANS_SHARING_SAME_PNICMULTIPLE_UPLINKS_IN_NAMED_TEAMING_NOT_SUPPORTED_IF_UPLINK_IN_DEFAULT_TEAMING"
const ConfigurationStateElementStateEDGECONFIGERROR ConfigurationStateElementState = "EDGE_CONFIG_ERROR"
const ConfigurationStateElementStateEDGEHARDWARENOTSUPPORTED ConfigurationStateElementState = "EDGE_HARDWARE_NOT_SUPPORTED"
const ConfigurationStateElementStateEDGENODESETTINGSANDVSPHERESETTINGSARECHANGEDRESOLVE ConfigurationStateElementState = "EDGE_NODE_SETTINGS_AND_VSPHERE_SETTINGS_ARE_CHANGED_RESOLVE"
const ConfigurationStateElementStateEDGENODESETTINGSMISMATCHRESOLVE ConfigurationStateElementState = "EDGE_NODE_SETTINGS_MISMATCH_RESOLVE"
const ConfigurationStateElementStateEDGENODEVERSIONNOTSUPPORTED ConfigurationStateElementState = "EDGE_NODE_VERSION_NOT_SUPPORTED"
const ConfigurationStateElementStateEDGEVMVSPHERESETTINGSMISMATCHRESOLVE ConfigurationStateElementState = "EDGE_VM_VSPHERE_SETTINGS_MISMATCH_RESOLVE"
const ConfigurationStateElementStateEDGEVSPHERELOCATIONMISMATCHRESOLVE ConfigurationStateElementState = "EDGE_VSPHERE_LOCATION_MISMATCH_RESOLVE"
const ConfigurationStateElementStateERRORINDISABLEMAINTENANCEMODE ConfigurationStateElementState = "ERROR_IN_DISABLE_MAINTENANCE_MODE"
const ConfigurationStateElementStateERRORINENABLEMAINTENANCEMODE ConfigurationStateElementState = "ERROR_IN_ENABLE_MAINTENANCE_MODE"
const ConfigurationStateElementStateError ConfigurationStateElementState = "error"
const ConfigurationStateElementStateFailed ConfigurationStateElementState = "failed"
const ConfigurationStateElementStateHOSTSWITCHPROFILENOTFOUND ConfigurationStateElementState = "HOSTSWITCH_PROFILE_NOT_FOUND"
const ConfigurationStateElementStateINSUFFICIENTRESOURCESINEDGENODEFORSERVICE ConfigurationStateElementState = "INSUFFICIENT_RESOURCES_IN_EDGE_NODE_FOR_SERVICE"
const ConfigurationStateElementStateINVALIDPNICDEVICENAME ConfigurationStateElementState = "INVALID_PNIC_DEVICE_NAME"
const ConfigurationStateElementStateInProgress ConfigurationStateElementState = "in_progress"
const ConfigurationStateElementStateInSync ConfigurationStateElementState = "in_sync"
const ConfigurationStateElementStateLACPNOTSUPPORTEDFOREDGEVM ConfigurationStateElementState = "LACP_NOT_SUPPORTED_FOR_EDGE_VM"
const ConfigurationStateElementStateLBSRCIDNOTSUPPORTEDFOREDGEVM ConfigurationStateElementState = "LBSRCID_NOT_SUPPORTED_FOR_EDGE_VM"
const ConfigurationStateElementStateLLDPSENDENABLEDNOTSUPPORTED ConfigurationStateElementState = "LLDP_SEND_ENABLED_NOT_SUPPORTED"
const ConfigurationStateElementStateLOGICALSWITCHNAMEDTEAMINGHASNOPNICBACKING ConfigurationStateElementState = "LOGICAL_SWITCH_NAMED_TEAMING_HAS_NO_PNIC_BACKING"
const ConfigurationStateElementStateMAINTENANCEMODEENABLED ConfigurationStateElementState = "MAINTENANCE_MODE_ENABLED"
const ConfigurationStateElementStateMPADISCONNECTED ConfigurationStateElementState = "MPA_DISCONNECTED"
const ConfigurationStateElementStateMULTIPLEACTIVEUPLINKSNOTSUPPORTEDFOREDGE ConfigurationStateElementState = "MULTIPLE_ACTIVE_UPLINKS_NOT_SUPPORTED_FOR_EDGE"
const ConfigurationStateElementStateMULTIPLEOVERLAYTZSNOTSUPPORTED ConfigurationStateElementState = "MULTIPLE_OVERLAY_TZS_NOT_SUPPORTED"
const ConfigurationStateElementStateMULTIPLEUPLINKSINNAMEDTEAMINGNOTSUPPORTEDIFUPLINKINDEFAULTTEAMING ConfigurationStateElementState = "MULTIPLE_UPLINKS_IN_NAMED_TEAMING_NOT_SUPPORTED_IF_UPLINK_IN_DEFAULT_TEAMING"
const ConfigurationStateElementStateNODENOTREADY ConfigurationStateElementState = "NODE_NOT_READY"
const ConfigurationStateElementStateNODEREADY ConfigurationStateElementState = "NODE_READY"
const ConfigurationStateElementStateNOPNICPREPAREDINEDGE ConfigurationStateElementState = "NO_PNIC_PREPARED_IN_EDGE"
const ConfigurationStateElementStateNOPNICSPECIFIEDINTN ConfigurationStateElementState = "NO_PNIC_SPECIFIED_IN_TN"
const ConfigurationStateElementStateNOTAVAILABLE ConfigurationStateElementState = "NOT_AVAILABLE"
const ConfigurationStateElementStateOrphaned ConfigurationStateElementState = "orphaned"
const ConfigurationStateElementStatePartialSuccess ConfigurationStateElementState = "partial_success"
const ConfigurationStateElementStatePending ConfigurationStateElementState = "pending"
const ConfigurationStateElementStateREDEPLOYACTIVITYFAILED ConfigurationStateElementState = "REDEPLOY_ACTIVITY_FAILED"
const ConfigurationStateElementStateREDEPLOYACTIVITYINPROGRESS ConfigurationStateElementState = "REDEPLOY_ACTIVITY_IN_PROGRESS"
const ConfigurationStateElementStateREDEPLOYACTIVITYSCHEDULED ConfigurationStateElementState = "REDEPLOY_ACTIVITY_SCHEDULED"
const ConfigurationStateElementStateREDEPLOYACTIVITYSUCCESSFUL ConfigurationStateElementState = "REDEPLOY_ACTIVITY_SUCCESSFUL"
const ConfigurationStateElementStateREDEPLOYEDVMREGISTRATIONPENDING ConfigurationStateElementState = "REDEPLOYED_VM_REGISTRATION_PENDING"
const ConfigurationStateElementStateREGISTRATIONFAILED ConfigurationStateElementState = "REGISTRATION_FAILED"
const ConfigurationStateElementStateREGISTRATIONPENDING ConfigurationStateElementState = "REGISTRATION_PENDING"
const ConfigurationStateElementStateREGISTRATIONTIMEDOUT ConfigurationStateElementState = "REGISTRATION_TIMEDOUT"
const ConfigurationStateElementStateREPLACEACTIVITYFAILED ConfigurationStateElementState = "REPLACE_ACTIVITY_FAILED"
const ConfigurationStateElementStateREPLACEACTIVITYINPROGRESS ConfigurationStateElementState = "REPLACE_ACTIVITY_IN_PROGRESS"
const ConfigurationStateElementStateREPLACEACTIVITYSCHEDULED ConfigurationStateElementState = "REPLACE_ACTIVITY_SCHEDULED"
const ConfigurationStateElementStateREPLACEACTIVITYSUCCESSFUL ConfigurationStateElementState = "REPLACE_ACTIVITY_SUCCESSFUL"
const ConfigurationStateElementStateREPLACEDRPCCLIENTOFTN ConfigurationStateElementState = "REPLACED_RPC_CLIENT_OF_TN"
const ConfigurationStateElementStateREPLACEFAILED ConfigurationStateElementState = "REPLACE_FAILED"
const ConfigurationStateElementStateRETRYINGREPLACE ConfigurationStateElementState = "RETRYING_REPLACE"
const ConfigurationStateElementStateSTANDBYUPLINKSNOTSUPPORTEDFOREDGEVM ConfigurationStateElementState = "STANDBY_UPLINKS_NOT_SUPPORTED_FOR_EDGE_VM"
const ConfigurationStateElementStateSuccess ConfigurationStateElementState = "success"
const ConfigurationStateElementStateTNOVERLAYTZINUSEBYEDGECLUSTER ConfigurationStateElementState = "TN_OVERLAY_TZ_IN_USE_BY_EDGE_CLUSTER"
const ConfigurationStateElementStateTRANSPORTNODECONFIGURATIONMISSING ConfigurationStateElementState = "TRANSPORT_NODE_CONFIGURATION_MISSING"
const ConfigurationStateElementStateTRANSPORTNODEREADY ConfigurationStateElementState = "TRANSPORT_NODE_READY"
const ConfigurationStateElementStateTRANSPORTNODESYNCPENDING ConfigurationStateElementState = "TRANSPORT_NODE_SYNC_PENDING"
const ConfigurationStateElementStateTZENDPOINTSNOTSPECIFIED ConfigurationStateElementState = "TZ_ENDPOINTS_NOT_SPECIFIED"
const ConfigurationStateElementStateUNABLETODELETEEDGENODEVMINTERNALERROR ConfigurationStateElementState = "UNABLE_TO_DELETE_EDGE_NODE_VM_INTERNAL_ERROR"
const ConfigurationStateElementStateUNSUPPORTEDDEFAULTTEAMINGPOLICY ConfigurationStateElementState = "UNSUPPORTED_DEFAULT_TEAMING_POLICY"
const ConfigurationStateElementStateUNSUPPORTEDHOSTSWITCHPROFILE ConfigurationStateElementState = "UNSUPPORTED_HOST_SWITCH_PROFILE"
const ConfigurationStateElementStateUNSUPPORTEDLACPLBALGOFORNODE ConfigurationStateElementState = "UNSUPPORTED_LACP_LB_ALGO_FOR_NODE"
const ConfigurationStateElementStateUNSUPPORTEDNAMEDTEAMINGPOLICY ConfigurationStateElementState = "UNSUPPORTED_NAMED_TEAMING_POLICY"
const ConfigurationStateElementStateUPLINKFROMTEAMINGPOLICYNOTMAPPED ConfigurationStateElementState = "UPLINK_FROM_TEAMING_POLICY_NOT_MAPPED"
const ConfigurationStateElementStateUPLINKHOSTSWITCHPROFILENOTSPECIFIED ConfigurationStateElementState = "UPLINK_HOST_SWITCH_PROFILE_NOT_SPECIFIED"
const ConfigurationStateElementStateUPTMODEREALIZATIONPOLLTIMEDOUT ConfigurationStateElementState = "UPT_MODE_REALIZATION_POLL_TIMED_OUT"
const ConfigurationStateElementStateUnknown ConfigurationStateElementState = "unknown"
const ConfigurationStateElementStateVMCONFIGDISCREPANCY ConfigurationStateElementState = "VM_CONFIG_DISCREPANCY"
const ConfigurationStateElementStateVMCONFIGEDITFAILED ConfigurationStateElementState = "VM_CONFIG_EDIT_FAILED"
const ConfigurationStateElementStateVMCONFIGEDITPENDING ConfigurationStateElementState = "VM_CONFIG_EDIT_PENDING"
const ConfigurationStateElementStateVMDEPLOYMENTFAILED ConfigurationStateElementState = "VM_DEPLOYMENT_FAILED"
const ConfigurationStateElementStateVMDEPLOYMENTINPROGRESS ConfigurationStateElementState = "VM_DEPLOYMENT_IN_PROGRESS"
const ConfigurationStateElementStateVMDEPLOYMENTQUEUED ConfigurationStateElementState = "VM_DEPLOYMENT_QUEUED"
const ConfigurationStateElementStateVMDEPLOYMENTRESTARTED ConfigurationStateElementState = "VM_DEPLOYMENT_RESTARTED"
const ConfigurationStateElementStateVMNETWORKEDITFAILED ConfigurationStateElementState = "VM_NETWORK_EDIT_FAILED"
const ConfigurationStateElementStateVMNETWORKEDITPENDING ConfigurationStateElementState = "VM_NETWORK_EDIT_PENDING"
const ConfigurationStateElementStateVMNODEREFRESHFAILED ConfigurationStateElementState = "VM_NODE_REFRESH_FAILED"
const ConfigurationStateElementStateVMPLACEMENTREFRESHFAILED ConfigurationStateElementState = "VM_PLACEMENT_REFRESH_FAILED"
const ConfigurationStateElementStateVMPOWEROFFFAILED ConfigurationStateElementState = "VM_POWER_OFF_FAILED"
const ConfigurationStateElementStateVMPOWEROFFINPROGRESS ConfigurationStateElementState = "VM_POWER_OFF_IN_PROGRESS"
const ConfigurationStateElementStateVMPOWERONFAILED ConfigurationStateElementState = "VM_POWER_ON_FAILED"
const ConfigurationStateElementStateVMPOWERONINPROGRESS ConfigurationStateElementState = "VM_POWER_ON_IN_PROGRESS"
const ConfigurationStateElementStateVMREDEPLOYFAILED ConfigurationStateElementState = "VM_REDEPLOY_FAILED"
const ConfigurationStateElementStateVMRENAMEFAILED ConfigurationStateElementState = "VM_RENAME_FAILED"
const ConfigurationStateElementStateVMRENAMEPENDING ConfigurationStateElementState = "VM_RENAME_PENDING"
const ConfigurationStateElementStateVMRESOURCERESERVATIONEDITPENDING ConfigurationStateElementState = "VM_RESOURCE_RESERVATION_EDIT_PENDING"
const ConfigurationStateElementStateVMRESOURCERESERVATIONFAILED ConfigurationStateElementState = "VM_RESOURCE_RESERVATION_FAILED"
const ConfigurationStateElementStateVMUNDEPLOYFAILED ConfigurationStateElementState = "VM_UNDEPLOY_FAILED"
const ConfigurationStateElementStateVMUNDEPLOYINPROGRESS ConfigurationStateElementState = "VM_UNDEPLOY_IN_PROGRESS"
const ConfigurationStateElementStateVMUNDEPLOYSUCCESSFUL ConfigurationStateElementState = "VM_UNDEPLOY_SUCCESSFUL"
const ConfigurationStateElementStateVMVERSIONISUPTINCOMPATIBLE ConfigurationStateElementState = "VM_VERSION_IS_UPT_INCOMPATIBLE"
const ConfigurationStateElementStateVTEPDHCPNOTSUPPORTED ConfigurationStateElementState = "VTEP_DHCP_NOT_SUPPORTED"

var enumValues_ConfigurationStateElementState = []interface{}{
	"in_progress",
	"success",
	"failed",
	"partial_success",
	"in_sync",
	"VM_DEPLOYMENT_FAILED",
	"VM_POWER_ON_FAILED",
	"VM_POWER_OFF_FAILED",
	"VM_UNDEPLOY_FAILED",
	"REPLACE_FAILED",
	"UPLINK_FROM_TEAMING_POLICY_NOT_MAPPED",
	"LOGICAL_SWITCH_NAMED_TEAMING_HAS_NO_PNIC_BACKING",
	"DELETE_VM_IN_REDEPLOY_FAILED",
	"DEPLOY_VM_IN_REDEPLOY_FAILED",
	"INSUFFICIENT_RESOURCES_IN_EDGE_NODE_FOR_SERVICE",
	"EDGE_CONFIG_ERROR",
	"REGISTRATION_FAILED",
	"TRANSPORT_NODE_CONFIGURATION_MISSING",
	"EDGE_HARDWARE_NOT_SUPPORTED",
	"MULTIPLE_OVERLAY_TZS_NOT_SUPPORTED",
	"TN_OVERLAY_TZ_IN_USE_BY_EDGE_CLUSTER",
	"TZ_ENDPOINTS_NOT_SPECIFIED",
	"NO_PNIC_PREPARED_IN_EDGE",
	"APPLIANCE_INTERNAL_ERROR",
	"VTEP_DHCP_NOT_SUPPORTED",
	"UNSUPPORTED_HOST_SWITCH_PROFILE",
	"UPLINK_HOST_SWITCH_PROFILE_NOT_SPECIFIED",
	"HOSTSWITCH_PROFILE_NOT_FOUND",
	"LLDP_SEND_ENABLED_NOT_SUPPORTED",
	"UNSUPPORTED_NAMED_TEAMING_POLICY",
	"LBSRCID_NOT_SUPPORTED_FOR_EDGE_VM",
	"LACP_NOT_SUPPORTED_FOR_EDGE_VM",
	"STANDBY_UPLINKS_NOT_SUPPORTED_FOR_EDGE_VM",
	"MULTIPLE_ACTIVE_UPLINKS_NOT_SUPPORTED_FOR_EDGE",
	"UNSUPPORTED_LACP_LB_ALGO_FOR_NODE",
	"EDGE_NODE_VERSION_NOT_SUPPORTED",
	"NO_PNIC_SPECIFIED_IN_TN",
	"INVALID_PNIC_DEVICE_NAME",
	"UNSUPPORTED_DEFAULT_TEAMING_POLICY",
	"MPA_DISCONNECTED",
	"VM_NETWORK_EDIT_PENDING",
	"VM_RENAME_PENDING",
	"VM_CONFIG_EDIT_PENDING",
	"VM_NETWORK_EDIT_FAILED",
	"VM_RENAME_FAILED",
	"VM_CONFIG_EDIT_FAILED",
	"VM_CONFIG_DISCREPANCY",
	"VM_NODE_REFRESH_FAILED",
	"VM_PLACEMENT_REFRESH_FAILED",
	"NOT_AVAILABLE",
	"REGISTRATION_TIMEDOUT",
	"ADVANCED_CONFIG_EDIT_FAILED",
	"VM_RESOURCE_RESERVATION_FAILED",
	"UPT_MODE_REALIZATION_POLL_TIMED_OUT",
	"DATAPATH_CONFIGURATION_EDIT_FAILED",
	"MAINTENANCE_MODE_ENABLED",
	"ERROR_IN_ENABLE_MAINTENANCE_MODE",
	"ERROR_IN_DISABLE_MAINTENANCE_MODE",
	"CONFIGURE_UPT_ON_VM_FAILED",
	"VM_VERSION_IS_UPT_INCOMPATIBLE",
	"pending",
	"orphaned",
	"unknown",
	"error",
	"VM_DEPLOYMENT_QUEUED",
	"VM_DEPLOYMENT_IN_PROGRESS",
	"VM_POWER_ON_IN_PROGRESS",
	"REGISTRATION_PENDING",
	"NODE_NOT_READY",
	"NODE_READY",
	"VM_POWER_OFF_IN_PROGRESS",
	"VM_UNDEPLOY_IN_PROGRESS",
	"VM_UNDEPLOY_SUCCESSFUL",
	"VM_DEPLOYMENT_RESTARTED",
	"TRANSPORT_NODE_SYNC_PENDING",
	"TRANSPORT_NODE_READY",
	"DUPLICATE_PNICS_IN_TEAMINGS_WITH_MULTIPLE_UPLINKS_AND_FAILOVER_ORDER",
	"DUPLICATE_VLANS_SHARING_SAME_PNICMULTIPLE_UPLINKS_IN_NAMED_TEAMING_NOT_SUPPORTED_IF_UPLINK_IN_DEFAULT_TEAMING",
	"EDGE_NODE_SETTINGS_MISMATCH_RESOLVE",
	"EDGE_VM_VSPHERE_SETTINGS_MISMATCH_RESOLVE",
	"EDGE_NODE_SETTINGS_AND_VSPHERE_SETTINGS_ARE_CHANGED_RESOLVE",
	"EDGE_VSPHERE_LOCATION_MISMATCH_RESOLVE",
	"COMPUTE_MANAGER_NOT_FOUND",
	"ADVANCED_CONFIG_EDIT_PENDING",
	"DELETE_FAILED_FOR_DIFFERENT_MOREF_ID",
	"DELETE_FAILED_FOR_NON_LCM_EDGE",
	"DELETE_FAILED_ON_VM_NOT_FOUND",
	"DELETE_IN_PROGRESS",
	"DUPLICATE_VLANS_SHARING_SAME_PNIC",
	"MULTIPLE_UPLINKS_IN_NAMED_TEAMING_NOT_SUPPORTED_IF_UPLINK_IN_DEFAULT_TEAMING",
	"REDEPLOY_ACTIVITY_FAILED",
	"REDEPLOY_ACTIVITY_IN_PROGRESS",
	"REDEPLOY_ACTIVITY_SCHEDULED",
	"REDEPLOY_ACTIVITY_SUCCESSFUL",
	"REPLACE_ACTIVITY_FAILED",
	"REPLACE_ACTIVITY_IN_PROGRESS",
	"REPLACE_ACTIVITY_SCHEDULED",
	"REPLACE_ACTIVITY_SUCCESSFUL",
	"REPLACED_RPC_CLIENT_OF_TN",
	"RETRYING_REPLACE",
	"UNABLE_TO_DELETE_EDGE_NODE_VM_INTERNAL_ERROR",
	"VM_REDEPLOY_FAILED",
	"VM_RESOURCE_RESERVATION_EDIT_PENDING",
	"REDEPLOYED_VM_REGISTRATION_PENDING",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConfigurationStateElementState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConfigurationStateElementState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConfigurationStateElementState, v)
	}
	*j = ConfigurationStateElementState(v)
	return nil
}

// Represents the operators AND or OR.
type ConjunctionOperator struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// ConjunctionOperator corresponds to the JSON schema field
	// "conjunction_operator".
	ConjunctionOperator *ConjunctionOperatorConjunctionOperator `json:"conjunction_operator,omitempty" yaml:"conjunction_operator,omitempty" mapstructure:"conjunction_operator,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ConjunctionOperatorResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ConjunctionOperatorConjunctionOperator string

const ConjunctionOperatorConjunctionOperatorAND ConjunctionOperatorConjunctionOperator = "AND"
const ConjunctionOperatorConjunctionOperatorOR ConjunctionOperatorConjunctionOperator = "OR"

var enumValues_ConjunctionOperatorConjunctionOperator = []interface{}{
	"OR",
	"AND",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConjunctionOperatorConjunctionOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConjunctionOperatorConjunctionOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConjunctionOperatorConjunctionOperator, v)
	}
	*j = ConjunctionOperatorConjunctionOperator(v)
	return nil
}

type ConjunctionOperatorResourceType string

const ConjunctionOperatorResourceTypeCondition ConjunctionOperatorResourceType = "Condition"
const ConjunctionOperatorResourceTypeConjunctionOperator ConjunctionOperatorResourceType = "ConjunctionOperator"
const ConjunctionOperatorResourceTypeExternalIDExpression ConjunctionOperatorResourceType = "ExternalIDExpression"
const ConjunctionOperatorResourceTypeIPAddressExpression ConjunctionOperatorResourceType = "IPAddressExpression"
const ConjunctionOperatorResourceTypeIdentityGroupExpression ConjunctionOperatorResourceType = "IdentityGroupExpression"
const ConjunctionOperatorResourceTypeMACAddressExpression ConjunctionOperatorResourceType = "MACAddressExpression"
const ConjunctionOperatorResourceTypeNestedExpression ConjunctionOperatorResourceType = "NestedExpression"
const ConjunctionOperatorResourceTypePathExpression ConjunctionOperatorResourceType = "PathExpression"

var enumValues_ConjunctionOperatorResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConjunctionOperatorResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConjunctionOperatorResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConjunctionOperatorResourceType, v)
	}
	*j = ConjunctionOperatorResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConjunctionOperator) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ConjunctionOperator
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = ConjunctionOperator(plain)
	return nil
}

type DiscoveredResourceScope struct {
	// Specifies the scope id of discovered resource.
	ScopeId *string `json:"scope_id,omitempty" yaml:"scope_id,omitempty" mapstructure:"scope_id,omitempty"`

	// Type of the scope for the discovered resource.
	ScopeType *DiscoveredResourceScopeScopeType `json:"scope_type,omitempty" yaml:"scope_type,omitempty" mapstructure:"scope_type,omitempty"`
}

type DiscoveredResourceScopeScopeType string

const DiscoveredResourceScopeScopeTypeCONTAINERCLUSTER DiscoveredResourceScopeScopeType = "CONTAINER_CLUSTER"
const DiscoveredResourceScopeScopeTypeVPC DiscoveredResourceScopeScopeType = "VPC"

var enumValues_DiscoveredResourceScopeScopeType = []interface{}{
	"CONTAINER_CLUSTER",
	"VPC",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DiscoveredResourceScopeScopeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DiscoveredResourceScopeScopeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DiscoveredResourceScopeScopeType, v)
	}
	*j = DiscoveredResourceScopeScopeType(v)
	return nil
}

// Dns config
type DnsClientConfig struct {
	// IPs of the DNS servers which need to be configured on the workload VMs
	DnsServerIps []string `json:"dns_server_ips,omitempty" yaml:"dns_server_ips,omitempty" mapstructure:"dns_server_ips,omitempty"`
}

// Domain.
type Domain struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Domain) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Domain
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Domain(plain)
	return nil
}

type EpochMsTimestamp int

// Represents the list of members that need to be excluded
type ExcludedMembersList struct {
	// IpAddressExpression corresponds to the JSON schema field
	// "ip_address_expression".
	IpAddressExpression *IPAddressExpression `json:"ip_address_expression,omitempty" yaml:"ip_address_expression,omitempty" mapstructure:"ip_address_expression,omitempty"`

	// Paths can be only IP address based groups. Upto 50 paths are allowed.
	PathExpression *PathExpression `json:"path_expression,omitempty" yaml:"path_expression,omitempty" mapstructure:"path_expression,omitempty"`
}

// All the nodes of the expression extend from this abstract class. This is present
// for extensibility.
type Expression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ExpressionResourceType string

const ExpressionResourceTypeCondition ExpressionResourceType = "Condition"
const ExpressionResourceTypeConjunctionOperator ExpressionResourceType = "ConjunctionOperator"
const ExpressionResourceTypeExternalIDExpression ExpressionResourceType = "ExternalIDExpression"
const ExpressionResourceTypeIPAddressExpression ExpressionResourceType = "IPAddressExpression"
const ExpressionResourceTypeIdentityGroupExpression ExpressionResourceType = "IdentityGroupExpression"
const ExpressionResourceTypeMACAddressExpression ExpressionResourceType = "MACAddressExpression"
const ExpressionResourceTypeNestedExpression ExpressionResourceType = "NestedExpression"
const ExpressionResourceTypePathExpression ExpressionResourceType = "PathExpression"

var enumValues_ExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExpressionResourceType, v)
	}
	*j = ExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Expression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Expression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Expression(plain)
	return nil
}

// Additional configuration required for federation.
type FederationConnectivityConfig struct {
	// Global id for by Layer3 services for federation usecases.
	GlobalOverlayId *int `json:"global_overlay_id,omitempty" yaml:"global_overlay_id,omitempty" mapstructure:"global_overlay_id,omitempty"`
}

// Group.
type Group struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// The expression list must follow below criteria:   1. A non-empty expression
	// list, must be of odd size. In a list, with   indices starting from 0, all
	// non-conjunction expressions must be at   even indices, separated by a
	// conjunction expression at odd   indices.   2. The total of ConditionExpression
	// and NestedExpression in a list   should not exceed 5.   3. The total of
	// IPAddressExpression, MACAddressExpression, external   IDs in an
	// ExternalIDExpression and paths in a PathExpression must not exceed   the
	// defined Config Max limit for the form-factor of Manager nodes.   4. Each
	// expression must be a valid Expression. See the definition of   the Expression
	// type for more information.
	Expression []Expression `json:"expression,omitempty" yaml:"expression,omitempty" mapstructure:"expression,omitempty"`

	// Extended Expression allows additional higher level context to be specified for
	// grouping criteria. (e.g. user AD group) This field allow users to specified
	// user context as the source of a firewall rule for IDFW feature. Current version
	// only support a single IdentityGroupExpression. In the future, this might expand
	// to support other conjunction and non-conjunction expression.  The extended
	// expression list must follow below criteria: 1. Contains a single
	// IdentityGroupExpression. No conjunction expression is supported. 2. No other
	// non-conjunction expression is supported, except for IdentityGroupExpression. 3.
	// Each expression must be a valid Expression. See the definition of the
	// Expression type for more information. 4. Extended expression are implicitly AND
	// with expression. 5. No nesting can be supported if this value is used. 6. If a
	// Group is using extended expression, this group must be the only member in the
	// source field of an communication map.
	ExtendedExpression []Expression `json:"extended_expression,omitempty" yaml:"extended_expression,omitempty" mapstructure:"extended_expression,omitempty"`

	// Group type can be specified during create and update of a group. Empty group
	// type indicates a 'generic' group, ie group can include any entity from the
	// valid GroupMemberType.
	GroupType []GroupTypes `json:"group_type,omitempty" yaml:"group_type,omitempty" mapstructure:"group_type,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// If true, indicates that this is a remote reference group. Such group will have
	// span different from the its parent domain. Default value is false.
	Reference bool `json:"reference,omitempty" yaml:"reference,omitempty" mapstructure:"reference,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// State corresponds to the JSON schema field "state".
	State *GroupState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type GroupState string

const GroupStateFAILURE GroupState = "FAILURE"
const GroupStateINPROGRESS GroupState = "IN_PROGRESS"
const GroupStateSUCCESS GroupState = "SUCCESS"

var enumValues_GroupState = []interface{}{
	"IN_PROGRESS",
	"SUCCESS",
	"FAILURE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GroupState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GroupState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GroupState, v)
	}
	*j = GroupState(v)
	return nil
}

type GroupTypes string

const GroupTypesANTREA GroupTypes = "ANTREA"
const GroupTypesIPAddress GroupTypes = "IPAddress"

var enumValues_GroupTypes = []interface{}{
	"IPAddress",
	"ANTREA",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GroupTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GroupTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GroupTypes, v)
	}
	*j = GroupTypes(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Group) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Group
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.ExtendedExpression) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "extended_expression", 1)
	}
	if len(plain.GroupType) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "group_type", 1)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if v, ok := raw["reference"]; !ok || v == nil {
		plain.Reference = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Group(plain)
	return nil
}

// Guest virtual machine details include OS name and computer name of guest VM.
type GuestInfo struct {
	// Computer name of guest virtual machine, which is set inside guest OS. Currently
	// this is supported for guests on ESXi that have VMware Tools installed.
	ComputerName *string `json:"computer_name,omitempty" yaml:"computer_name,omitempty" mapstructure:"computer_name,omitempty"`

	// OS name of guest virtual machine. Currently this is supported for guests on
	// ESXi that have VMware Tools installed.
	OsName *string `json:"os_name,omitempty" yaml:"os_name,omitempty" mapstructure:"os_name,omitempty"`
}

type IPAddress string

// Represents IP address expressions in the form of an array, to support addition
// of IP addresses in a group.If duplicate IP Addresses are provided these will be
// filtered out and only unique IP Addresses will be considered. Avoid creating
// groups with multiple IPAddressExpression.In future releases, group will be
// restricted to contain a single IPAddressExpression. To group IPAddresses, use
// nested groups instead of multiple IPAddressExpressions.
type IPAddressExpression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// This array can consist of a single IP address, IP address range or a subnet.
	// Its type can be of either IPv4 or IPv6. Both IPv4 and IPv6 addresses within one
	// expression is not allowed. Supported list of formats are, "192.168.1.1",
	// "192.168.1.1-192.168.1.100", "192.168.0.0/24", "fe80::250:56ff:fe83:318c",
	// "fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c",
	// "fe80::250:56ff:fe83:318c/64". The max limit for number of IP addresses applies
	// across all expressions in a group. Please refer to Config Max limits
	// specification document for a given environment.
	IpAddresses []IPElement `json:"ip_addresses,omitempty" yaml:"ip_addresses,omitempty" mapstructure:"ip_addresses,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *IPAddressExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type IPAddressExpressionResourceType string

const IPAddressExpressionResourceTypeCondition IPAddressExpressionResourceType = "Condition"
const IPAddressExpressionResourceTypeConjunctionOperator IPAddressExpressionResourceType = "ConjunctionOperator"
const IPAddressExpressionResourceTypeExternalIDExpression IPAddressExpressionResourceType = "ExternalIDExpression"
const IPAddressExpressionResourceTypeIPAddressExpression IPAddressExpressionResourceType = "IPAddressExpression"
const IPAddressExpressionResourceTypeIdentityGroupExpression IPAddressExpressionResourceType = "IdentityGroupExpression"
const IPAddressExpressionResourceTypeMACAddressExpression IPAddressExpressionResourceType = "MACAddressExpression"
const IPAddressExpressionResourceTypeNestedExpression IPAddressExpressionResourceType = "NestedExpression"
const IPAddressExpressionResourceTypePathExpression IPAddressExpressionResourceType = "PathExpression"

var enumValues_IPAddressExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IPAddressExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IPAddressExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IPAddressExpressionResourceType, v)
	}
	*j = IPAddressExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IPAddressExpression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain IPAddressExpression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if plain.IpAddresses != nil && len(plain.IpAddresses) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "ip_addresses", 1)
	}
	if len(plain.IpAddresses) > 25000 {
		return fmt.Errorf("field %s length: must be <= %d", "ip_addresses", 25000)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = IPAddressExpression(plain)
	return nil
}

type IPCIDRBlock string

// IPElement can be a single IP address, IP address range or a Subnet. Its type can
// be of IPv4 or IPv6. Supported list of formats are "192.168.1.1",
// "192.168.1.1-192.168.1.100", "192.168.0.0/24", "fe80::250:56ff:fe83:318c",
// "fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c",
// "fe80::250:56ff:fe83:318c/64"
type IPElement string

type IpAddressInfo struct {
	// IpAddresses corresponds to the JSON schema field "ip_addresses".
	IpAddresses []IPAddress `json:"ip_addresses,omitempty" yaml:"ip_addresses,omitempty" mapstructure:"ip_addresses,omitempty"`

	// Source corresponds to the JSON schema field "source".
	Source *IpAddressInfoSource `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`
}

type IpAddressInfoSource string

const IpAddressInfoSourceVMTOOLS IpAddressInfoSource = "VM_TOOLS"

var enumValues_IpAddressInfoSource = []interface{}{
	"VM_TOOLS",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IpAddressInfoSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IpAddressInfoSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IpAddressInfoSource, v)
	}
	*j = IpAddressInfoSource(v)
	return nil
}

type L2Extension struct {
	// This property has been deprecated. Please use the property l2vpn_paths for
	// setting the paths of associated L2 VPN session. This property will continue to
	// work as expected to provide backwards compatibility. However, when both
	// l2vpn_path and l2vpn_paths properties are specified, only l2vpn_paths is used.
	L2VpnPath *string `json:"l2vpn_path,omitempty" yaml:"l2vpn_path,omitempty" mapstructure:"l2vpn_path,omitempty"`

	// Policy paths corresponding to the associated L2 VPN sessions
	L2VpnPaths []string `json:"l2vpn_paths,omitempty" yaml:"l2vpn_paths,omitempty" mapstructure:"l2vpn_paths,omitempty"`

	// Local Egress.
	LocalEgress *LocalEgress `json:"local_egress,omitempty" yaml:"local_egress,omitempty" mapstructure:"local_egress,omitempty"`

	// TunnelId corresponds to the JSON schema field "tunnel_id".
	TunnelId *int `json:"tunnel_id,omitempty" yaml:"tunnel_id,omitempty" mapstructure:"tunnel_id,omitempty"`
}

// Local Egress is used on both server and client sites so that the gateway is used
// for N-S traffic and overhead on L2VPN tunnel is reduced.
type LocalEgress struct {
	// Gateway IP for Local Egress. Local egress is enabled only when this list is not
	// empty.
	OptimizedIps []IPAddress `json:"optimized_ips,omitempty" yaml:"optimized_ips,omitempty" mapstructure:"optimized_ips,omitempty"`
}

type LocalEgressRoutingEntry struct {
	// Next hop address for proximity routing.
	NexthopAddress *string `json:"nexthop_address,omitempty" yaml:"nexthop_address,omitempty" mapstructure:"nexthop_address,omitempty"`

	// The destination address of traffic matching a prefix-list is forwarded to the
	// nexthop_address. Traffic matching a prefix list with Action DENY will be
	// dropped. Individual prefix-lists specified could have different actions.
	PrefixListPaths []string `json:"prefix_list_paths,omitempty" yaml:"prefix_list_paths,omitempty" mapstructure:"prefix_list_paths,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LocalEgressRoutingEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain LocalEgressRoutingEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.PrefixListPaths) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "prefix_list_paths", 1)
	}
	*j = LocalEgressRoutingEntry(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LocalEgress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain LocalEgress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.OptimizedIps != nil && len(plain.OptimizedIps) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "optimized_ips", 1)
	}
	if len(plain.OptimizedIps) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "optimized_ips", 1)
	}
	*j = LocalEgress(plain)
	return nil
}

// A MAC address. Must be 6 pairs of hexadecimal digits, upper or lower case,
// separated by colons or dashes. Examples: 01:23:45:67:89:ab, 01-23-45-67-89-AB.
type MACAddress string

// Represents policy path expressions in the form of an array, to support addition
// of objects like groups, segments and policy logical ports in a group.
type PathExpression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This array can consist of one or more policy paths. Only policy paths of
	// groups, segments and policy logical ports are allowed.
	Paths []string `json:"paths,omitempty" yaml:"paths,omitempty" mapstructure:"paths,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *PathExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type PathExpressionResourceType string

const PathExpressionResourceTypeCondition PathExpressionResourceType = "Condition"
const PathExpressionResourceTypeConjunctionOperator PathExpressionResourceType = "ConjunctionOperator"
const PathExpressionResourceTypeExternalIDExpression PathExpressionResourceType = "ExternalIDExpression"
const PathExpressionResourceTypeIPAddressExpression PathExpressionResourceType = "IPAddressExpression"
const PathExpressionResourceTypeIdentityGroupExpression PathExpressionResourceType = "IdentityGroupExpression"
const PathExpressionResourceTypeMACAddressExpression PathExpressionResourceType = "MACAddressExpression"
const PathExpressionResourceTypeNestedExpression PathExpressionResourceType = "NestedExpression"
const PathExpressionResourceTypePathExpression PathExpressionResourceType = "PathExpression"

var enumValues_PathExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PathExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PathExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PathExpressionResourceType, v)
	}
	*j = PathExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PathExpression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PathExpression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if plain.Paths != nil && len(plain.Paths) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "paths", 1)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = PathExpression(plain)
	return nil
}

// Alarm base class of realized policy object
type PolicyAlarmResource struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// ErrorDetails corresponds to the JSON schema field "error_details".
	ErrorDetails *PolicyApiError `json:"error_details,omitempty" yaml:"error_details,omitempty" mapstructure:"error_details,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Message corresponds to the JSON schema field "message".
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// SourceReference corresponds to the JSON schema field "source_reference".
	SourceReference *string `json:"source_reference,omitempty" yaml:"source_reference,omitempty" mapstructure:"source_reference,omitempty"`

	// This field will refer to the source site on which the alarm is generated. This
	// field is populated by GM, when it receives corresponding notification from LM.
	SourceSiteId *string `json:"source_site_id,omitempty" yaml:"source_site_id,omitempty" mapstructure:"source_site_id,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyAlarmResource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PolicyAlarmResource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = PolicyAlarmResource(plain)
	return nil
}

type PolicyApiError struct {
	// Details corresponds to the JSON schema field "details".
	Details *string `json:"details,omitempty" yaml:"details,omitempty" mapstructure:"details,omitempty"`

	// ErrorCode corresponds to the JSON schema field "error_code".
	ErrorCode *int `json:"error_code,omitempty" yaml:"error_code,omitempty" mapstructure:"error_code,omitempty"`

	// ErrorData corresponds to the JSON schema field "error_data".
	ErrorData PolicyApiErrorErrorData `json:"error_data,omitempty" yaml:"error_data,omitempty" mapstructure:"error_data,omitempty"`

	// ErrorMessage corresponds to the JSON schema field "error_message".
	ErrorMessage *string `json:"error_message,omitempty" yaml:"error_message,omitempty" mapstructure:"error_message,omitempty"`

	// ModuleName corresponds to the JSON schema field "module_name".
	ModuleName *string `json:"module_name,omitempty" yaml:"module_name,omitempty" mapstructure:"module_name,omitempty"`

	// RelatedErrors corresponds to the JSON schema field "related_errors".
	RelatedErrors []PolicyRelatedApiError `json:"related_errors,omitempty" yaml:"related_errors,omitempty" mapstructure:"related_errors,omitempty"`
}

type PolicyApiErrorErrorData map[string]interface{}

type PolicyRelatedApiError struct {
	// Details corresponds to the JSON schema field "details".
	Details *string `json:"details,omitempty" yaml:"details,omitempty" mapstructure:"details,omitempty"`

	// ErrorCode corresponds to the JSON schema field "error_code".
	ErrorCode *int `json:"error_code,omitempty" yaml:"error_code,omitempty" mapstructure:"error_code,omitempty"`

	// ErrorData corresponds to the JSON schema field "error_data".
	ErrorData PolicyRelatedApiErrorErrorData `json:"error_data,omitempty" yaml:"error_data,omitempty" mapstructure:"error_data,omitempty"`

	// ErrorMessage corresponds to the JSON schema field "error_message".
	ErrorMessage *string `json:"error_message,omitempty" yaml:"error_message,omitempty" mapstructure:"error_message,omitempty"`

	// ModuleName corresponds to the JSON schema field "module_name".
	ModuleName *string `json:"module_name,omitempty" yaml:"module_name,omitempty" mapstructure:"module_name,omitempty"`
}

type PolicyRelatedApiErrorErrorData map[string]interface{}

// Optional API Request Parameter to be used in HAPI.
type PolicyRequestParameter struct {
	// The type of this request parameter.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`
}

// Detailed information about static address for the port.
type PortAddressBindingEntry struct {
	// IP Address for port binding
	IpAddress *string `json:"ip_address,omitempty" yaml:"ip_address,omitempty" mapstructure:"ip_address,omitempty"`

	// Mac address for port binding
	MacAddress *MACAddress `json:"mac_address,omitempty" yaml:"mac_address,omitempty" mapstructure:"mac_address,omitempty"`

	// VLAN ID for port binding
	VlanId *VlanID `json:"vlan_id,omitempty" yaml:"vlan_id,omitempty" mapstructure:"vlan_id,omitempty"`
}

// Detail information about port attachment
type PortAttachment struct {
	// Indicate how IP will be allocated for the port. Enum BOTH references IP pool
	// and MAC pool.  Enum NONE is no allocation.
	AllocateAddresses *PortAttachmentAllocateAddresses `json:"allocate_addresses,omitempty" yaml:"allocate_addresses,omitempty" mapstructure:"allocate_addresses,omitempty"`

	// ID used to identify/look up a child attachment behind a parent attachment
	AppId *string `json:"app_id,omitempty" yaml:"app_id,omitempty" mapstructure:"app_id,omitempty"`

	// Indicate application interface configuration for Bare Metal Server.
	BmsInterfaceConfig *AttachedInterfaceEntry `json:"bms_interface_config,omitempty" yaml:"bms_interface_config,omitempty" mapstructure:"bms_interface_config,omitempty"`

	// If type is CHILD and the parent port is on the same segment as the child port,
	// then this field should be VIF ID of the parent port. If type is CHILD and the
	// parent port is on a different segment, then this field should be policy path of
	// the parent port. If type is INDEPENDENT/STATIC, then this field should be
	// transport node ID.
	ContextId *string `json:"context_id,omitempty" yaml:"context_id,omitempty" mapstructure:"context_id,omitempty"`

	// Set to PARENT when type field is CHILD. Read only field.
	ContextType *PortAttachmentContextType `json:"context_type,omitempty" yaml:"context_type,omitempty" mapstructure:"context_type,omitempty"`

	// List of Evpn tenant VLAN IDs the Parent logical-port serves in Evpn
	// Route-Server mode. Only effective when attachment type is PARENT and the
	// logical-port is attached to vRouter VM.
	EvpnVlans []string `json:"evpn_vlans,omitempty" yaml:"evpn_vlans,omitempty" mapstructure:"evpn_vlans,omitempty"`

	// Flag to indicate if hyperbus configuration is required.
	HyperbusMode PortAttachmentHyperbusMode `json:"hyperbus_mode,omitempty" yaml:"hyperbus_mode,omitempty" mapstructure:"hyperbus_mode,omitempty"`

	// VIF UUID on NSX Manager. If the attachement type is PARENT, this property is
	// required.
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Not valid when type field is INDEPENDENT, mainly used to identify traffic from
	// different ports in container use case.
	TrafficTag *VlanID `json:"traffic_tag,omitempty" yaml:"traffic_tag,omitempty" mapstructure:"traffic_tag,omitempty"`

	// Type of port attachment. STATIC is added to replace INDEPENDENT. INDEPENDENT
	// type and PARENT type are deprecated.
	Type *PortAttachmentType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type PortAttachmentAllocateAddresses string

const PortAttachmentAllocateAddressesBOTH PortAttachmentAllocateAddresses = "BOTH"
const PortAttachmentAllocateAddressesDHCP PortAttachmentAllocateAddresses = "DHCP"
const PortAttachmentAllocateAddressesDHCPV6 PortAttachmentAllocateAddresses = "DHCPV6"
const PortAttachmentAllocateAddressesIPPOOL PortAttachmentAllocateAddresses = "IP_POOL"
const PortAttachmentAllocateAddressesMACPOOL PortAttachmentAllocateAddresses = "MAC_POOL"
const PortAttachmentAllocateAddressesNONE PortAttachmentAllocateAddresses = "NONE"
const PortAttachmentAllocateAddressesSLAAC PortAttachmentAllocateAddresses = "SLAAC"

var enumValues_PortAttachmentAllocateAddresses = []interface{}{
	"IP_POOL",
	"MAC_POOL",
	"BOTH",
	"DHCP",
	"DHCPV6",
	"SLAAC",
	"NONE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortAttachmentAllocateAddresses) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PortAttachmentAllocateAddresses {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PortAttachmentAllocateAddresses, v)
	}
	*j = PortAttachmentAllocateAddresses(v)
	return nil
}

type PortAttachmentContextType string

const PortAttachmentContextTypePARENT PortAttachmentContextType = "PARENT"

var enumValues_PortAttachmentContextType = []interface{}{
	"PARENT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortAttachmentContextType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PortAttachmentContextType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PortAttachmentContextType, v)
	}
	*j = PortAttachmentContextType(v)
	return nil
}

type PortAttachmentHyperbusMode string

const PortAttachmentHyperbusModeDISABLE PortAttachmentHyperbusMode = "DISABLE"
const PortAttachmentHyperbusModeENABLE PortAttachmentHyperbusMode = "ENABLE"

var enumValues_PortAttachmentHyperbusMode = []interface{}{
	"ENABLE",
	"DISABLE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortAttachmentHyperbusMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PortAttachmentHyperbusMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PortAttachmentHyperbusMode, v)
	}
	*j = PortAttachmentHyperbusMode(v)
	return nil
}

type PortAttachmentType string

const PortAttachmentTypeCHILD PortAttachmentType = "CHILD"
const PortAttachmentTypeINDEPENDENT PortAttachmentType = "INDEPENDENT"
const PortAttachmentTypePARENT PortAttachmentType = "PARENT"
const PortAttachmentTypeSTATIC PortAttachmentType = "STATIC"

var enumValues_PortAttachmentType = []interface{}{
	"PARENT",
	"CHILD",
	"INDEPENDENT",
	"STATIC",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortAttachmentType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PortAttachmentType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PortAttachmentType, v)
	}
	*j = PortAttachmentType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortAttachment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PortAttachment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.EvpnVlans) > 1000 {
		return fmt.Errorf("field %s length: must be <= %d", "evpn_vlans", 1000)
	}
	if v, ok := raw["hyperbus_mode"]; !ok || v == nil {
		plain.HyperbusMode = "DISABLE"
	}
	*j = PortAttachment(plain)
	return nil
}

type RealizedVirtualMachine struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Alarms corresponds to the JSON schema field "alarms".
	Alarms []PolicyAlarmResource `json:"alarms,omitempty" yaml:"alarms,omitempty" mapstructure:"alarms,omitempty"`

	// ComputeIds corresponds to the JSON schema field "compute_ids".
	ComputeIds []string `json:"compute_ids,omitempty" yaml:"compute_ids,omitempty" mapstructure:"compute_ids,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// HostId corresponds to the JSON schema field "host_id".
	HostId *string `json:"host_id,omitempty" yaml:"host_id,omitempty" mapstructure:"host_id,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// IntentReference corresponds to the JSON schema field "intent_reference".
	IntentReference []string `json:"intent_reference,omitempty" yaml:"intent_reference,omitempty" mapstructure:"intent_reference,omitempty"`

	// LocalIdOnHost corresponds to the JSON schema field "local_id_on_host".
	LocalIdOnHost *string `json:"local_id_on_host,omitempty" yaml:"local_id_on_host,omitempty" mapstructure:"local_id_on_host,omitempty"`

	// Possible values could be UP, DOWN, UNKNOWN, FAILURE This list is not
	// exhaustive.
	OperationalStatus *string `json:"operational_status,omitempty" yaml:"operational_status,omitempty" mapstructure:"operational_status,omitempty"`

	// It defines the root cause for operational status error.
	OperationalStatusError *string `json:"operational_status_error,omitempty" yaml:"operational_status_error,omitempty" mapstructure:"operational_status_error,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// PowerState corresponds to the JSON schema field "power_state".
	PowerState *RealizedVirtualMachinePowerState `json:"power_state,omitempty" yaml:"power_state,omitempty" mapstructure:"power_state,omitempty"`

	// Possible values could be UP, DOWN, UNKNOWN, SUCCESS This list is not
	// exhaustive.
	PublishStatus *string `json:"publish_status,omitempty" yaml:"publish_status,omitempty" mapstructure:"publish_status,omitempty"`

	// It defines the root cause for publish status error.
	PublishStatusError *string `json:"publish_status_error,omitempty" yaml:"publish_status_error,omitempty" mapstructure:"publish_status_error,omitempty"`

	// It defines error code for publish status error.
	PublishStatusErrorCode *int `json:"publish_status_error_code,omitempty" yaml:"publish_status_error_code,omitempty" mapstructure:"publish_status_error_code,omitempty"`

	// Error details for publish status.
	PublishStatusErrorDetails []ConfigurationStateElement `json:"publish_status_error_details,omitempty" yaml:"publish_status_error_details,omitempty" mapstructure:"publish_status_error_details,omitempty"`

	// This is the time when our system detects that data has been pushed to the
	// transport nodes. This is based on a poll mechanism and hence this is not the
	// accurate time when the intent was published at the data path. The value of -1
	// indicates that either the publishing is still in progress or the runtime status
	// is UNKNOWN and hence not available. The Runtime status can be UNKNOWN if one or
	// more hosts are down and the rules could not be sent to those hosts. When the
	// host comes up, the runtime status will change to SUCCESS but the publish_time
	// will show the value of the last realization time. Any new configuration change
	// after this will start reflecting the proper value for publish_time
	PublishTime *EpochMsTimestamp `json:"publish_time,omitempty" yaml:"publish_time,omitempty" mapstructure:"publish_time,omitempty"`

	// RealizationApi corresponds to the JSON schema field "realization_api".
	RealizationApi *string `json:"realization_api,omitempty" yaml:"realization_api,omitempty" mapstructure:"realization_api,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// RealizationSpecificIdentifier corresponds to the JSON schema field
	// "realization_specific_identifier".
	RealizationSpecificIdentifier *string `json:"realization_specific_identifier,omitempty" yaml:"realization_specific_identifier,omitempty" mapstructure:"realization_specific_identifier,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// It define the root cause for runtime error.
	RuntimeError *string `json:"runtime_error,omitempty" yaml:"runtime_error,omitempty" mapstructure:"runtime_error,omitempty"`

	// Possible values could be UP, DOWN, UNKNOWN, DEGRADED This list is not
	// exhaustive.
	RuntimeStatus *string `json:"runtime_status,omitempty" yaml:"runtime_status,omitempty" mapstructure:"runtime_status,omitempty"`

	// State corresponds to the JSON schema field "state".
	State *RealizedVirtualMachineState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is an approximate time taken for the realization of the intent to the data
	// path. The actual time taken could be lesser than what is reported here. The
	// value of -1 indicates that either the publishing is still in progress or the
	// runtime status is UNKNOWN and hence not available. The Runtime status can be
	// UNKNOWN if one or more hosts are down and the rules could not be sent to those
	// hosts. When the host comes up, the runtime status will change to SUCCESS but
	// the time taken for realization will show the value of the last realization
	// time. Any new configuration change after this will start reflecting the proper
	// value for time_taken_for_realization
	TimeTakenForRealization *int `json:"time_taken_for_realization,omitempty" yaml:"time_taken_for_realization,omitempty" mapstructure:"time_taken_for_realization,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type RealizedVirtualMachinePowerState string

const RealizedVirtualMachinePowerStateUNKNOWN RealizedVirtualMachinePowerState = "UNKNOWN"
const RealizedVirtualMachinePowerStateVMRUNNING RealizedVirtualMachinePowerState = "VM_RUNNING"
const RealizedVirtualMachinePowerStateVMSTOPPED RealizedVirtualMachinePowerState = "VM_STOPPED"
const RealizedVirtualMachinePowerStateVMSUSPENDED RealizedVirtualMachinePowerState = "VM_SUSPENDED"

var enumValues_RealizedVirtualMachinePowerState = []interface{}{
	"VM_RUNNING",
	"VM_STOPPED",
	"VM_SUSPENDED",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RealizedVirtualMachinePowerState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RealizedVirtualMachinePowerState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RealizedVirtualMachinePowerState, v)
	}
	*j = RealizedVirtualMachinePowerState(v)
	return nil
}

type RealizedVirtualMachineState string

const RealizedVirtualMachineStateERROR RealizedVirtualMachineState = "ERROR"
const RealizedVirtualMachineStateREALIZED RealizedVirtualMachineState = "REALIZED"
const RealizedVirtualMachineStateUNAVAILABLE RealizedVirtualMachineState = "UNAVAILABLE"
const RealizedVirtualMachineStateUNREALIZED RealizedVirtualMachineState = "UNREALIZED"

var enumValues_RealizedVirtualMachineState = []interface{}{
	"UNAVAILABLE",
	"UNREALIZED",
	"REALIZED",
	"ERROR",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RealizedVirtualMachineState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RealizedVirtualMachineState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RealizedVirtualMachineState, v)
	}
	*j = RealizedVirtualMachineState(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RealizedVirtualMachine) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain RealizedVirtualMachine
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = RealizedVirtualMachine(plain)
	return nil
}

type ResourceLink struct {
	// Action corresponds to the JSON schema field "action".
	Action *string `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Href corresponds to the JSON schema field "href".
	Href *string `json:"href,omitempty" yaml:"href,omitempty" mapstructure:"href,omitempty"`

	// Custom relation type (follows RFC 5988 where appropriate definitions exist)
	Rel *string `json:"rel,omitempty" yaml:"rel,omitempty" mapstructure:"rel,omitempty"`
}

// A weak reference to an NSX resource.
type ResourceReference struct {
	// Will be set to false if the referenced NSX resource has been deleted.
	IsValid *bool `json:"is_valid,omitempty" yaml:"is_valid,omitempty" mapstructure:"is_valid,omitempty"`

	// Display name of the NSX resource.
	TargetDisplayName *string `json:"target_display_name,omitempty" yaml:"target_display_name,omitempty" mapstructure:"target_display_name,omitempty"`

	// Identifier of the NSX resource.
	TargetId *string `json:"target_id,omitempty" yaml:"target_id,omitempty" mapstructure:"target_id,omitempty"`

	// Type of the NSX resource.
	TargetType *string `json:"target_type,omitempty" yaml:"target_type,omitempty" mapstructure:"target_type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceReference) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ResourceReference
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.TargetDisplayName != nil && len(*plain.TargetDisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "target_display_name", 255)
	}
	if plain.TargetId != nil && len(*plain.TargetId) > 64 {
		return fmt.Errorf("field %s length: must be <= %d", "target_id", 64)
	}
	if plain.TargetType != nil && len(*plain.TargetType) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "target_type", 255)
	}
	*j = ResourceReference(plain)
	return nil
}

// A rule indicates the action to be performed for various types of traffic flowing
// between workload groups.
type Rule struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// The action to be applied to all the services The JUMP_TO_APPLICATION action is
	// only supported for rules created in the Environment category. Once a match is
	// hit then the rule processing will jump to the rules present in the Application
	// category, skipping all further rules in the Environment category. If no rules
	// match in the Application category then the default application rule will be
	// hit. This is applicable only for DFW.
	Action *RuleAction `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// We need paths as duplicate names may exist for groups under different domains.
	// Along with paths we support IP Address of type IPv4 and IPv6. IP Address can be
	// in one of the format(CIDR, IP Address, Range of IP Address). In order to
	// specify all groups, use the constant "ANY". This is case insensitive. If "ANY"
	// is used, it should be the ONLY element in the group array. Error will be thrown
	// if ANY is used in conjunction with other values.
	DestinationGroups []string `json:"destination_groups,omitempty" yaml:"destination_groups,omitempty" mapstructure:"destination_groups,omitempty"`

	// If set to true, the rule gets applied on all the groups that are NOT part of
	// the destination groups. If false, the rule applies to the destination groups
	DestinationsExcluded bool `json:"destinations_excluded,omitempty" yaml:"destinations_excluded,omitempty" mapstructure:"destinations_excluded,omitempty"`

	// Define direction of traffic.
	Direction RuleDirection `json:"direction,omitempty" yaml:"direction,omitempty" mapstructure:"direction,omitempty"`

	// Flag to deactivate the rule. Default is activated.
	Disabled bool `json:"disabled,omitempty" yaml:"disabled,omitempty" mapstructure:"disabled,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Type of IP packet that should be matched while enforcing the rule. The value is
	// set to IPV4_IPV6 for Layer3 rule if not specified. For Layer2/Ether rule the
	// value must be null.
	IpProtocol *RuleIpProtocol `json:"ip_protocol,omitempty" yaml:"ip_protocol,omitempty" mapstructure:"ip_protocol,omitempty"`

	// A flag to indicate whether rule is a default rule.
	IsDefault *bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// Flag to enable packet logging. Default is deactivated.
	Logged bool `json:"logged,omitempty" yaml:"logged,omitempty" mapstructure:"logged,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// Text for additional notes on changes.
	Notes *string `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Holds the list of layer 7 service profile paths. These profiles accept
	// attributes and sub-attributes of various network services (e.g. L4 AppId,
	// encryption algorithm, domain name, etc) as key value pairs. Instead of Layer 7
	// service profiles you can use a L7 access profile. One of either Layer 7 service
	// profiles or L7 Access Profile can be used in firewall rule. In case of L7
	// access profile only one is allowed.
	Profiles []string `json:"profiles,omitempty" yaml:"profiles,omitempty" mapstructure:"profiles,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// This is a unique 4 byte positive number that is assigned by the system.  This
	// rule id is passed all the way down to the data path. The first 1GB (1000 to
	// 2^30) will be shared by GM and LM with zebra style striped number space. For
	// E.g 1000 to (1Million -1) by LM, (1M - 2M-1) by GM and so on.
	RuleId *int `json:"rule_id,omitempty" yaml:"rule_id,omitempty" mapstructure:"rule_id,omitempty"`

	// The list of policy paths where the rule is applied LR/Edge/T0/T1/LRP etc. Note
	// that a given rule can be applied on multiple LRs/LRPs.
	Scope []string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// This field is used to resolve conflicts between multiple Rules under Security
	// or Gateway Policy for a Domain If no sequence number is specified in the
	// payload, a value of 0 is assigned by default. If there are multiple rules with
	// the same sequence number then their order is not deterministic. If a specific
	// order of rules is desired, then one has to specify unique sequence numbers or
	// use the POST request on the rule entity with a query parameter action=revise to
	// let the framework assign a sequence number
	SequenceNumber *int `json:"sequence_number,omitempty" yaml:"sequence_number,omitempty" mapstructure:"sequence_number,omitempty"`

	// In order to specify raw services this can be used, along with services which
	// contains path to services. This can be empty or null.
	ServiceEntries []ServiceEntry `json:"service_entries,omitempty" yaml:"service_entries,omitempty" mapstructure:"service_entries,omitempty"`

	// In order to specify all services, use the constant "ANY". This is case
	// insensitive. If "ANY" is used, it should be the ONLY element in the services
	// array. Error will be thrown if ANY is used in conjunction with other values.
	Services []string `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`

	// We need paths as duplicate names may exist for groups under different domains.
	// Along with paths we support IP Address of type IPv4 and IPv6. IP Address can be
	// in one of the format(CIDR, IP Address, Range of IP Address). In order to
	// specify all groups, use the constant "ANY". This is case insensitive. If "ANY"
	// is used, it should be the ONLY element in the group array. Error will be thrown
	// if ANY is used in conjunction with other values.
	SourceGroups []string `json:"source_groups,omitempty" yaml:"source_groups,omitempty" mapstructure:"source_groups,omitempty"`

	// If set to true, the rule gets applied on all the groups that are NOT part of
	// the source groups. If false, the rule applies to the source groups
	SourcesExcluded bool `json:"sources_excluded,omitempty" yaml:"sources_excluded,omitempty" mapstructure:"sources_excluded,omitempty"`

	// User level field which will be printed in CLI and packet logs. Even though
	// there is no limitation on length of a tag, internally tag will get truncated
	// after 32 characters.
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type RuleAction string

const RuleActionALLOW RuleAction = "ALLOW"
const RuleActionDROP RuleAction = "DROP"
const RuleActionJUMPTOAPPLICATION RuleAction = "JUMP_TO_APPLICATION"
const RuleActionREJECT RuleAction = "REJECT"

var enumValues_RuleAction = []interface{}{
	"ALLOW",
	"DROP",
	"REJECT",
	"JUMP_TO_APPLICATION",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RuleAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RuleAction, v)
	}
	*j = RuleAction(v)
	return nil
}

type RuleDirection string

const RuleDirectionIN RuleDirection = "IN"
const RuleDirectionINOUT RuleDirection = "IN_OUT"
const RuleDirectionOUT RuleDirection = "OUT"

var enumValues_RuleDirection = []interface{}{
	"IN",
	"OUT",
	"IN_OUT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleDirection) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RuleDirection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RuleDirection, v)
	}
	*j = RuleDirection(v)
	return nil
}

type RuleIpProtocol string

const RuleIpProtocolIPV4 RuleIpProtocol = "IPV4"
const RuleIpProtocolIPV4IPV6 RuleIpProtocol = "IPV4_IPV6"
const RuleIpProtocolIPV6 RuleIpProtocol = "IPV6"

var enumValues_RuleIpProtocol = []interface{}{
	"IPV4",
	"IPV6",
	"IPV4_IPV6",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleIpProtocol) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RuleIpProtocol {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RuleIpProtocol, v)
	}
	*j = RuleIpProtocol(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Rule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Rule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if len(plain.DestinationGroups) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "destination_groups", 128)
	}
	if v, ok := raw["destinations_excluded"]; !ok || v == nil {
		plain.DestinationsExcluded = false
	}
	if v, ok := raw["direction"]; !ok || v == nil {
		plain.Direction = "IN_OUT"
	}
	if v, ok := raw["disabled"]; !ok || v == nil {
		plain.Disabled = false
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["logged"]; !ok || v == nil {
		plain.Logged = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if plain.Notes != nil && len(*plain.Notes) > 2048 {
		return fmt.Errorf("field %s length: must be <= %d", "notes", 2048)
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Profiles) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "profiles", 128)
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if len(plain.ServiceEntries) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "service_entries", 128)
	}
	if len(plain.Services) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "services", 128)
	}
	if len(plain.SourceGroups) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "source_groups", 128)
	}
	if v, ok := raw["sources_excluded"]; !ok || v == nil {
		plain.SourcesExcluded = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Rule(plain)
	return nil
}

// Ordered list of Rules.
type SecurityPolicy struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// This field indicates the application connectivity policy for the security
	// policy.
	ApplicationConnectivityStrategy []ApplicationConnectivityStrategy `json:"application_connectivity_strategy,omitempty" yaml:"application_connectivity_strategy,omitempty" mapstructure:"application_connectivity_strategy,omitempty"`

	// - Distributed Firewall - Policy framework provides five pre-defined categories
	// for classifying a security policy. They are "Ethernet","Emergency",
	// "Infrastructure" "Environment" and "Application". There is a pre-determined
	// order in which the policy framework manages the priority of these security
	// policies. Ethernet category is for supporting layer 2 firewall rules. The other
	// four categories are applicable for layer 3 rules. Amongst them, the Emergency
	// category has the highest priority followed by Infrastructure, Environment and
	// then Application rules. Administrator can choose to categorize a security
	// policy into the above categories or can choose to leave it empty. If empty it
	// will have the least precedence w.r.t the above four categories. - Edge Firewall
	// - Policy Framework for Edge Firewall provides six pre-defined categories
	// "Emergency", "SystemRules", "SharedPreRules", "LocalGatewayRules",
	// "AutoServiceRules" and "Default", in order of priority of rules. All categories
	// are allowed for Gatetway Policies that belong to 'default' Domain. However, for
	// user created domains, category is restricted to "SharedPreRules" or
	// "LocalGatewayRules" only. Also, the users can add/modify/delete rules from only
	// the "SharedPreRules" and "LocalGatewayRules" categories. If user doesn't
	// specify the category then defaulted to "Rules". System generated category is
	// used by NSX created rules, for example BFD rules. Autoplumbed category used by
	// NSX verticals to autoplumb data path rules. Finally, "Default" category is the
	// placeholder default rules with lowest in the order of priority.
	Category *string `json:"category,omitempty" yaml:"category,omitempty" mapstructure:"category,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Comments for security policy lock/unlock.
	Comments *string `json:"comments,omitempty" yaml:"comments,omitempty" mapstructure:"comments,omitempty"`

	// This field indicates the default connectivity policy for the security policy.
	// Based on the connectivity preference, a default rule for this security policy
	// will be created. An appropriate action will be set on the rule based on the
	// value of the connectivity preference. If NONE is selected or no connectivity
	// preference is specified, then no default rule for the security policy gets
	// created. The default rule that gets created will be a any-any rule and applied
	// to entities specified in the scope of the security policy. Specifying the
	// connectivity_preference without specifying the scope is not allowed. The scope
	// has to be a Group and one cannot specify IPAddress directly in the group that
	// is used as scope. This default rule is only applicable for the Layer3 security
	// policies. ALLOWLIST - Adds a default drop rule. Administrator can then use
	// "allow" rules to allow traffic between groups DENYLIST - Adds a default allow
	// rule. Admin can then use "drop" rules to block traffic between groups
	// ALLOWLIST_ENABLE_LOGGING - Allowlisting with logging enabled
	// DENYLIST_ENABLE_LOGGING - Denylisting with logging enabled NONE - No default
	// rule is created.
	ConnectivityPreference *SecurityPolicyConnectivityPreference `json:"connectivity_preference,omitempty" yaml:"connectivity_preference,omitempty" mapstructure:"connectivity_preference,omitempty"`

	// This field indicates the default connectivity policy for the security policy.
	// Based on the connectivity strategy, a default rule for this security policy
	// will be created. An appropriate action will be set on the rule based on the
	// value of the connectivity strategy. If NONE is selected or no connectivity
	// strategy is specified, then no default rule for the security policy gets
	// created. The default rule that gets created will be a any-any rule and applied
	// to entities specified in the scope of the security policy. Specifying the
	// connectivity_strategy without specifying the scope is not allowed. The scope
	// has to be a Group and one cannot specify IPAddress directly in the group that
	// is used as scope. This default rule is only applicable for the Layer3 security
	// policies. This property is deprecated. Use the type connectivity_preference
	// instead. WHITELIST - Adds a default drop rule. Administrator can then use
	// "allow" rules (aka whitelist) to allow traffic between groups BLACKLIST - Adds
	// a default allow rule. Admin can then use "drop" rules (aka blacklist) to block
	// traffic between groups WHITELIST_ENABLE_LOGGING - Whitelising with logging
	// enabled BLACKLIST_ENABLE_LOGGING - Blacklisting with logging enabled NONE - No
	// default rule is created.
	ConnectivityStrategy *SecurityPolicyConnectivityStrategy `json:"connectivity_strategy,omitempty" yaml:"connectivity_strategy,omitempty" mapstructure:"connectivity_strategy,omitempty"`

	// Based on the value of the connectivity strategy, a default rule is created for
	// the security policy. The rule id is internally assigned by the system for this
	// default rule.
	DefaultRuleId *int `json:"default_rule_id,omitempty" yaml:"default_rule_id,omitempty" mapstructure:"default_rule_id,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// This field is to indicate the internal sequence number of a policy with respect
	// to the policies across categories.
	InternalSequenceNumber *int `json:"internal_sequence_number,omitempty" yaml:"internal_sequence_number,omitempty" mapstructure:"internal_sequence_number,omitempty"`

	// A flag to indicate whether policy is a default policy.
	IsDefault *bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// ID of the user who last modified the lock for the secruity policy.
	LockModifiedBy *string `json:"lock_modified_by,omitempty" yaml:"lock_modified_by,omitempty" mapstructure:"lock_modified_by,omitempty"`

	// SecurityPolicy locked/unlocked time in epoch milliseconds.
	LockModifiedTime *EpochMsTimestamp `json:"lock_modified_time,omitempty" yaml:"lock_modified_time,omitempty" mapstructure:"lock_modified_time,omitempty"`

	// Indicates whether a security policy should be locked. If the security policy is
	// locked by a user, then no other user would be able to modify this security
	// policy. Once the user releases the lock, other users can update this security
	// policy.
	Locked bool `json:"locked,omitempty" yaml:"locked,omitempty" mapstructure:"locked,omitempty"`

	// This property is deprecated. Flag to enable logging for all the rules in the
	// security policy. If the value is true then logging will be enabled for all the
	// rules in the security policy. If the value is false, then the rule level
	// logging value will be honored.
	LoggingEnabled bool `json:"logging_enabled,omitempty" yaml:"logging_enabled,omitempty" mapstructure:"logging_enabled,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// The count of rules in the policy.
	RuleCount *int `json:"rule_count,omitempty" yaml:"rule_count,omitempty" mapstructure:"rule_count,omitempty"`

	// Rules corresponds to the JSON schema field "rules".
	Rules []Rule `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// Provides a mechanism to apply the rules in this policy for a specified time
	// duration.
	SchedulerPath *string `json:"scheduler_path,omitempty" yaml:"scheduler_path,omitempty" mapstructure:"scheduler_path,omitempty"`

	// The list of group paths where the rules in this policy will get applied. This
	// scope will take precedence over rule level scope. Supported only for security
	// and redirection policies. In case of RedirectionPolicy, it is expected only
	// when the policy is NS and redirecting to service chain.
	Scope []string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// This field is used to resolve conflicts between security policies across
	// domains. In order to change the sequence number of a policy one can fire a POST
	// request on the policy entity with a query parameter action=revise The sequence
	// number field will reflect the value of the computed sequence number upon
	// execution of the above mentioned POST request. For scenarios where the
	// administrator is using a template to update several security policies, the only
	// way to set the sequence number is to explicitly specify the sequence number for
	// each security policy. If no sequence number is specified in the payload, a
	// value of 0 is assigned by default. If there are multiple policies with the same
	// sequence number then their order is not deterministic. If a specific order of
	// policies is desired, then one has to specify unique sequence numbers or use the
	// POST request on the policy entity with a query parameter action=revise to let
	// the framework assign a sequence number. The value of sequence number must be
	// between 0 and 999,999.
	SequenceNumber *int `json:"sequence_number,omitempty" yaml:"sequence_number,omitempty" mapstructure:"sequence_number,omitempty"`

	// Stateful or Stateless nature of security policy is enforced on all rules in
	// this security policy. When it is stateful, the state of the network connects
	// are tracked and a stateful packet inspection is performed. Layer3 security
	// policies can be stateful or stateless. By default, they are stateful. Layer2
	// security policies can only be stateless.
	Stateful *bool `json:"stateful,omitempty" yaml:"stateful,omitempty" mapstructure:"stateful,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Ensures that a 3 way TCP handshake is done before the data packets are sent.
	// tcp_strict=true is supported only for stateful security policies. If the
	// tcp_strict flag is not specified and the security policy is stateful, then
	// tcp_strict will be set to true.
	TcpStrict *bool `json:"tcp_strict,omitempty" yaml:"tcp_strict,omitempty" mapstructure:"tcp_strict,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type SecurityPolicyConnectivityPreference string

const SecurityPolicyConnectivityPreferenceALLOWLIST SecurityPolicyConnectivityPreference = "ALLOWLIST"
const SecurityPolicyConnectivityPreferenceALLOWLISTENABLELOGGING SecurityPolicyConnectivityPreference = "ALLOWLIST_ENABLE_LOGGING"
const SecurityPolicyConnectivityPreferenceDENYLIST SecurityPolicyConnectivityPreference = "DENYLIST"
const SecurityPolicyConnectivityPreferenceDENYLISTENABLELOGGING SecurityPolicyConnectivityPreference = "DENYLIST_ENABLE_LOGGING"
const SecurityPolicyConnectivityPreferenceNONE SecurityPolicyConnectivityPreference = "NONE"

var enumValues_SecurityPolicyConnectivityPreference = []interface{}{
	"ALLOWLIST",
	"DENYLIST",
	"ALLOWLIST_ENABLE_LOGGING",
	"DENYLIST_ENABLE_LOGGING",
	"NONE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SecurityPolicyConnectivityPreference) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SecurityPolicyConnectivityPreference {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SecurityPolicyConnectivityPreference, v)
	}
	*j = SecurityPolicyConnectivityPreference(v)
	return nil
}

type SecurityPolicyConnectivityStrategy string

const SecurityPolicyConnectivityStrategyBLACKLIST SecurityPolicyConnectivityStrategy = "BLACKLIST"
const SecurityPolicyConnectivityStrategyBLACKLISTENABLELOGGING SecurityPolicyConnectivityStrategy = "BLACKLIST_ENABLE_LOGGING"
const SecurityPolicyConnectivityStrategyNONE SecurityPolicyConnectivityStrategy = "NONE"
const SecurityPolicyConnectivityStrategyWHITELIST SecurityPolicyConnectivityStrategy = "WHITELIST"
const SecurityPolicyConnectivityStrategyWHITELISTENABLELOGGING SecurityPolicyConnectivityStrategy = "WHITELIST_ENABLE_LOGGING"

var enumValues_SecurityPolicyConnectivityStrategy = []interface{}{
	"WHITELIST",
	"BLACKLIST",
	"WHITELIST_ENABLE_LOGGING",
	"BLACKLIST_ENABLE_LOGGING",
	"NONE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SecurityPolicyConnectivityStrategy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SecurityPolicyConnectivityStrategy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SecurityPolicyConnectivityStrategy, v)
	}
	*j = SecurityPolicyConnectivityStrategy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SecurityPolicy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SecurityPolicy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.ApplicationConnectivityStrategy) > 3 {
		return fmt.Errorf("field %s length: must be <= %d", "application_connectivity_strategy", 3)
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["locked"]; !ok || v == nil {
		plain.Locked = false
	}
	if v, ok := raw["logging_enabled"]; !ok || v == nil {
		plain.LoggingEnabled = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = SecurityPolicy(plain)
	return nil
}

// Segment configuration to attach workloads.
type Segment struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Static address binding used for the Segment. This field is deprecated and will
	// be removed in a future release. Please use address_bindings in SegmentPort to
	// configure static bindings.
	AddressBindings []PortAddressBindingEntry `json:"address_bindings,omitempty" yaml:"address_bindings,omitempty" mapstructure:"address_bindings,omitempty"`

	// Admin state represents desired state of segment. It does not reflect the state
	// of other logical entities connected/attached to the segment.
	AdminState SegmentAdminState `json:"admin_state,omitempty" yaml:"admin_state,omitempty" mapstructure:"admin_state,omitempty"`

	// Advanced configuration for Segment.
	AdvancedConfig *SegmentAdvancedConfig `json:"advanced_config,omitempty" yaml:"advanced_config,omitempty" mapstructure:"advanced_config,omitempty"`

	// Multiple distinct L2 bridge profiles can be configured.
	BridgeProfiles []BridgeProfileConfig `json:"bridge_profiles,omitempty" yaml:"bridge_profiles,omitempty" mapstructure:"bridge_profiles,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Policy path to the connecting Tier-0 or Tier-1 or label of type Tier0. Valid
	// only for segments created under Infra. This field can only be used for overlay
	// segments. VLAN backed segments cannot have connectivity path set.
	ConnectivityPath *string `json:"connectivity_path,omitempty" yaml:"connectivity_path,omitempty" mapstructure:"connectivity_path,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Policy path to DHCP server or relay configuration to use for all IPv4 & IPv6
	// subnets configured on this segment.
	DhcpConfigPath *string `json:"dhcp_config_path,omitempty" yaml:"dhcp_config_path,omitempty" mapstructure:"dhcp_config_path,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// DomainName corresponds to the JSON schema field "domain_name".
	DomainName *string `json:"domain_name,omitempty" yaml:"domain_name,omitempty" mapstructure:"domain_name,omitempty"`

	// Flag to indicate if the Segment is a Child-Segment of type EVPN.
	EvpnSegment *bool `json:"evpn_segment,omitempty" yaml:"evpn_segment,omitempty" mapstructure:"evpn_segment,omitempty"`

	// Policy path to the EvpnTenantConfig resource. Supported only for Route-Server
	// Evpn Mode. Supported only for Overlay Segments. This will be populated for both
	// Parent and Child segments participating in Evpn Route-Server Mode.
	EvpnTenantConfigPath *string `json:"evpn_tenant_config_path,omitempty" yaml:"evpn_tenant_config_path,omitempty" mapstructure:"evpn_tenant_config_path,omitempty"`

	// This property could be used for vendor specific configuration in key value
	// string pairs, the setting in extra_configs will be automatically inheritted by
	// segment ports in the Segment.
	ExtraConfigs []SegmentExtraConfig `json:"extra_configs,omitempty" yaml:"extra_configs,omitempty" mapstructure:"extra_configs,omitempty"`

	// Additional config for federation.
	FederationConfig *FederationConnectivityConfig `json:"federation_config,omitempty" yaml:"federation_config,omitempty" mapstructure:"federation_config,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// L2Extension corresponds to the JSON schema field "l2_extension".
	L2Extension *L2Extension `json:"l2_extension,omitempty" yaml:"l2_extension,omitempty" mapstructure:"l2_extension,omitempty"`

	// This property is deprecated. The property will continue to work as expected for
	// existing segments. The segments that are newly created with ls_id will be
	// ignored. Sepcify pre-creted logical switch id for Segment.
	LsId *string `json:"ls_id,omitempty" yaml:"ls_id,omitempty" mapstructure:"ls_id,omitempty"`

	// Mac pool id that associated with a Segment.
	MacPoolId *string `json:"mac_pool_id,omitempty" yaml:"mac_pool_id,omitempty" mapstructure:"mac_pool_id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// Policy path to metadata proxy configuration. Multiple distinct MD proxies can
	// be configured.
	MetadataProxyPaths []string `json:"metadata_proxy_paths,omitempty" yaml:"metadata_proxy_paths,omitempty" mapstructure:"metadata_proxy_paths,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Used for overlay connectivity of segments. The overlay_id should be allocated
	// from the pool as definied by enforcement-point. If not provided, it is
	// auto-allocated from the default pool on the enforcement-point.
	OverlayId *int `json:"overlay_id,omitempty" yaml:"overlay_id,omitempty" mapstructure:"overlay_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// If this field is not set for overlay segment, then the default of MTEP will be
	// used.
	ReplicationMode SegmentReplicationMode `json:"replication_mode,omitempty" yaml:"replication_mode,omitempty" mapstructure:"replication_mode,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Subnets corresponds to the JSON schema field "subnets".
	Subnets []SegmentSubnet `json:"subnets,omitempty" yaml:"subnets,omitempty" mapstructure:"subnets,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Policy path to the transport zone. Supported for VLAN backed segments as well
	// as Overlay Segments. - This field is required for VLAN backed Segments. - For
	// overlay Segments, it is auto assigned if only one transport zone   exists in
	// the enforcement point. Default transport zone is auto   assigned for  overlay
	// segments if none specified.
	TransportZonePath *string `json:"transport_zone_path,omitempty" yaml:"transport_zone_path,omitempty" mapstructure:"transport_zone_path,omitempty"`

	// Segment type based on configuration.
	Type *SegmentType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`

	// VLAN ids for a VLAN backed Segment. Can be a VLAN id or a range of VLAN ids
	// specified with '-' in between.
	VlanIds []string `json:"vlan_ids,omitempty" yaml:"vlan_ids,omitempty" mapstructure:"vlan_ids,omitempty"`
}

type SegmentAdminState string

const SegmentAdminStateDOWN SegmentAdminState = "DOWN"
const SegmentAdminStateUP SegmentAdminState = "UP"

var enumValues_SegmentAdminState = []interface{}{
	"UP",
	"DOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentAdminState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentAdminState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentAdminState, v)
	}
	*j = SegmentAdminState(v)
	return nil
}

type SegmentAdvancedConfig struct {
	// Policy path to IP address pools.
	AddressPoolPaths []string `json:"address_pool_paths,omitempty" yaml:"address_pool_paths,omitempty" mapstructure:"address_pool_paths,omitempty"`

	// Connectivity configuration to manually connect (ON) or disconnect (OFF)
	// Tier-0/Tier1 segment from corresponding gateway. This property does not apply
	// to VLAN backed segments. VLAN backed segments with connectivity OFF does not
	// affect its layer-2 connectivity.
	Connectivity SegmentAdvancedConfigConnectivity `json:"connectivity,omitempty" yaml:"connectivity,omitempty" mapstructure:"connectivity,omitempty"`

	// When set to true, all the ports created on this segment will behave in a hybrid
	// fashion. The hybrid port indicates to NSX that the VM intends to operate in
	// underlay mode, but retains the ability to forward egress traffic to the NSX
	// overlay network. This property is only applicable for segment created with
	// transport zone type OVERLAY_STANDARD. This property cannot be modified after
	// segment is created.
	Hybrid bool `json:"hybrid,omitempty" yaml:"hybrid,omitempty" mapstructure:"hybrid,omitempty"`

	// When set to true, any port attached to this logical switch will not be visible
	// through VC/ESX UI
	InterRouter bool `json:"inter_router,omitempty" yaml:"inter_router,omitempty" mapstructure:"inter_router,omitempty"`

	// This property is used to enable proximity routing with local egress. When set
	// to true, logical router interface (downlink) connecting Segment to Tier0/Tier1
	// gateway is configured with prefix-length 32.
	LocalEgress bool `json:"local_egress,omitempty" yaml:"local_egress,omitempty" mapstructure:"local_egress,omitempty"`

	// An ordered list of routing policies to forward traffic to the next hop.
	LocalEgressRoutingPolicies []LocalEgressRoutingEntry `json:"local_egress_routing_policies,omitempty" yaml:"local_egress_routing_policies,omitempty" mapstructure:"local_egress_routing_policies,omitempty"`

	// Enable multicast on the downlink LRP created to connect the segment to
	// Tier0/Tier1 gateway.
	Multicast *bool `json:"multicast,omitempty" yaml:"multicast,omitempty" mapstructure:"multicast,omitempty"`

	// This profile is applie dto the downlink logical router port created while
	// attaching this semgnet to tier-0 or tier-1. If this field is empty, NDRA
	// profile of the router is applied to the newly created port.
	NdraProfilePath *string `json:"ndra_profile_path,omitempty" yaml:"ndra_profile_path,omitempty" mapstructure:"ndra_profile_path,omitempty"`

	// A behaviour required for Firewall As A Service (FaaS) where the segment BUM
	// traffic is confined within the edge node that this segment belongs to.
	NodeLocalSwitch *bool `json:"node_local_switch,omitempty" yaml:"node_local_switch,omitempty" mapstructure:"node_local_switch,omitempty"`

	// ID populated by NSX when NSX on DVPG is used to indicate the source DVPG.
	// Currently, only DVPortgroups are identified as Discovered Segments. The
	// origin_id is the identifier of DVPortgroup from the source vCenter server.
	OriginId *string `json:"origin_id,omitempty" yaml:"origin_id,omitempty" mapstructure:"origin_id,omitempty"`

	// The type of source from where the DVPortgroup is discovered
	OriginType *SegmentAdvancedConfigOriginType `json:"origin_type,omitempty" yaml:"origin_type,omitempty" mapstructure:"origin_type,omitempty"`

	// The name of the switching uplink teaming policy for the Segment. This name
	// corresponds to one of the switching uplink teaming policy names listed in
	// TransportZone associated with the Segment. See transport_zone_path property
	// above for more details. When this property is not specified, the segment will
	// not have a teaming policy associated with it and the host switch's default
	// teaming policy will be used by MP.
	UplinkTeamingPolicyName *string `json:"uplink_teaming_policy_name,omitempty" yaml:"uplink_teaming_policy_name,omitempty" mapstructure:"uplink_teaming_policy_name,omitempty"`

	// This URPF mode is applied to the downlink logical router port created while
	// attaching this segment to tier-0 or tier-1.
	UrpfMode SegmentAdvancedConfigUrpfMode `json:"urpf_mode,omitempty" yaml:"urpf_mode,omitempty" mapstructure:"urpf_mode,omitempty"`
}

type SegmentAdvancedConfigConnectivity string

const SegmentAdvancedConfigConnectivityOFF SegmentAdvancedConfigConnectivity = "OFF"
const SegmentAdvancedConfigConnectivityON SegmentAdvancedConfigConnectivity = "ON"

var enumValues_SegmentAdvancedConfigConnectivity = []interface{}{
	"ON",
	"OFF",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentAdvancedConfigConnectivity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentAdvancedConfigConnectivity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentAdvancedConfigConnectivity, v)
	}
	*j = SegmentAdvancedConfigConnectivity(v)
	return nil
}

type SegmentAdvancedConfigOriginType string

const SegmentAdvancedConfigOriginTypeVCENTER SegmentAdvancedConfigOriginType = "VCENTER"

var enumValues_SegmentAdvancedConfigOriginType = []interface{}{
	"VCENTER",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentAdvancedConfigOriginType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentAdvancedConfigOriginType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentAdvancedConfigOriginType, v)
	}
	*j = SegmentAdvancedConfigOriginType(v)
	return nil
}

type SegmentAdvancedConfigUrpfMode string

const SegmentAdvancedConfigUrpfModeNONE SegmentAdvancedConfigUrpfMode = "NONE"
const SegmentAdvancedConfigUrpfModeSTRICT SegmentAdvancedConfigUrpfMode = "STRICT"

var enumValues_SegmentAdvancedConfigUrpfMode = []interface{}{
	"NONE",
	"STRICT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentAdvancedConfigUrpfMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentAdvancedConfigUrpfMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentAdvancedConfigUrpfMode, v)
	}
	*j = SegmentAdvancedConfigUrpfMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentAdvancedConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SegmentAdvancedConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.AddressPoolPaths) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "address_pool_paths", 1)
	}
	if v, ok := raw["connectivity"]; !ok || v == nil {
		plain.Connectivity = "ON"
	}
	if v, ok := raw["hybrid"]; !ok || v == nil {
		plain.Hybrid = false
	}
	if v, ok := raw["inter_router"]; !ok || v == nil {
		plain.InterRouter = false
	}
	if v, ok := raw["local_egress"]; !ok || v == nil {
		plain.LocalEgress = false
	}
	if plain.LocalEgressRoutingPolicies != nil && len(plain.LocalEgressRoutingPolicies) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "local_egress_routing_policies", 1)
	}
	if v, ok := raw["urpf_mode"]; !ok || v == nil {
		plain.UrpfMode = "STRICT"
	}
	*j = SegmentAdvancedConfig(plain)
	return nil
}

// DHCP IPv4 and IPv6 configurations are extended from this abstract class.
type SegmentDhcpConfig struct {
	// IP address of DNS servers for subnet. DNS server IP address must belong to the
	// same address family as segment gateway_address property.
	DnsServers []IPAddress `json:"dns_servers,omitempty" yaml:"dns_servers,omitempty" mapstructure:"dns_servers,omitempty"`

	// DHCP lease time in seconds. When specified, this property overwrites lease time
	// configured DHCP server config.
	LeaseTime int `json:"lease_time,omitempty" yaml:"lease_time,omitempty" mapstructure:"lease_time,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *SegmentDhcpConfigResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// IP address of the DHCP server in CIDR format. The server_address is mandatory
	// in case this segment has provided a dhcp_config_path and it represents a DHCP
	// server config. If this SegmentDhcpConfig is a SegmentDhcpV4Config, the address
	// must be an IPv4 address. If this is a SegmentDhcpV6Config, the address must be
	// an IPv6 address. This address must not overlap the ip-ranges of the subnet, or
	// the gateway address of the subnet, or the DHCP static-binding addresses of this
	// segment.
	ServerAddress *IPCIDRBlock `json:"server_address,omitempty" yaml:"server_address,omitempty" mapstructure:"server_address,omitempty"`
}

type SegmentDhcpConfigResourceType string

const SegmentDhcpConfigResourceTypeSegmentDhcpV4Config SegmentDhcpConfigResourceType = "SegmentDhcpV4Config"
const SegmentDhcpConfigResourceTypeSegmentDhcpV6Config SegmentDhcpConfigResourceType = "SegmentDhcpV6Config"

var enumValues_SegmentDhcpConfigResourceType = []interface{}{
	"SegmentDhcpV4Config",
	"SegmentDhcpV6Config",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentDhcpConfigResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentDhcpConfigResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentDhcpConfigResourceType, v)
	}
	*j = SegmentDhcpConfigResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentDhcpConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SegmentDhcpConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.DnsServers) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "dns_servers", 2)
	}
	if v, ok := raw["lease_time"]; !ok || v == nil {
		plain.LeaseTime = 86400.0
	}
	*j = SegmentDhcpConfig(plain)
	return nil
}

// Segment extra config is intended for supporting vendor specific configuration on
// the data path, it can be set as key value string pairs on either segment or
// segment port.
type SegmentExtraConfig struct {
	// Key value pair in string for the configuration.
	ConfigPair *UnboundedKeyValuePair `json:"config_pair,omitempty" yaml:"config_pair,omitempty" mapstructure:"config_pair,omitempty"`
}

// Policy port will create LogicalPort on LogicalSwitch corresponding to the
// Segment. Address bindings cannot be removed after realization.
type SegmentPort struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Static address binding used for the port.
	AddressBindings []PortAddressBindingEntry `json:"address_bindings,omitempty" yaml:"address_bindings,omitempty" mapstructure:"address_bindings,omitempty"`

	// AdminState corresponds to the JSON schema field "admin_state".
	AdminState SegmentPortAdminState `json:"admin_state,omitempty" yaml:"admin_state,omitempty" mapstructure:"admin_state,omitempty"`

	// Only VIF attachment is supported
	Attachment *PortAttachment `json:"attachment,omitempty" yaml:"attachment,omitempty" mapstructure:"attachment,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// This property could be used for vendor specific configuration in key value
	// string pairs. Segment port setting will override segment setting if the same
	// key was set on both segment and segment port.
	ExtraConfigs []SegmentExtraConfig `json:"extra_configs,omitempty" yaml:"extra_configs,omitempty" mapstructure:"extra_configs,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// IP Discovery module uses various mechanisms to discover address bindings being
	// used on each segment port. If a user would like to ignore any specific
	// discovered address bindings or prevent the discovery of a particular set of
	// discovered bindings, then those address bindings can be provided here.
	// Currently IP range in CIDR format is not supported.
	IgnoredAddressBindings []PortAddressBindingEntry `json:"ignored_address_bindings,omitempty" yaml:"ignored_address_bindings,omitempty" mapstructure:"ignored_address_bindings,omitempty"`

	// Set initial state when a new logical port is created. 'UNBLOCKED_VLAN' means
	// new port will be unblocked on traffic in creation, also VLAN will be set with
	// corresponding logical switch setting. This port setting can only be configured
	// at port creation, and cannot be modified. 'RESTORE_VIF' fetches and restores
	// VIF attachment from ESX host.
	InitState *SegmentPortInitState `json:"init_state,omitempty" yaml:"init_state,omitempty" mapstructure:"init_state,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// ID populated by NSX when NSX on DVPG is used to indicate the source Distributed
	// Virtual Port and the corresponding Distributed Virtual Switch. This ID is
	// populated only for ports attached to discovered segments.
	OriginId *string `json:"origin_id,omitempty" yaml:"origin_id,omitempty" mapstructure:"origin_id,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// This field will refer to the source site on which the segment port is
	// discovered. This field is populated by GM, when it receives corresponding
	// notification from LM.
	SourceSiteId *string `json:"source_site_id,omitempty" yaml:"source_site_id,omitempty" mapstructure:"source_site_id,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type SegmentPortAdminState string

const SegmentPortAdminStateDOWN SegmentPortAdminState = "DOWN"
const SegmentPortAdminStateUP SegmentPortAdminState = "UP"

var enumValues_SegmentPortAdminState = []interface{}{
	"UP",
	"DOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentPortAdminState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentPortAdminState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentPortAdminState, v)
	}
	*j = SegmentPortAdminState(v)
	return nil
}

type SegmentPortInitState string

const SegmentPortInitStateRESTOREVIF SegmentPortInitState = "RESTORE_VIF"
const SegmentPortInitStateUNBLOCKEDVLAN SegmentPortInitState = "UNBLOCKED_VLAN"

var enumValues_SegmentPortInitState = []interface{}{
	"UNBLOCKED_VLAN",
	"RESTORE_VIF",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentPortInitState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentPortInitState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentPortInitState, v)
	}
	*j = SegmentPortInitState(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentPort) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SegmentPort
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.AddressBindings) > 512 {
		return fmt.Errorf("field %s length: must be <= %d", "address_bindings", 512)
	}
	if v, ok := raw["admin_state"]; !ok || v == nil {
		plain.AdminState = "UP"
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.IgnoredAddressBindings) > 16 {
		return fmt.Errorf("field %s length: must be <= %d", "ignored_address_bindings", 16)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = SegmentPort(plain)
	return nil
}

type SegmentReplicationMode string

const SegmentReplicationModeMTEP SegmentReplicationMode = "MTEP"
const SegmentReplicationModeSOURCE SegmentReplicationMode = "SOURCE"

var enumValues_SegmentReplicationMode = []interface{}{
	"MTEP",
	"SOURCE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentReplicationMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentReplicationMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentReplicationMode, v)
	}
	*j = SegmentReplicationMode(v)
	return nil
}

type SegmentSubnet struct {
	// Additional DHCP configuration for current subnet.
	DhcpConfig *SegmentDhcpConfig `json:"dhcp_config,omitempty" yaml:"dhcp_config,omitempty" mapstructure:"dhcp_config,omitempty"`

	// DHCP address ranges are used for dynamic IP allocation. Supports address range
	// and CIDR formats. First valid host address from the first value is assigned to
	// DHCP server IP address. Existing values cannot be deleted or modified, but
	// additional DHCP ranges can be added.
	DhcpRanges []IPElement `json:"dhcp_ranges,omitempty" yaml:"dhcp_ranges,omitempty" mapstructure:"dhcp_ranges,omitempty"`

	// Gateway IP address in CIDR format for both IPv4 and IPv6.
	GatewayAddress *string `json:"gateway_address,omitempty" yaml:"gateway_address,omitempty" mapstructure:"gateway_address,omitempty"`

	// Network CIDR for this subnet calculated from gateway_addresses and prefix_len.
	Network *string `json:"network,omitempty" yaml:"network,omitempty" mapstructure:"network,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentSubnet) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SegmentSubnet
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.DhcpRanges != nil && len(plain.DhcpRanges) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "dhcp_ranges", 1)
	}
	if len(plain.DhcpRanges) > 99 {
		return fmt.Errorf("field %s length: must be <= %d", "dhcp_ranges", 99)
	}
	*j = SegmentSubnet(plain)
	return nil
}

type SegmentType string

const SegmentTypeDISCONNECTED SegmentType = "DISCONNECTED"
const SegmentTypeEXTENDED SegmentType = "EXTENDED"
const SegmentTypeROUTED SegmentType = "ROUTED"
const SegmentTypeROUTEDANDEXTENDED SegmentType = "ROUTED_AND_EXTENDED"

var enumValues_SegmentType = []interface{}{
	"ROUTED",
	"EXTENDED",
	"ROUTED_AND_EXTENDED",
	"DISCONNECTED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentType, v)
	}
	*j = SegmentType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Segment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Segment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.AddressBindings) > 512 {
		return fmt.Errorf("field %s length: must be <= %d", "address_bindings", 512)
	}
	if v, ok := raw["admin_state"]; !ok || v == nil {
		plain.AdminState = "UP"
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if v, ok := raw["replication_mode"]; !ok || v == nil {
		plain.ReplicationMode = "MTEP"
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Segment(plain)
	return nil
}

// The server will populate this field when returing the resource. Ignored on PUT
// and POST.
type SelfResourceLink struct {
	// Action corresponds to the JSON schema field "action".
	Action *string `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Href corresponds to the JSON schema field "href".
	Href *string `json:"href,omitempty" yaml:"href,omitempty" mapstructure:"href,omitempty"`

	// Custom relation type (follows RFC 5988 where appropriate definitions exist)
	Rel *string `json:"rel,omitempty" yaml:"rel,omitempty" mapstructure:"rel,omitempty"`
}

// Used while defining a CommunicationEntry. A service may have multiple service
// entries.
type Service struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// The flag, if true, indicates that service is created in the system by default.
	// Such default services can't be modified/deleted.
	IsDefault bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Service entries for this service
	ServiceEntries []ServiceEntry `json:"service_entries,omitempty" yaml:"service_entries,omitempty" mapstructure:"service_entries,omitempty"`

	// ServiceType corresponds to the JSON schema field "service_type".
	ServiceType *string `json:"service_type,omitempty" yaml:"service_type,omitempty" mapstructure:"service_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ServiceEntry struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ServiceEntryResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ServiceEntryResourceType string

const ServiceEntryResourceTypeALGTypeServiceEntry ServiceEntryResourceType = "ALGTypeServiceEntry"
const ServiceEntryResourceTypeEtherTypeServiceEntry ServiceEntryResourceType = "EtherTypeServiceEntry"
const ServiceEntryResourceTypeICMPTypeServiceEntry ServiceEntryResourceType = "ICMPTypeServiceEntry"
const ServiceEntryResourceTypeIGMPTypeServiceEntry ServiceEntryResourceType = "IGMPTypeServiceEntry"
const ServiceEntryResourceTypeIPProtocolServiceEntry ServiceEntryResourceType = "IPProtocolServiceEntry"
const ServiceEntryResourceTypeL4PortSetServiceEntry ServiceEntryResourceType = "L4PortSetServiceEntry"
const ServiceEntryResourceTypeNestedServiceServiceEntry ServiceEntryResourceType = "NestedServiceServiceEntry"

var enumValues_ServiceEntryResourceType = []interface{}{
	"IPProtocolServiceEntry",
	"IGMPTypeServiceEntry",
	"ICMPTypeServiceEntry",
	"ALGTypeServiceEntry",
	"L4PortSetServiceEntry",
	"EtherTypeServiceEntry",
	"NestedServiceServiceEntry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServiceEntryResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ServiceEntryResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ServiceEntryResourceType, v)
	}
	*j = ServiceEntryResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServiceEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ServiceEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = ServiceEntry(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Service) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Service
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["is_default"]; !ok || v == nil {
		plain.IsDefault = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Service(plain)
	return nil
}

// Static IP allocation for VPC Subnet ports with VIF attachement
type StaticIpAllocation struct {
	// Enable ip and mac addresse allocation for VPC Subnet ports from static ip pool.
	// To enable this, dhcp pool shall be empty and static ip pool shall own all
	// available ip addresses.
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StaticIpAllocation) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain StaticIpAllocation
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		plain.Enabled = false
	}
	*j = StaticIpAllocation(plain)
	return nil
}

// Static IP pool configuration
type StaticPoolConfig struct {
	// Number of IPs to be reserved in static ip pool. Maximum allowed value is
	// 'subnet size - 4'. If dhcp is enabled then by default static ipv4 pool size
	// will be zero and all available IPs will be reserved in local dhcp pool. If dhcp
	// is deactivated then by default all IPs will be reserved in static ip pool.
	Ipv4PoolSize int `json:"ipv4_pool_size,omitempty" yaml:"ipv4_pool_size,omitempty" mapstructure:"ipv4_pool_size,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *StaticPoolConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain StaticPoolConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["ipv4_pool_size"]; !ok || v == nil {
		plain.Ipv4PoolSize = 0.0
	}
	*j = StaticPoolConfig(plain)
	return nil
}

// VPC Subnet Advanced Configuration
type SubnetAdvancedConfig struct {
	// Static IP allocation configuration for VPC Subnet ports with VIF attachement.
	// Not supported when DUAL ip_address_type is used in parent VPC.
	StaticIpAllocation *StaticIpAllocation `json:"static_ip_allocation,omitempty" yaml:"static_ip_allocation,omitempty" mapstructure:"static_ip_allocation,omitempty"`
}

type Tag struct {
	// Tag searches may optionally be restricted by scope
	Scope string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// Identifier meaningful to user with maximum length of 256 characters
	Tag string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tag) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Tag
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["scope"]; !ok || v == nil {
		plain.Scope = ""
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if v, ok := raw["tag"]; !ok || v == nil {
		plain.Tag = ""
	}
	*j = Tag(plain)
	return nil
}

type UnboundedKeyValuePair struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type VirtualMachine struct {
	// Timestamp of last modification
	LastSyncTime *EpochMsTimestamp `json:"_last_sync_time,omitempty" yaml:"_last_sync_time,omitempty" mapstructure:"_last_sync_time,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// ComputeIds corresponds to the JSON schema field "compute_ids".
	ComputeIds []string `json:"compute_ids,omitempty" yaml:"compute_ids,omitempty" mapstructure:"compute_ids,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// ExternalId corresponds to the JSON schema field "external_id".
	ExternalId *string `json:"external_id,omitempty" yaml:"external_id,omitempty" mapstructure:"external_id,omitempty"`

	// Guest virtual machine details include OS name, computer name of guest VM.
	// Currently this is supported for guests on ESXi that have VMware Tools
	// installed.
	GuestInfo *GuestInfo `json:"guest_info,omitempty" yaml:"guest_info,omitempty" mapstructure:"guest_info,omitempty"`

	// HostId corresponds to the JSON schema field "host_id".
	HostId *string `json:"host_id,omitempty" yaml:"host_id,omitempty" mapstructure:"host_id,omitempty"`

	// LocalIdOnHost corresponds to the JSON schema field "local_id_on_host".
	LocalIdOnHost *string `json:"local_id_on_host,omitempty" yaml:"local_id_on_host,omitempty" mapstructure:"local_id_on_host,omitempty"`

	// PowerState corresponds to the JSON schema field "power_state".
	PowerState *VirtualMachinePowerState `json:"power_state,omitempty" yaml:"power_state,omitempty" mapstructure:"power_state,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Specifies runtime details of virtual machine.
	RuntimeInfo *VirtualMachineRuntimeInfo `json:"runtime_info,omitempty" yaml:"runtime_info,omitempty" mapstructure:"runtime_info,omitempty"`

	// Specifies list of scope of discovered resource. e.g. if VHC path is associated
	// with principal identity, who owns the discovered resource, then scope id will
	// be VHC path and scope type will be VHC.
	Scope []DiscoveredResourceScope `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// Source corresponds to the JSON schema field "source".
	Source *ResourceReference `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *VirtualMachineType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// If UPT enabled is true for any virtual network interface of the virtual
	// machine, then this property is true for the virtual machine.
	Uptv2Enabled *bool `json:"uptv2_enabled,omitempty" yaml:"uptv2_enabled,omitempty" mapstructure:"uptv2_enabled,omitempty"`
}

type VirtualMachinePowerState string

const VirtualMachinePowerStateUNKNOWN VirtualMachinePowerState = "UNKNOWN"
const VirtualMachinePowerStateVMRUNNING VirtualMachinePowerState = "VM_RUNNING"
const VirtualMachinePowerStateVMSTOPPED VirtualMachinePowerState = "VM_STOPPED"
const VirtualMachinePowerStateVMSUSPENDED VirtualMachinePowerState = "VM_SUSPENDED"

var enumValues_VirtualMachinePowerState = []interface{}{
	"VM_RUNNING",
	"VM_STOPPED",
	"VM_SUSPENDED",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualMachinePowerState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VirtualMachinePowerState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VirtualMachinePowerState, v)
	}
	*j = VirtualMachinePowerState(v)
	return nil
}

// Specifies details of runtime for a virtual machine
type VirtualMachineRuntimeInfo struct {
	// Specifies list of runtime details of virtual network interfaces of virtual
	// machine.
	VifRuntimeInfo []VirtualNetworkInterfaceRuntimeInfo `json:"vif_runtime_info,omitempty" yaml:"vif_runtime_info,omitempty" mapstructure:"vif_runtime_info,omitempty"`
}

type VirtualMachineType string

const VirtualMachineTypeEDGE VirtualMachineType = "EDGE"
const VirtualMachineTypeINTELLIGENCE VirtualMachineType = "INTELLIGENCE"
const VirtualMachineTypeMP VirtualMachineType = "MP"
const VirtualMachineTypeREGULAR VirtualMachineType = "REGULAR"
const VirtualMachineTypeSERVICE VirtualMachineType = "SERVICE"
const VirtualMachineTypeUNKNOWN VirtualMachineType = "UNKNOWN"
const VirtualMachineTypeVCSYSTEM VirtualMachineType = "VC_SYSTEM"

var enumValues_VirtualMachineType = []interface{}{
	"EDGE",
	"SERVICE",
	"REGULAR",
	"MP",
	"INTELLIGENCE",
	"VC_SYSTEM",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualMachineType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VirtualMachineType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VirtualMachineType, v)
	}
	*j = VirtualMachineType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualMachine) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VirtualMachine
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = VirtualMachine(plain)
	return nil
}

type VirtualNetworkInterface struct {
	// Timestamp of last modification
	LastSyncTime *EpochMsTimestamp `json:"_last_sync_time,omitempty" yaml:"_last_sync_time,omitempty" mapstructure:"_last_sync_time,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// DeviceKey corresponds to the JSON schema field "device_key".
	DeviceKey *string `json:"device_key,omitempty" yaml:"device_key,omitempty" mapstructure:"device_key,omitempty"`

	// DeviceName corresponds to the JSON schema field "device_name".
	DeviceName *string `json:"device_name,omitempty" yaml:"device_name,omitempty" mapstructure:"device_name,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// ExternalId corresponds to the JSON schema field "external_id".
	ExternalId *string `json:"external_id,omitempty" yaml:"external_id,omitempty" mapstructure:"external_id,omitempty"`

	// HostId corresponds to the JSON schema field "host_id".
	HostId *string `json:"host_id,omitempty" yaml:"host_id,omitempty" mapstructure:"host_id,omitempty"`

	// IpAddressInfo corresponds to the JSON schema field "ip_address_info".
	IpAddressInfo []IpAddressInfo `json:"ip_address_info,omitempty" yaml:"ip_address_info,omitempty" mapstructure:"ip_address_info,omitempty"`

	// LportAttachmentId corresponds to the JSON schema field "lport_attachment_id".
	LportAttachmentId *string `json:"lport_attachment_id,omitempty" yaml:"lport_attachment_id,omitempty" mapstructure:"lport_attachment_id,omitempty"`

	// MacAddress corresponds to the JSON schema field "mac_address".
	MacAddress *string `json:"mac_address,omitempty" yaml:"mac_address,omitempty" mapstructure:"mac_address,omitempty"`

	// OwnerVmId corresponds to the JSON schema field "owner_vm_id".
	OwnerVmId *string `json:"owner_vm_id,omitempty" yaml:"owner_vm_id,omitempty" mapstructure:"owner_vm_id,omitempty"`

	// OwnerVmType corresponds to the JSON schema field "owner_vm_type".
	OwnerVmType *VirtualNetworkInterfaceOwnerVmType `json:"owner_vm_type,omitempty" yaml:"owner_vm_type,omitempty" mapstructure:"owner_vm_type,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Specifies list of scope of discovered resource. e.g. if VHC path is associated
	// with principal identity, who owns the discovered resource, then scope id will
	// be VHC path and scope type will be VHC.
	Scope []DiscoveredResourceScope `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Specifies if UPTv2 (Universal Pass-through version 2) compatibility is enabled
	// for the virtual network interface or not.
	Uptv2Enabled *bool `json:"uptv2_enabled,omitempty" yaml:"uptv2_enabled,omitempty" mapstructure:"uptv2_enabled,omitempty"`

	// VmLocalIdOnHost corresponds to the JSON schema field "vm_local_id_on_host".
	VmLocalIdOnHost *string `json:"vm_local_id_on_host,omitempty" yaml:"vm_local_id_on_host,omitempty" mapstructure:"vm_local_id_on_host,omitempty"`
}

type VirtualNetworkInterfaceOwnerVmType VirtualMachineType


// Runtime details of virtual network interface of virtual machine.
type VirtualNetworkInterfaceRuntimeInfo struct {
	// ExternalId corresponds to the JSON schema field "external_id".
	ExternalId *string `json:"external_id,omitempty" yaml:"external_id,omitempty" mapstructure:"external_id,omitempty"`

	// This flag specifies whether UPTv2 (Universal Pass-through version 2) is active
	// on the virtual network interface or not. If TRUE, then the virtual network
	// interface works in the pass-through mode. If FALSE, then the virtual network
	// interface still has network connectivity but works in emulated mode and
	// pass-through is not enabled. This flag is NONE, if it is not applicable.
	Uptv2Active *VirtualNetworkInterfaceRuntimeInfoUptv2Active `json:"uptv2_active,omitempty" yaml:"uptv2_active,omitempty" mapstructure:"uptv2_active,omitempty"`
}

type VirtualNetworkInterfaceRuntimeInfoUptv2Active string

const VirtualNetworkInterfaceRuntimeInfoUptv2ActiveNONE VirtualNetworkInterfaceRuntimeInfoUptv2Active = "NONE"

var enumValues_VirtualNetworkInterfaceRuntimeInfoUptv2Active = []interface{}{
	"NONE",
	true,
	false,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualNetworkInterfaceRuntimeInfoUptv2Active) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VirtualNetworkInterfaceRuntimeInfoUptv2Active {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VirtualNetworkInterfaceRuntimeInfoUptv2Active, v)
	}
	*j = VirtualNetworkInterfaceRuntimeInfoUptv2Active(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualNetworkInterface) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VirtualNetworkInterface
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = VirtualNetworkInterface(plain)
	return nil
}

type VlanID int

// VPC Subnet provides self-service and allows the application users to create
// networks within the VPC and attach workloads to them.
type VpcSubnet struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// There are three kinds of Access Types supported for an Application. Private  -
	// VPC Subnet is accessible only within the application and its IPs are allocated
	// from            private IP address pool from VPC configuration unless specified
	// explicitly by user. Public   - VPC Subnet is accessible from external networks
	// and its IPs are allocated from public IP            address pool from VPC
	// configuration unless specified explicitly by user. Isolated - VPC Subnet is not
	// accessible from other VPC Subnets within the same VPC.
	AccessMode VpcSubnetAccessMode `json:"access_mode,omitempty" yaml:"access_mode,omitempty" mapstructure:"access_mode,omitempty"`

	// VPC Subnet advanced configuration. This field is supported only for VPC Subnets
	// on NSX local manager.
	AdvancedConfig *SubnetAdvancedConfig `json:"advanced_config,omitempty" yaml:"advanced_config,omitempty" mapstructure:"advanced_config,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// DHCP configuration to be applied on this VPC Subnet if the IP address type is
	// IPv4. If not specified, VPC dhcp configuration will be applied on the VPC
	// Subnet. VPC Subnet DHCP config will take precedence over VPC dhcp config, if
	// available at both places.
	DhcpConfig *VpcSubnetDhcpConfig `json:"dhcp_config,omitempty" yaml:"dhcp_config,omitempty" mapstructure:"dhcp_config,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// If not provided, Ip assignment will be done based on VPC CIDRs This represents
	// the VPC Subnet that is associated with tier. If IPv4 CIDR is given,
	// ipv4_subnet_size property is ignored. For IPv6 CIDR, supported prefix length is
	// /64.
	IpAddresses []string `json:"ip_addresses,omitempty" yaml:"ip_addresses,omitempty" mapstructure:"ip_addresses,omitempty"`

	// If IP Addresses are not provided, this field will be used to carve out the ips
	// from respective ip block defined in the parent VPC. The default is 64. If
	// ip_addresses field is provided then ipv4_subnet_size field is ignored. This
	// field cannot be modified after creating a VPC Subnet.
	Ipv4SubnetSize *int `json:"ipv4_subnet_size,omitempty" yaml:"ipv4_subnet_size,omitempty" mapstructure:"ipv4_subnet_size,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type VpcSubnetAccessMode string

const VpcSubnetAccessModeIsolated VpcSubnetAccessMode = "Isolated"
const VpcSubnetAccessModePrivate VpcSubnetAccessMode = "Private"
const VpcSubnetAccessModePublic VpcSubnetAccessMode = "Public"

var enumValues_VpcSubnetAccessMode = []interface{}{
	"Private",
	"Public",
	"Isolated",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VpcSubnetAccessMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VpcSubnetAccessMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VpcSubnetAccessMode, v)
	}
	*j = VpcSubnetAccessMode(v)
	return nil
}

// VPC Subnet DHCP config
type VpcSubnetDhcpConfig struct {
	// Policy path of DHCP-relay-config. If configured then all the subnets will be
	// configured with the DHCP relay server. If not specified, then the local DHCP
	// server will be configured for all connected subnets.
	DhcpRelayConfigPath *string `json:"dhcp_relay_config_path,omitempty" yaml:"dhcp_relay_config_path,omitempty" mapstructure:"dhcp_relay_config_path,omitempty"`

	// Dns configuration
	DnsClientConfig *DnsClientConfig `json:"dns_client_config,omitempty" yaml:"dns_client_config,omitempty" mapstructure:"dns_client_config,omitempty"`

	// If activated, the DHCP server will be configured based on IP address type. If
	// deactivated then neither DHCP server nor relay shall be configured.
	EnableDhcp *bool `json:"enable_dhcp,omitempty" yaml:"enable_dhcp,omitempty" mapstructure:"enable_dhcp,omitempty"`

	// Static IP pool configuration.
	StaticPoolConfig *StaticPoolConfig `json:"static_pool_config,omitempty" yaml:"static_pool_config,omitempty" mapstructure:"static_pool_config,omitempty"`
}

// VPC Subnet port will create LogicalPort on LogicalSwitch corresponding to the
// Subnet. Address bindings cannot be removed after realization.
type VpcSubnetPort struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// ID of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// ID of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Static address binding used for the port.
	AddressBindings []PortAddressBindingEntry `json:"address_bindings,omitempty" yaml:"address_bindings,omitempty" mapstructure:"address_bindings,omitempty"`

	// AdminState corresponds to the JSON schema field "admin_state".
	AdminState VpcSubnetPortAdminState `json:"admin_state,omitempty" yaml:"admin_state,omitempty" mapstructure:"admin_state,omitempty"`

	// Only VIF attachment is supported
	Attachment *PortAttachment `json:"attachment,omitempty" yaml:"attachment,omitempty" mapstructure:"attachment,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to ID if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// This property could be used for vendor specific configuration in key value
	// string pairs. Segment port setting will override segment setting if the same
	// key was set on both segment and segment port.
	ExtraConfigs []SegmentExtraConfig `json:"extra_configs,omitempty" yaml:"extra_configs,omitempty" mapstructure:"extra_configs,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// IP Discovery module uses various mechanisms to discover address bindings being
	// used on each segment port. If a user would like to ignore any specific
	// discovered address bindings or prevent the discovery of a particular set of
	// discovered bindings, then those address bindings can be provided here.
	// Currently IP range in CIDR format is not supported.
	IgnoredAddressBindings []PortAddressBindingEntry `json:"ignored_address_bindings,omitempty" yaml:"ignored_address_bindings,omitempty" mapstructure:"ignored_address_bindings,omitempty"`

	// Set initial state when a new logical port is created. 'UNBLOCKED_VLAN' means
	// new port will be unblocked on traffic in creation, also VLAN will be set with
	// corresponding logical switch setting. This port setting can only be configured
	// at port creation, and cannot be modified. 'RESTORE_VIF' fetches and restores
	// VIF attachment from ESX host.
	InitState *VpcSubnetPortInitState `json:"init_state,omitempty" yaml:"init_state,omitempty" mapstructure:"init_state,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// ID populated by NSX when NSX on DVPG is used to indicate the source Distributed
	// Virtual Port and the corresponding Distributed Virtual Switch. This ID is
	// populated only for ports attached to discovered segments.
	OriginId *string `json:"origin_id,omitempty" yaml:"origin_id,omitempty" mapstructure:"origin_id,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// This field will refer to the source site on which the segment port is
	// discovered. This field is populated by GM, when it receives corresponding
	// notification from LM.
	SourceSiteId *string `json:"source_site_id,omitempty" yaml:"source_site_id,omitempty" mapstructure:"source_site_id,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same ID will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type VpcSubnetPortAdminState string

const VpcSubnetPortAdminStateDOWN VpcSubnetPortAdminState = "DOWN"
const VpcSubnetPortAdminStateUP VpcSubnetPortAdminState = "UP"

var enumValues_VpcSubnetPortAdminState = []interface{}{
	"UP",
	"DOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VpcSubnetPortAdminState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VpcSubnetPortAdminState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VpcSubnetPortAdminState, v)
	}
	*j = VpcSubnetPortAdminState(v)
	return nil
}

type VpcSubnetPortInitState string

const VpcSubnetPortInitStateRESTOREVIF VpcSubnetPortInitState = "RESTORE_VIF"
const VpcSubnetPortInitStateUNBLOCKEDVLAN VpcSubnetPortInitState = "UNBLOCKED_VLAN"

var enumValues_VpcSubnetPortInitState = []interface{}{
	"UNBLOCKED_VLAN",
	"RESTORE_VIF",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VpcSubnetPortInitState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VpcSubnetPortInitState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VpcSubnetPortInitState, v)
	}
	*j = VpcSubnetPortInitState(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VpcSubnetPort) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VpcSubnetPort
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.AddressBindings) > 512 {
		return fmt.Errorf("field %s length: must be <= %d", "address_bindings", 512)
	}
	if v, ok := raw["admin_state"]; !ok || v == nil {
		plain.AdminState = "UP"
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.IgnoredAddressBindings) > 16 {
		return fmt.Errorf("field %s length: must be <= %d", "ignored_address_bindings", 16)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = VpcSubnetPort(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VpcSubnet) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VpcSubnet
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["access_mode"]; !ok || v == nil {
		plain.AccessMode = "Private"
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.IpAddresses) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "ip_addresses", 2)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = VpcSubnet(plain)
	return nil
}
