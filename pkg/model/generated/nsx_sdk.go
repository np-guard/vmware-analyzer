// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package resources

import "encoding/json"
import "fmt"
import "net/netip"
import "reflect"

type ALGTypeServiceEntry struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// The Application Layer Gateway (ALG) protocol. Please note, protocol
	// NBNS_BROADCAST and NBDG_BROADCAST are  deprecated. Please use UDP protocol and
	// create L4 Port Set type of service instead.
	Alg *ALGTypeServiceEntryAlg `json:"alg,omitempty" yaml:"alg,omitempty" mapstructure:"alg,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// DestinationPorts corresponds to the JSON schema field "destination_ports".
	DestinationPorts []PortElement `json:"destination_ports,omitempty" yaml:"destination_ports,omitempty" mapstructure:"destination_ports,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ALGTypeServiceEntryResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// SourcePorts corresponds to the JSON schema field "source_ports".
	SourcePorts []PortElement `json:"source_ports,omitempty" yaml:"source_ports,omitempty" mapstructure:"source_ports,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ALGTypeServiceEntryAlg string

const ALGTypeServiceEntryAlgFTP ALGTypeServiceEntryAlg = "FTP"
const ALGTypeServiceEntryAlgMSRPCTCP ALGTypeServiceEntryAlg = "MS_RPC_TCP"
const ALGTypeServiceEntryAlgMSRPCUDP ALGTypeServiceEntryAlg = "MS_RPC_UDP"
const ALGTypeServiceEntryAlgNBDGBROADCAST ALGTypeServiceEntryAlg = "NBDG_BROADCAST"
const ALGTypeServiceEntryAlgNBNSBROADCAST ALGTypeServiceEntryAlg = "NBNS_BROADCAST"
const ALGTypeServiceEntryAlgORACLETNS ALGTypeServiceEntryAlg = "ORACLE_TNS"
const ALGTypeServiceEntryAlgSUNRPCTCP ALGTypeServiceEntryAlg = "SUN_RPC_TCP"
const ALGTypeServiceEntryAlgSUNRPCUDP ALGTypeServiceEntryAlg = "SUN_RPC_UDP"
const ALGTypeServiceEntryAlgTFTP ALGTypeServiceEntryAlg = "TFTP"

var enumValues_ALGTypeServiceEntryAlg = []interface{}{
	"ORACLE_TNS",
	"FTP",
	"SUN_RPC_TCP",
	"SUN_RPC_UDP",
	"MS_RPC_TCP",
	"MS_RPC_UDP",
	"NBNS_BROADCAST",
	"NBDG_BROADCAST",
	"TFTP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ALGTypeServiceEntryAlg) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ALGTypeServiceEntryAlg {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ALGTypeServiceEntryAlg, v)
	}
	*j = ALGTypeServiceEntryAlg(v)
	return nil
}

type ALGTypeServiceEntryResourceType string

const ALGTypeServiceEntryResourceTypeALGTypeServiceEntry ALGTypeServiceEntryResourceType = "ALGTypeServiceEntry"
const ALGTypeServiceEntryResourceTypeEtherTypeServiceEntry ALGTypeServiceEntryResourceType = "EtherTypeServiceEntry"
const ALGTypeServiceEntryResourceTypeICMPTypeServiceEntry ALGTypeServiceEntryResourceType = "ICMPTypeServiceEntry"
const ALGTypeServiceEntryResourceTypeIGMPTypeServiceEntry ALGTypeServiceEntryResourceType = "IGMPTypeServiceEntry"
const ALGTypeServiceEntryResourceTypeIPProtocolServiceEntry ALGTypeServiceEntryResourceType = "IPProtocolServiceEntry"
const ALGTypeServiceEntryResourceTypeL4PortSetServiceEntry ALGTypeServiceEntryResourceType = "L4PortSetServiceEntry"
const ALGTypeServiceEntryResourceTypeNestedServiceServiceEntry ALGTypeServiceEntryResourceType = "NestedServiceServiceEntry"

var enumValues_ALGTypeServiceEntryResourceType = []interface{}{
	"IPProtocolServiceEntry",
	"IGMPTypeServiceEntry",
	"ICMPTypeServiceEntry",
	"ALGTypeServiceEntry",
	"L4PortSetServiceEntry",
	"EtherTypeServiceEntry",
	"NestedServiceServiceEntry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ALGTypeServiceEntryResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ALGTypeServiceEntryResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ALGTypeServiceEntryResourceType, v)
	}
	*j = ALGTypeServiceEntryResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ALGTypeServiceEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ALGTypeServiceEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DestinationPorts != nil && len(plain.DestinationPorts) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "destination_ports", 1)
	}
	if len(plain.DestinationPorts) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "destination_ports", 1)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.SourcePorts) > 15 {
		return fmt.Errorf("field %s length: must be <= %d", "source_ports", 15)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = ALGTypeServiceEntry(plain)
	return nil
}

// Allows more granular policies for application workloads
type ApplicationConnectivityStrategy struct {
	// App connectivity strategies
	ApplicationConnectivityStrategy *ApplicationConnectivityStrategyApplicationConnectivityStrategy `json:"application_connectivity_strategy,omitempty" yaml:"application_connectivity_strategy,omitempty" mapstructure:"application_connectivity_strategy,omitempty"`

	// Based on the value of the app connectivity strategy, a default rule is created
	// for the security policy. The rule id is internally assigned by the system for
	// this default rule.
	DefaultApplicationRuleId *int `json:"default_application_rule_id,omitempty" yaml:"default_application_rule_id,omitempty" mapstructure:"default_application_rule_id,omitempty"`

	// Flag to enable packet logging. Default is deactivated.
	LoggingEnabled bool `json:"logging_enabled,omitempty" yaml:"logging_enabled,omitempty" mapstructure:"logging_enabled,omitempty"`
}

type ApplicationConnectivityStrategyApplicationConnectivityStrategy string

const ApplicationConnectivityStrategyApplicationConnectivityStrategyALLOWEGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "ALLOW_EGRESS"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyALLOWINGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "ALLOW_INGRESS"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyALLOWINTRA ApplicationConnectivityStrategyApplicationConnectivityStrategy = "ALLOW_INTRA"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyDROPEGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "DROP_EGRESS"
const ApplicationConnectivityStrategyApplicationConnectivityStrategyDROPINGRESS ApplicationConnectivityStrategyApplicationConnectivityStrategy = "DROP_INGRESS"

var enumValues_ApplicationConnectivityStrategyApplicationConnectivityStrategy = []interface{}{
	"ALLOW_INTRA",
	"ALLOW_EGRESS",
	"ALLOW_INGRESS",
	"DROP_INGRESS",
	"DROP_EGRESS",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApplicationConnectivityStrategyApplicationConnectivityStrategy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ApplicationConnectivityStrategyApplicationConnectivityStrategy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ApplicationConnectivityStrategyApplicationConnectivityStrategy, v)
	}
	*j = ApplicationConnectivityStrategyApplicationConnectivityStrategy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ApplicationConnectivityStrategy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ApplicationConnectivityStrategy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["logging_enabled"]; !ok || v == nil {
		plain.LoggingEnabled = false
	}
	*j = ApplicationConnectivityStrategy(plain)
	return nil
}

type ArpHeader struct {
	// DstIp corresponds to the JSON schema field "dst_ip".
	DstIp *IPAddress `json:"dst_ip,omitempty" yaml:"dst_ip,omitempty" mapstructure:"dst_ip,omitempty"`

	// This field specifies the nature of the Arp message being sent.
	OpCode ArpHeaderOpCode `json:"op_code,omitempty" yaml:"op_code,omitempty" mapstructure:"op_code,omitempty"`

	// This field specifies the IP address of the sender. If omitted, the src_ip is
	// set to 0.0.0.0.
	SrcIp *IPAddress `json:"src_ip,omitempty" yaml:"src_ip,omitempty" mapstructure:"src_ip,omitempty"`
}

type ArpHeaderOpCode string

const ArpHeaderOpCodeARPREPLY ArpHeaderOpCode = "ARP_REPLY"
const ArpHeaderOpCodeARPREQUEST ArpHeaderOpCode = "ARP_REQUEST"

var enumValues_ArpHeaderOpCode = []interface{}{
	"ARP_REQUEST",
	"ARP_REPLY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArpHeaderOpCode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ArpHeaderOpCode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ArpHeaderOpCode, v)
	}
	*j = ArpHeaderOpCode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ArpHeader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ArpHeader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["op_code"]; !ok || v == nil {
		plain.OpCode = "ARP_REQUEST"
	}
	*j = ArpHeader(plain)
	return nil
}

// The Attached interface is only effective for the segment port on Bare metal
// server.
type AttachedInterfaceEntry struct {
	// AppIntfName corresponds to the JSON schema field "app_intf_name".
	AppIntfName *string `json:"app_intf_name,omitempty" yaml:"app_intf_name,omitempty" mapstructure:"app_intf_name,omitempty"`

	// DefaultGateway corresponds to the JSON schema field "default_gateway".
	DefaultGateway *IPAddress `json:"default_gateway,omitempty" yaml:"default_gateway,omitempty" mapstructure:"default_gateway,omitempty"`

	// IP configuration on migrate_intf will migrate to app_intf_name. It is used for
	// Management and Application sharing the same IP.
	MigrateIntf *string `json:"migrate_intf,omitempty" yaml:"migrate_intf,omitempty" mapstructure:"migrate_intf,omitempty"`

	// RoutingTable corresponds to the JSON schema field "routing_table".
	RoutingTable []string `json:"routing_table,omitempty" yaml:"routing_table,omitempty" mapstructure:"routing_table,omitempty"`
}

type BinaryPacketData struct {
	// If the requested frame_size is too small (given the payload and traceflow
	// metadata requirement of 16 bytes), the traceflow request will fail with an
	// appropriate message.  The frame will be zero padded to the requested size.
	FrameSize int `json:"frame_size,omitempty" yaml:"frame_size,omitempty" mapstructure:"frame_size,omitempty"`

	// Up to 1000 bytes of payload may be supplied (with a base64-encoded length of
	// 1336 bytes.) Additional bytes of traceflow metadata will be appended to the
	// payload. The payload must contain all headers (Ethernet, IP, etc). Note that
	// VLAN is not supported in the logical space. Hence, payload must not contain
	// 802.1Q headers.
	Payload *string `json:"payload,omitempty" yaml:"payload,omitempty" mapstructure:"payload,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType BinaryPacketDataResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// When this flag is set, traceflow packet will have its destination overwritten
	// as the gateway address of the logical router to which the source logical switch
	// is connected. More specifically: - For ARP request, the target IP will be
	// overwritten as gateway IP if the target   IP is not in the same subnet of
	// gateway. - For ARP response, the target IP and destination MAC will be
	// overwritten as   gateway IP/MAC respectively, if the target IP is not in the
	// same subnet of gateway. - For IP packet, the destination MAC will be
	// overwritten as gateway MAC. However, this flag will not be effective when
	// injecting the traceflow packet to a VLAN backed port. This is because the
	// gateway in this case is a physical gateway that is outside the scope of NSX.
	// Therefore, users need to manually populate the gateway MAC address. If the user
	// still sets this flag in this case, a validation error will be thrown. The
	// scenario where a user injects a packet with a VLAN tag into a parent port is
	// referred to as the traceflow container case. Please note that the value of
	// `routed` depends on the connected network of the child segment rather than the
	// connected network of segment of the parent port in this case. Here is the
	// explanation: The parent port in this context is the port on a segment which is
	// referred to by a SegmentConnectionBindingMap. The bound segment of the
	// SegmentConnectionBindingMap is the child segment. The user-crafted traceflow
	// packet will be directly forwarded to the corresponding child segment of the
	// parent port without interacting with any layer 2 forwarding/layer 3 routing in
	// this scenario. The crafted packet will follow the forwarding/routing polices of
	// the child segment's connected network. For example, if a user injects a crafted
	// packet to port_p, and the segment (seg_p) of port_p is referred to by the
	// binding map m1, where m1 is bound to segment seg_c, and the destination port
	// (port_d) of the packet is the VM vNIC connected to seg_p. Although port_p and
	// port_d are on the same segment, the 'routed' value should be set to true if the
	// user expects the crafted packet to be correctly delivered to the destination.
	// This is because the child segments seg_c and seg_d are on different segments
	// and require router interaction to communicate.
	Routed *bool `json:"routed,omitempty" yaml:"routed,omitempty" mapstructure:"routed,omitempty"`

	// This type takes effect only for IP packet.
	TransportType BinaryPacketDataTransportType `json:"transport_type,omitempty" yaml:"transport_type,omitempty" mapstructure:"transport_type,omitempty"`
}

type BinaryPacketDataResourceType string

const BinaryPacketDataResourceTypeBinaryPacketData BinaryPacketDataResourceType = "BinaryPacketData"
const BinaryPacketDataResourceTypeFieldsPacketData BinaryPacketDataResourceType = "FieldsPacketData"

var enumValues_BinaryPacketDataResourceType = []interface{}{
	"BinaryPacketData",
	"FieldsPacketData",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BinaryPacketDataResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BinaryPacketDataResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BinaryPacketDataResourceType, v)
	}
	*j = BinaryPacketDataResourceType(v)
	return nil
}

type BinaryPacketDataTransportType string

const BinaryPacketDataTransportTypeBROADCAST BinaryPacketDataTransportType = "BROADCAST"
const BinaryPacketDataTransportTypeMULTICAST BinaryPacketDataTransportType = "MULTICAST"
const BinaryPacketDataTransportTypeUNICAST BinaryPacketDataTransportType = "UNICAST"
const BinaryPacketDataTransportTypeUNKNOWN BinaryPacketDataTransportType = "UNKNOWN"

var enumValues_BinaryPacketDataTransportType = []interface{}{
	"BROADCAST",
	"UNICAST",
	"MULTICAST",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BinaryPacketDataTransportType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_BinaryPacketDataTransportType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_BinaryPacketDataTransportType, v)
	}
	*j = BinaryPacketDataTransportType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BinaryPacketData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain BinaryPacketData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["frame_size"]; !ok || v == nil {
		plain.FrameSize = 128.0
	}
	if plain.Payload != nil && len(*plain.Payload) > 1336 {
		return fmt.Errorf("field %s length: must be <= %d", "payload", 1336)
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "FieldsPacketData"
	}
	if v, ok := raw["transport_type"]; !ok || v == nil {
		plain.TransportType = "UNICAST"
	}
	*j = BinaryPacketData(plain)
	return nil
}

// configuration parameters for Bridge Profile
type BridgeProfileConfig struct {
	// Same bridge profile can be configured on different segments. Each bridge
	// profile on a segment must unique.
	BridgeProfilePath *string `json:"bridge_profile_path,omitempty" yaml:"bridge_profile_path,omitempty" mapstructure:"bridge_profile_path,omitempty"`

	// The name of the switching uplink teaming policy for the bridge endpoint. This
	// name corresponds to one of the switching uplink teaming policy names listed in
	// the VLAN transport zone specified by the property "vlan_transport_zone_path".
	// When this property is not specified, the default teaming policy of the
	// host-switch is assigned. Do not set a value when the 'bridge_profile_path' is
	// the path of L2DistributedBridgeEndpointProfile.
	UplinkTeamingPolicyName *string `json:"uplink_teaming_policy_name,omitempty" yaml:"uplink_teaming_policy_name,omitempty" mapstructure:"uplink_teaming_policy_name,omitempty"`

	// VLAN specification for bridge endpoint. Either VLAN Id or VLAN ranges can be
	// specified. Not both.
	VlanIds []string `json:"vlan_ids,omitempty" yaml:"vlan_ids,omitempty" mapstructure:"vlan_ids,omitempty"`

	// The path of the VLAN transport zone that represents the underlay L2 zone in
	// which the VLANs will be bridged to overlay segments. A unique VLAN transport
	// zone should be assigned to each underlay L2 zone when needed for bridging. If
	// two VLANs in two underlay L2 zones are combined together as one L2
	// broadcast-domain by certain L2 extension, the two underlay L2 zones still
	// should have two different VLAN transport zones assigned to them. It is optional
	// for distributed-bridging but required for other bridging modes. If it is not
	// given, the distributed bridge will span all ESX transport nodes in the overlay
	// transport zone of the segment that contains this profile.
	VlanTransportZonePath *string `json:"vlan_transport_zone_path,omitempty" yaml:"vlan_transport_zone_path,omitempty" mapstructure:"vlan_transport_zone_path,omitempty"`
}

// Represents an object on the desired state
type ChildPolicyConfigResource struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// MarkForOverride corresponds to the JSON schema field "mark_for_override".
	MarkForOverride bool `json:"mark_for_override,omitempty" yaml:"mark_for_override,omitempty" mapstructure:"mark_for_override,omitempty"`

	// If this field is set to true, delete operation is triggered on the intent tree.
	// This resource along with its all children in intent tree will be deleted. This
	// is a cascade delete and should only be used if intent object along with its all
	// children are to be deleted. This does not support deletion of single non-leaf
	// node within the tree and should be used carefully.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// RequestParameter corresponds to the JSON schema field "request_parameter".
	RequestParameter *PolicyRequestParameter `json:"request_parameter,omitempty" yaml:"request_parameter,omitempty" mapstructure:"request_parameter,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ChildPolicyConfigResource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ChildPolicyConfigResource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["mark_for_override"]; !ok || v == nil {
		plain.MarkForOverride = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = ChildPolicyConfigResource(plain)
	return nil
}

// Represents the leaf level condition. Evaluation of the condition expression will
// be case insensitive.
type Condition struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// List of members to be excluded from the condition. This field is applicable
	// only for condition representing the list of malicious IPs. Only
	// IPAddressExpression and PathExpression are supported. The PathExpression should
	// have paths of Groups that of the group_type IPAddress. Multiple PathExpressions
	// are not supported here.
	Exclude *ExcludedMembersList `json:"exclude,omitempty" yaml:"exclude,omitempty" mapstructure:"exclude,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Key corresponds to the JSON schema field "key".
	Key *ConditionKey `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// For global groups (groups created from Global Manager), the supported Member
	// Types are - VirtualMachine, Segment, SegmentPort, Group, DVPG and DVPort. For
	// local groups (groups created on the local policy manager), the supported member
	// types are IPSet, VirtualMachine, LogicalPort, LogicalSwitch, Segment,
	// SegmentPort, Pod, Service, Namespace, TransportNode, Group, DVPG, DVPort,
	// KubernetesCluster, KubernetesNamespace, AntreaEgress, AntreaIPPool,
	// KubernetesIngress, KubernetesGateway, KubernetesService and KubernetesNode.
	MemberType *ConditionMemberType `json:"member_type,omitempty" yaml:"member_type,omitempty" mapstructure:"member_type,omitempty"`

	// Operator is made non-mandatory to support Segment and SegmentPort tag based
	// expression. To evaluate expression for other types, operator value should be
	// provided.
	Operator *ConditionOperator `json:"operator,omitempty" yaml:"operator,omitempty" mapstructure:"operator,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ConditionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Default operator when not specified explicitly would be considered as EQUALS.
	// If value for Condition is empty, then condition will not be evaluated. For
	// example, Condition with key as Tag and value as "|tag" would be evaluated for
	// tag value not for empty scope value.
	ScopeOperator *ConditionScopeOperator `json:"scope_operator,omitempty" yaml:"scope_operator,omitempty" mapstructure:"scope_operator,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type ConditionKey string

const ConditionKeyALL ConditionKey = "ALL"
const ConditionKeyComputerName ConditionKey = "ComputerName"
const ConditionKeyGroupType ConditionKey = "GroupType"
const ConditionKeyIPAddress ConditionKey = "IPAddress"
const ConditionKeyName ConditionKey = "Name"
const ConditionKeyNodeType ConditionKey = "NodeType"
const ConditionKeyOSName ConditionKey = "OSName"
const ConditionKeyPodCidr ConditionKey = "PodCidr"
const ConditionKeyTag ConditionKey = "Tag"

var enumValues_ConditionKey = []interface{}{
	"Tag",
	"Name",
	"OSName",
	"ComputerName",
	"NodeType",
	"GroupType",
	"ALL",
	"IPAddress",
	"PodCidr",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionKey) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionKey {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionKey, v)
	}
	*j = ConditionKey(v)
	return nil
}

type ConditionMemberType string

const ConditionMemberTypeAntreaEgress ConditionMemberType = "AntreaEgress"
const ConditionMemberTypeAntreaIPPool ConditionMemberType = "AntreaIPPool"
const ConditionMemberTypeDVPG ConditionMemberType = "DVPG"
const ConditionMemberTypeDVPort ConditionMemberType = "DVPort"
const ConditionMemberTypeGroup ConditionMemberType = "Group"
const ConditionMemberTypeIPAddress ConditionMemberType = "IPAddress"
const ConditionMemberTypeIPSet ConditionMemberType = "IPSet"
const ConditionMemberTypeKubernetesCluster ConditionMemberType = "KubernetesCluster"
const ConditionMemberTypeKubernetesGateway ConditionMemberType = "KubernetesGateway"
const ConditionMemberTypeKubernetesIngress ConditionMemberType = "KubernetesIngress"
const ConditionMemberTypeKubernetesNamespace ConditionMemberType = "KubernetesNamespace"
const ConditionMemberTypeKubernetesNode ConditionMemberType = "KubernetesNode"
const ConditionMemberTypeKubernetesService ConditionMemberType = "KubernetesService"
const ConditionMemberTypeLogicalPort ConditionMemberType = "LogicalPort"
const ConditionMemberTypeLogicalSwitch ConditionMemberType = "LogicalSwitch"
const ConditionMemberTypeNamespace ConditionMemberType = "Namespace"
const ConditionMemberTypePod ConditionMemberType = "Pod"
const ConditionMemberTypeSegment ConditionMemberType = "Segment"
const ConditionMemberTypeSegmentPort ConditionMemberType = "SegmentPort"
const ConditionMemberTypeService ConditionMemberType = "Service"
const ConditionMemberTypeTransportNode ConditionMemberType = "TransportNode"
const ConditionMemberTypeVirtualMachine ConditionMemberType = "VirtualMachine"
const ConditionMemberTypeVpcSubnet ConditionMemberType = "VpcSubnet"
const ConditionMemberTypeVpcSubnetPort ConditionMemberType = "VpcSubnetPort"

var enumValues_ConditionMemberType = []interface{}{
	"IPSet",
	"VirtualMachine",
	"LogicalPort",
	"LogicalSwitch",
	"Segment",
	"SegmentPort",
	"Pod",
	"Service",
	"Namespace",
	"TransportNode",
	"Group",
	"DVPG",
	"DVPort",
	"IPAddress",
	"VpcSubnet",
	"KubernetesCluster",
	"KubernetesNamespace",
	"AntreaEgress",
	"AntreaIPPool",
	"KubernetesIngress",
	"KubernetesGateway",
	"KubernetesService",
	"KubernetesNode",
	"VpcSubnetPort",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionMemberType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionMemberType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionMemberType, v)
	}
	*j = ConditionMemberType(v)
	return nil
}

type ConditionOperator string

const ConditionOperatorCONTAINS ConditionOperator = "CONTAINS"
const ConditionOperatorENDSWITH ConditionOperator = "ENDSWITH"
const ConditionOperatorEQUALS ConditionOperator = "EQUALS"
const ConditionOperatorIN ConditionOperator = "IN"
const ConditionOperatorMATCHES ConditionOperator = "MATCHES"
const ConditionOperatorNOTEQUALS ConditionOperator = "NOTEQUALS"
const ConditionOperatorNOTIN ConditionOperator = "NOTIN"
const ConditionOperatorSTARTSWITH ConditionOperator = "STARTSWITH"

var enumValues_ConditionOperator = []interface{}{
	"EQUALS",
	"CONTAINS",
	"STARTSWITH",
	"ENDSWITH",
	"NOTEQUALS",
	"NOTIN",
	"MATCHES",
	"IN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionOperator, v)
	}
	*j = ConditionOperator(v)
	return nil
}

type ConditionResourceType string

const ConditionResourceTypeCondition ConditionResourceType = "Condition"
const ConditionResourceTypeConjunctionOperator ConditionResourceType = "ConjunctionOperator"
const ConditionResourceTypeExternalIDExpression ConditionResourceType = "ExternalIDExpression"
const ConditionResourceTypeIPAddressExpression ConditionResourceType = "IPAddressExpression"
const ConditionResourceTypeIdentityGroupExpression ConditionResourceType = "IdentityGroupExpression"
const ConditionResourceTypeMACAddressExpression ConditionResourceType = "MACAddressExpression"
const ConditionResourceTypeNestedExpression ConditionResourceType = "NestedExpression"
const ConditionResourceTypePathExpression ConditionResourceType = "PathExpression"

var enumValues_ConditionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionResourceType, v)
	}
	*j = ConditionResourceType(v)
	return nil
}

type ConditionScopeOperator string

const ConditionScopeOperatorEQUALS ConditionScopeOperator = "EQUALS"
const ConditionScopeOperatorNOTEQUALS ConditionScopeOperator = "NOTEQUALS"

var enumValues_ConditionScopeOperator = []interface{}{
	"EQUALS",
	"NOTEQUALS",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConditionScopeOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConditionScopeOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConditionScopeOperator, v)
	}
	*j = ConditionScopeOperator(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Condition) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Condition
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	if plain.Value != nil && len(*plain.Value) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "value", 1)
	}
	*j = Condition(plain)
	return nil
}

type ConfigurationStateElement struct {
	// FailureCode corresponds to the JSON schema field "failure_code".
	FailureCode *int `json:"failure_code,omitempty" yaml:"failure_code,omitempty" mapstructure:"failure_code,omitempty"`

	// FailureMessage corresponds to the JSON schema field "failure_message".
	FailureMessage *string `json:"failure_message,omitempty" yaml:"failure_message,omitempty" mapstructure:"failure_message,omitempty"`

	// State corresponds to the JSON schema field "state".
	State *ConfigurationStateElementState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// SubSystemAddress corresponds to the JSON schema field "sub_system_address".
	SubSystemAddress *string `json:"sub_system_address,omitempty" yaml:"sub_system_address,omitempty" mapstructure:"sub_system_address,omitempty"`

	// SubSystemId corresponds to the JSON schema field "sub_system_id".
	SubSystemId *string `json:"sub_system_id,omitempty" yaml:"sub_system_id,omitempty" mapstructure:"sub_system_id,omitempty"`

	// SubSystemName corresponds to the JSON schema field "sub_system_name".
	SubSystemName *string `json:"sub_system_name,omitempty" yaml:"sub_system_name,omitempty" mapstructure:"sub_system_name,omitempty"`

	// SubSystemType corresponds to the JSON schema field "sub_system_type".
	SubSystemType *string `json:"sub_system_type,omitempty" yaml:"sub_system_type,omitempty" mapstructure:"sub_system_type,omitempty"`
}

type ConfigurationStateElementState string

const ConfigurationStateElementStateADVANCEDCONFIGEDITFAILED ConfigurationStateElementState = "ADVANCED_CONFIG_EDIT_FAILED"
const ConfigurationStateElementStateADVANCEDCONFIGEDITPENDING ConfigurationStateElementState = "ADVANCED_CONFIG_EDIT_PENDING"
const ConfigurationStateElementStateAPPLIANCEINTERNALERROR ConfigurationStateElementState = "APPLIANCE_INTERNAL_ERROR"
const ConfigurationStateElementStateCOMPUTEMANAGERNOTFOUND ConfigurationStateElementState = "COMPUTE_MANAGER_NOT_FOUND"
const ConfigurationStateElementStateCONFIGUREUPTONVMFAILED ConfigurationStateElementState = "CONFIGURE_UPT_ON_VM_FAILED"
const ConfigurationStateElementStateDATAPATHCONFIGURATIONEDITFAILED ConfigurationStateElementState = "DATAPATH_CONFIGURATION_EDIT_FAILED"
const ConfigurationStateElementStateDELETEFAILEDFORDIFFERENTMOREFID ConfigurationStateElementState = "DELETE_FAILED_FOR_DIFFERENT_MOREF_ID"
const ConfigurationStateElementStateDELETEFAILEDFORNONLCMEDGE ConfigurationStateElementState = "DELETE_FAILED_FOR_NON_LCM_EDGE"
const ConfigurationStateElementStateDELETEFAILEDONVMNOTFOUND ConfigurationStateElementState = "DELETE_FAILED_ON_VM_NOT_FOUND"
const ConfigurationStateElementStateDELETEINPROGRESS ConfigurationStateElementState = "DELETE_IN_PROGRESS"
const ConfigurationStateElementStateDELETEVMINREDEPLOYFAILED ConfigurationStateElementState = "DELETE_VM_IN_REDEPLOY_FAILED"
const ConfigurationStateElementStateDEPLOYVMINREDEPLOYFAILED ConfigurationStateElementState = "DEPLOY_VM_IN_REDEPLOY_FAILED"
const ConfigurationStateElementStateDUPLICATEPNICSINTEAMINGSWITHMULTIPLEUPLINKSANDFAILOVERORDER ConfigurationStateElementState = "DUPLICATE_PNICS_IN_TEAMINGS_WITH_MULTIPLE_UPLINKS_AND_FAILOVER_ORDER"
const ConfigurationStateElementStateDUPLICATEVLANSSHARINGSAMEPNIC ConfigurationStateElementState = "DUPLICATE_VLANS_SHARING_SAME_PNIC"
const ConfigurationStateElementStateDUPLICATEVLANSSHARINGSAMEPNICMULTIPLEUPLINKSINNAMEDTEAMINGNOTSUPPORTEDIFUPLINKINDEFAULTTEAMING ConfigurationStateElementState = "DUPLICATE_VLANS_SHARING_SAME_PNICMULTIPLE_UPLINKS_IN_NAMED_TEAMING_NOT_SUPPORTED_IF_UPLINK_IN_DEFAULT_TEAMING"
const ConfigurationStateElementStateEDGECONFIGERROR ConfigurationStateElementState = "EDGE_CONFIG_ERROR"
const ConfigurationStateElementStateEDGEHARDWARENOTSUPPORTED ConfigurationStateElementState = "EDGE_HARDWARE_NOT_SUPPORTED"
const ConfigurationStateElementStateEDGENODESETTINGSANDVSPHERESETTINGSARECHANGEDRESOLVE ConfigurationStateElementState = "EDGE_NODE_SETTINGS_AND_VSPHERE_SETTINGS_ARE_CHANGED_RESOLVE"
const ConfigurationStateElementStateEDGENODESETTINGSMISMATCHRESOLVE ConfigurationStateElementState = "EDGE_NODE_SETTINGS_MISMATCH_RESOLVE"
const ConfigurationStateElementStateEDGENODEVERSIONNOTSUPPORTED ConfigurationStateElementState = "EDGE_NODE_VERSION_NOT_SUPPORTED"
const ConfigurationStateElementStateEDGEVMVSPHERESETTINGSMISMATCHRESOLVE ConfigurationStateElementState = "EDGE_VM_VSPHERE_SETTINGS_MISMATCH_RESOLVE"
const ConfigurationStateElementStateEDGEVSPHERELOCATIONMISMATCHRESOLVE ConfigurationStateElementState = "EDGE_VSPHERE_LOCATION_MISMATCH_RESOLVE"
const ConfigurationStateElementStateERRORINDISABLEMAINTENANCEMODE ConfigurationStateElementState = "ERROR_IN_DISABLE_MAINTENANCE_MODE"
const ConfigurationStateElementStateERRORINENABLEMAINTENANCEMODE ConfigurationStateElementState = "ERROR_IN_ENABLE_MAINTENANCE_MODE"
const ConfigurationStateElementStateError ConfigurationStateElementState = "error"
const ConfigurationStateElementStateFailed ConfigurationStateElementState = "failed"
const ConfigurationStateElementStateHOSTSWITCHPROFILENOTFOUND ConfigurationStateElementState = "HOSTSWITCH_PROFILE_NOT_FOUND"
const ConfigurationStateElementStateINSUFFICIENTRESOURCESINEDGENODEFORSERVICE ConfigurationStateElementState = "INSUFFICIENT_RESOURCES_IN_EDGE_NODE_FOR_SERVICE"
const ConfigurationStateElementStateINVALIDPNICDEVICENAME ConfigurationStateElementState = "INVALID_PNIC_DEVICE_NAME"
const ConfigurationStateElementStateInProgress ConfigurationStateElementState = "in_progress"
const ConfigurationStateElementStateInSync ConfigurationStateElementState = "in_sync"
const ConfigurationStateElementStateLACPNOTSUPPORTEDFOREDGEVM ConfigurationStateElementState = "LACP_NOT_SUPPORTED_FOR_EDGE_VM"
const ConfigurationStateElementStateLBSRCIDNOTSUPPORTEDFOREDGEVM ConfigurationStateElementState = "LBSRCID_NOT_SUPPORTED_FOR_EDGE_VM"
const ConfigurationStateElementStateLLDPSENDENABLEDNOTSUPPORTED ConfigurationStateElementState = "LLDP_SEND_ENABLED_NOT_SUPPORTED"
const ConfigurationStateElementStateLOGICALSWITCHNAMEDTEAMINGHASNOPNICBACKING ConfigurationStateElementState = "LOGICAL_SWITCH_NAMED_TEAMING_HAS_NO_PNIC_BACKING"
const ConfigurationStateElementStateMAINTENANCEMODEENABLED ConfigurationStateElementState = "MAINTENANCE_MODE_ENABLED"
const ConfigurationStateElementStateMPADISCONNECTED ConfigurationStateElementState = "MPA_DISCONNECTED"
const ConfigurationStateElementStateMULTIPLEACTIVEUPLINKSNOTSUPPORTEDFOREDGE ConfigurationStateElementState = "MULTIPLE_ACTIVE_UPLINKS_NOT_SUPPORTED_FOR_EDGE"
const ConfigurationStateElementStateMULTIPLEOVERLAYTZSNOTSUPPORTED ConfigurationStateElementState = "MULTIPLE_OVERLAY_TZS_NOT_SUPPORTED"
const ConfigurationStateElementStateMULTIPLEUPLINKSINNAMEDTEAMINGNOTSUPPORTEDIFUPLINKINDEFAULTTEAMING ConfigurationStateElementState = "MULTIPLE_UPLINKS_IN_NAMED_TEAMING_NOT_SUPPORTED_IF_UPLINK_IN_DEFAULT_TEAMING"
const ConfigurationStateElementStateNODENOTREADY ConfigurationStateElementState = "NODE_NOT_READY"
const ConfigurationStateElementStateNODEREADY ConfigurationStateElementState = "NODE_READY"
const ConfigurationStateElementStateNOPNICPREPAREDINEDGE ConfigurationStateElementState = "NO_PNIC_PREPARED_IN_EDGE"
const ConfigurationStateElementStateNOPNICSPECIFIEDINTN ConfigurationStateElementState = "NO_PNIC_SPECIFIED_IN_TN"
const ConfigurationStateElementStateNOTAVAILABLE ConfigurationStateElementState = "NOT_AVAILABLE"
const ConfigurationStateElementStateOrphaned ConfigurationStateElementState = "orphaned"
const ConfigurationStateElementStatePartialSuccess ConfigurationStateElementState = "partial_success"
const ConfigurationStateElementStatePending ConfigurationStateElementState = "pending"
const ConfigurationStateElementStateREDEPLOYACTIVITYFAILED ConfigurationStateElementState = "REDEPLOY_ACTIVITY_FAILED"
const ConfigurationStateElementStateREDEPLOYACTIVITYINPROGRESS ConfigurationStateElementState = "REDEPLOY_ACTIVITY_IN_PROGRESS"
const ConfigurationStateElementStateREDEPLOYACTIVITYSCHEDULED ConfigurationStateElementState = "REDEPLOY_ACTIVITY_SCHEDULED"
const ConfigurationStateElementStateREDEPLOYACTIVITYSUCCESSFUL ConfigurationStateElementState = "REDEPLOY_ACTIVITY_SUCCESSFUL"
const ConfigurationStateElementStateREDEPLOYEDVMREGISTRATIONPENDING ConfigurationStateElementState = "REDEPLOYED_VM_REGISTRATION_PENDING"
const ConfigurationStateElementStateREGISTRATIONFAILED ConfigurationStateElementState = "REGISTRATION_FAILED"
const ConfigurationStateElementStateREGISTRATIONPENDING ConfigurationStateElementState = "REGISTRATION_PENDING"
const ConfigurationStateElementStateREGISTRATIONTIMEDOUT ConfigurationStateElementState = "REGISTRATION_TIMEDOUT"
const ConfigurationStateElementStateREPLACEACTIVITYFAILED ConfigurationStateElementState = "REPLACE_ACTIVITY_FAILED"
const ConfigurationStateElementStateREPLACEACTIVITYINPROGRESS ConfigurationStateElementState = "REPLACE_ACTIVITY_IN_PROGRESS"
const ConfigurationStateElementStateREPLACEACTIVITYSCHEDULED ConfigurationStateElementState = "REPLACE_ACTIVITY_SCHEDULED"
const ConfigurationStateElementStateREPLACEACTIVITYSUCCESSFUL ConfigurationStateElementState = "REPLACE_ACTIVITY_SUCCESSFUL"
const ConfigurationStateElementStateREPLACEDRPCCLIENTOFTN ConfigurationStateElementState = "REPLACED_RPC_CLIENT_OF_TN"
const ConfigurationStateElementStateREPLACEFAILED ConfigurationStateElementState = "REPLACE_FAILED"
const ConfigurationStateElementStateRETRYINGREPLACE ConfigurationStateElementState = "RETRYING_REPLACE"
const ConfigurationStateElementStateSTANDBYUPLINKSNOTSUPPORTEDFOREDGEVM ConfigurationStateElementState = "STANDBY_UPLINKS_NOT_SUPPORTED_FOR_EDGE_VM"
const ConfigurationStateElementStateSuccess ConfigurationStateElementState = "success"
const ConfigurationStateElementStateTNOVERLAYTZINUSEBYEDGECLUSTER ConfigurationStateElementState = "TN_OVERLAY_TZ_IN_USE_BY_EDGE_CLUSTER"
const ConfigurationStateElementStateTRANSPORTNODECONFIGURATIONMISSING ConfigurationStateElementState = "TRANSPORT_NODE_CONFIGURATION_MISSING"
const ConfigurationStateElementStateTRANSPORTNODEREADY ConfigurationStateElementState = "TRANSPORT_NODE_READY"
const ConfigurationStateElementStateTRANSPORTNODESYNCPENDING ConfigurationStateElementState = "TRANSPORT_NODE_SYNC_PENDING"
const ConfigurationStateElementStateTZENDPOINTSNOTSPECIFIED ConfigurationStateElementState = "TZ_ENDPOINTS_NOT_SPECIFIED"
const ConfigurationStateElementStateUNABLETODELETEEDGENODEVMINTERNALERROR ConfigurationStateElementState = "UNABLE_TO_DELETE_EDGE_NODE_VM_INTERNAL_ERROR"
const ConfigurationStateElementStateUNSUPPORTEDDEFAULTTEAMINGPOLICY ConfigurationStateElementState = "UNSUPPORTED_DEFAULT_TEAMING_POLICY"
const ConfigurationStateElementStateUNSUPPORTEDHOSTSWITCHPROFILE ConfigurationStateElementState = "UNSUPPORTED_HOST_SWITCH_PROFILE"
const ConfigurationStateElementStateUNSUPPORTEDLACPLBALGOFORNODE ConfigurationStateElementState = "UNSUPPORTED_LACP_LB_ALGO_FOR_NODE"
const ConfigurationStateElementStateUNSUPPORTEDNAMEDTEAMINGPOLICY ConfigurationStateElementState = "UNSUPPORTED_NAMED_TEAMING_POLICY"
const ConfigurationStateElementStateUPLINKFROMTEAMINGPOLICYNOTMAPPED ConfigurationStateElementState = "UPLINK_FROM_TEAMING_POLICY_NOT_MAPPED"
const ConfigurationStateElementStateUPLINKHOSTSWITCHPROFILENOTSPECIFIED ConfigurationStateElementState = "UPLINK_HOST_SWITCH_PROFILE_NOT_SPECIFIED"
const ConfigurationStateElementStateUPTMODEREALIZATIONPOLLTIMEDOUT ConfigurationStateElementState = "UPT_MODE_REALIZATION_POLL_TIMED_OUT"
const ConfigurationStateElementStateUnknown ConfigurationStateElementState = "unknown"
const ConfigurationStateElementStateVMCONFIGDISCREPANCY ConfigurationStateElementState = "VM_CONFIG_DISCREPANCY"
const ConfigurationStateElementStateVMCONFIGEDITFAILED ConfigurationStateElementState = "VM_CONFIG_EDIT_FAILED"
const ConfigurationStateElementStateVMCONFIGEDITPENDING ConfigurationStateElementState = "VM_CONFIG_EDIT_PENDING"
const ConfigurationStateElementStateVMDEPLOYMENTFAILED ConfigurationStateElementState = "VM_DEPLOYMENT_FAILED"
const ConfigurationStateElementStateVMDEPLOYMENTINPROGRESS ConfigurationStateElementState = "VM_DEPLOYMENT_IN_PROGRESS"
const ConfigurationStateElementStateVMDEPLOYMENTQUEUED ConfigurationStateElementState = "VM_DEPLOYMENT_QUEUED"
const ConfigurationStateElementStateVMDEPLOYMENTRESTARTED ConfigurationStateElementState = "VM_DEPLOYMENT_RESTARTED"
const ConfigurationStateElementStateVMNETWORKEDITFAILED ConfigurationStateElementState = "VM_NETWORK_EDIT_FAILED"
const ConfigurationStateElementStateVMNETWORKEDITPENDING ConfigurationStateElementState = "VM_NETWORK_EDIT_PENDING"
const ConfigurationStateElementStateVMNODEREFRESHFAILED ConfigurationStateElementState = "VM_NODE_REFRESH_FAILED"
const ConfigurationStateElementStateVMPLACEMENTREFRESHFAILED ConfigurationStateElementState = "VM_PLACEMENT_REFRESH_FAILED"
const ConfigurationStateElementStateVMPOWEROFFFAILED ConfigurationStateElementState = "VM_POWER_OFF_FAILED"
const ConfigurationStateElementStateVMPOWEROFFINPROGRESS ConfigurationStateElementState = "VM_POWER_OFF_IN_PROGRESS"
const ConfigurationStateElementStateVMPOWERONFAILED ConfigurationStateElementState = "VM_POWER_ON_FAILED"
const ConfigurationStateElementStateVMPOWERONINPROGRESS ConfigurationStateElementState = "VM_POWER_ON_IN_PROGRESS"
const ConfigurationStateElementStateVMREDEPLOYFAILED ConfigurationStateElementState = "VM_REDEPLOY_FAILED"
const ConfigurationStateElementStateVMRENAMEFAILED ConfigurationStateElementState = "VM_RENAME_FAILED"
const ConfigurationStateElementStateVMRENAMEPENDING ConfigurationStateElementState = "VM_RENAME_PENDING"
const ConfigurationStateElementStateVMRESOURCERESERVATIONEDITPENDING ConfigurationStateElementState = "VM_RESOURCE_RESERVATION_EDIT_PENDING"
const ConfigurationStateElementStateVMRESOURCERESERVATIONFAILED ConfigurationStateElementState = "VM_RESOURCE_RESERVATION_FAILED"
const ConfigurationStateElementStateVMUNDEPLOYFAILED ConfigurationStateElementState = "VM_UNDEPLOY_FAILED"
const ConfigurationStateElementStateVMUNDEPLOYINPROGRESS ConfigurationStateElementState = "VM_UNDEPLOY_IN_PROGRESS"
const ConfigurationStateElementStateVMUNDEPLOYSUCCESSFUL ConfigurationStateElementState = "VM_UNDEPLOY_SUCCESSFUL"
const ConfigurationStateElementStateVMVERSIONISUPTINCOMPATIBLE ConfigurationStateElementState = "VM_VERSION_IS_UPT_INCOMPATIBLE"
const ConfigurationStateElementStateVTEPDHCPNOTSUPPORTED ConfigurationStateElementState = "VTEP_DHCP_NOT_SUPPORTED"

var enumValues_ConfigurationStateElementState = []interface{}{
	"in_progress",
	"success",
	"failed",
	"partial_success",
	"in_sync",
	"VM_DEPLOYMENT_FAILED",
	"VM_POWER_ON_FAILED",
	"VM_POWER_OFF_FAILED",
	"VM_UNDEPLOY_FAILED",
	"REPLACE_FAILED",
	"UPLINK_FROM_TEAMING_POLICY_NOT_MAPPED",
	"LOGICAL_SWITCH_NAMED_TEAMING_HAS_NO_PNIC_BACKING",
	"DELETE_VM_IN_REDEPLOY_FAILED",
	"DEPLOY_VM_IN_REDEPLOY_FAILED",
	"INSUFFICIENT_RESOURCES_IN_EDGE_NODE_FOR_SERVICE",
	"EDGE_CONFIG_ERROR",
	"REGISTRATION_FAILED",
	"TRANSPORT_NODE_CONFIGURATION_MISSING",
	"EDGE_HARDWARE_NOT_SUPPORTED",
	"MULTIPLE_OVERLAY_TZS_NOT_SUPPORTED",
	"TN_OVERLAY_TZ_IN_USE_BY_EDGE_CLUSTER",
	"TZ_ENDPOINTS_NOT_SPECIFIED",
	"NO_PNIC_PREPARED_IN_EDGE",
	"APPLIANCE_INTERNAL_ERROR",
	"VTEP_DHCP_NOT_SUPPORTED",
	"UNSUPPORTED_HOST_SWITCH_PROFILE",
	"UPLINK_HOST_SWITCH_PROFILE_NOT_SPECIFIED",
	"HOSTSWITCH_PROFILE_NOT_FOUND",
	"LLDP_SEND_ENABLED_NOT_SUPPORTED",
	"UNSUPPORTED_NAMED_TEAMING_POLICY",
	"LBSRCID_NOT_SUPPORTED_FOR_EDGE_VM",
	"LACP_NOT_SUPPORTED_FOR_EDGE_VM",
	"STANDBY_UPLINKS_NOT_SUPPORTED_FOR_EDGE_VM",
	"MULTIPLE_ACTIVE_UPLINKS_NOT_SUPPORTED_FOR_EDGE",
	"UNSUPPORTED_LACP_LB_ALGO_FOR_NODE",
	"EDGE_NODE_VERSION_NOT_SUPPORTED",
	"NO_PNIC_SPECIFIED_IN_TN",
	"INVALID_PNIC_DEVICE_NAME",
	"UNSUPPORTED_DEFAULT_TEAMING_POLICY",
	"MPA_DISCONNECTED",
	"VM_NETWORK_EDIT_PENDING",
	"VM_RENAME_PENDING",
	"VM_CONFIG_EDIT_PENDING",
	"VM_NETWORK_EDIT_FAILED",
	"VM_RENAME_FAILED",
	"VM_CONFIG_EDIT_FAILED",
	"VM_CONFIG_DISCREPANCY",
	"VM_NODE_REFRESH_FAILED",
	"VM_PLACEMENT_REFRESH_FAILED",
	"NOT_AVAILABLE",
	"REGISTRATION_TIMEDOUT",
	"ADVANCED_CONFIG_EDIT_FAILED",
	"VM_RESOURCE_RESERVATION_FAILED",
	"UPT_MODE_REALIZATION_POLL_TIMED_OUT",
	"DATAPATH_CONFIGURATION_EDIT_FAILED",
	"MAINTENANCE_MODE_ENABLED",
	"ERROR_IN_ENABLE_MAINTENANCE_MODE",
	"ERROR_IN_DISABLE_MAINTENANCE_MODE",
	"CONFIGURE_UPT_ON_VM_FAILED",
	"VM_VERSION_IS_UPT_INCOMPATIBLE",
	"pending",
	"orphaned",
	"unknown",
	"error",
	"VM_DEPLOYMENT_QUEUED",
	"VM_DEPLOYMENT_IN_PROGRESS",
	"VM_POWER_ON_IN_PROGRESS",
	"REGISTRATION_PENDING",
	"NODE_NOT_READY",
	"NODE_READY",
	"VM_POWER_OFF_IN_PROGRESS",
	"VM_UNDEPLOY_IN_PROGRESS",
	"VM_UNDEPLOY_SUCCESSFUL",
	"VM_DEPLOYMENT_RESTARTED",
	"TRANSPORT_NODE_SYNC_PENDING",
	"TRANSPORT_NODE_READY",
	"DUPLICATE_PNICS_IN_TEAMINGS_WITH_MULTIPLE_UPLINKS_AND_FAILOVER_ORDER",
	"DUPLICATE_VLANS_SHARING_SAME_PNICMULTIPLE_UPLINKS_IN_NAMED_TEAMING_NOT_SUPPORTED_IF_UPLINK_IN_DEFAULT_TEAMING",
	"EDGE_NODE_SETTINGS_MISMATCH_RESOLVE",
	"EDGE_VM_VSPHERE_SETTINGS_MISMATCH_RESOLVE",
	"EDGE_NODE_SETTINGS_AND_VSPHERE_SETTINGS_ARE_CHANGED_RESOLVE",
	"EDGE_VSPHERE_LOCATION_MISMATCH_RESOLVE",
	"COMPUTE_MANAGER_NOT_FOUND",
	"ADVANCED_CONFIG_EDIT_PENDING",
	"DELETE_FAILED_FOR_DIFFERENT_MOREF_ID",
	"DELETE_FAILED_FOR_NON_LCM_EDGE",
	"DELETE_FAILED_ON_VM_NOT_FOUND",
	"DELETE_IN_PROGRESS",
	"DUPLICATE_VLANS_SHARING_SAME_PNIC",
	"MULTIPLE_UPLINKS_IN_NAMED_TEAMING_NOT_SUPPORTED_IF_UPLINK_IN_DEFAULT_TEAMING",
	"REDEPLOY_ACTIVITY_FAILED",
	"REDEPLOY_ACTIVITY_IN_PROGRESS",
	"REDEPLOY_ACTIVITY_SCHEDULED",
	"REDEPLOY_ACTIVITY_SUCCESSFUL",
	"REPLACE_ACTIVITY_FAILED",
	"REPLACE_ACTIVITY_IN_PROGRESS",
	"REPLACE_ACTIVITY_SCHEDULED",
	"REPLACE_ACTIVITY_SUCCESSFUL",
	"REPLACED_RPC_CLIENT_OF_TN",
	"RETRYING_REPLACE",
	"UNABLE_TO_DELETE_EDGE_NODE_VM_INTERNAL_ERROR",
	"VM_REDEPLOY_FAILED",
	"VM_RESOURCE_RESERVATION_EDIT_PENDING",
	"REDEPLOYED_VM_REGISTRATION_PENDING",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConfigurationStateElementState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConfigurationStateElementState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConfigurationStateElementState, v)
	}
	*j = ConfigurationStateElementState(v)
	return nil
}

// Represents the operators AND or OR.
type ConjunctionOperator struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// ConjunctionOperator corresponds to the JSON schema field
	// "conjunction_operator".
	ConjunctionOperator *ConjunctionOperatorConjunctionOperator `json:"conjunction_operator,omitempty" yaml:"conjunction_operator,omitempty" mapstructure:"conjunction_operator,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ConjunctionOperatorResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ConjunctionOperatorConjunctionOperator string

const ConjunctionOperatorConjunctionOperatorAND ConjunctionOperatorConjunctionOperator = "AND"
const ConjunctionOperatorConjunctionOperatorOR ConjunctionOperatorConjunctionOperator = "OR"

var enumValues_ConjunctionOperatorConjunctionOperator = []interface{}{
	"OR",
	"AND",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConjunctionOperatorConjunctionOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConjunctionOperatorConjunctionOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConjunctionOperatorConjunctionOperator, v)
	}
	*j = ConjunctionOperatorConjunctionOperator(v)
	return nil
}

type ConjunctionOperatorResourceType string

const ConjunctionOperatorResourceTypeCondition ConjunctionOperatorResourceType = "Condition"
const ConjunctionOperatorResourceTypeConjunctionOperator ConjunctionOperatorResourceType = "ConjunctionOperator"
const ConjunctionOperatorResourceTypeExternalIDExpression ConjunctionOperatorResourceType = "ExternalIDExpression"
const ConjunctionOperatorResourceTypeIPAddressExpression ConjunctionOperatorResourceType = "IPAddressExpression"
const ConjunctionOperatorResourceTypeIdentityGroupExpression ConjunctionOperatorResourceType = "IdentityGroupExpression"
const ConjunctionOperatorResourceTypeMACAddressExpression ConjunctionOperatorResourceType = "MACAddressExpression"
const ConjunctionOperatorResourceTypeNestedExpression ConjunctionOperatorResourceType = "NestedExpression"
const ConjunctionOperatorResourceTypePathExpression ConjunctionOperatorResourceType = "PathExpression"

var enumValues_ConjunctionOperatorResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConjunctionOperatorResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ConjunctionOperatorResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ConjunctionOperatorResourceType, v)
	}
	*j = ConjunctionOperatorResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ConjunctionOperator) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ConjunctionOperator
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = ConjunctionOperator(plain)
	return nil
}

type DhcpHeader struct {
	// This is used to specify the general type of message. A client sending request
	// to a server uses an op code of BOOTREQUEST, while a server replying uses an op
	// code of BOOTREPLY.
	OpCode DhcpHeaderOpCode `json:"op_code,omitempty" yaml:"op_code,omitempty" mapstructure:"op_code,omitempty"`
}

type DhcpHeaderOpCode string

const DhcpHeaderOpCodeBOOTREPLY DhcpHeaderOpCode = "BOOTREPLY"
const DhcpHeaderOpCodeBOOTREQUEST DhcpHeaderOpCode = "BOOTREQUEST"

var enumValues_DhcpHeaderOpCode = []interface{}{
	"BOOTREQUEST",
	"BOOTREPLY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DhcpHeaderOpCode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DhcpHeaderOpCode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DhcpHeaderOpCode, v)
	}
	*j = DhcpHeaderOpCode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DhcpHeader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain DhcpHeader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["op_code"]; !ok || v == nil {
		plain.OpCode = "BOOTREQUEST"
	}
	*j = DhcpHeader(plain)
	return nil
}

type Dhcpv6Header struct {
	// This is used to specify the DHCP v6 message. To request the assignment of one
	// or more IPv6 addresses, a client first locates a DHCP server and then requests
	// the assignment of addresses and other configuration information from the
	// server. The client sends a Solicit message to the
	// All_DHCP_Relay_Agents_and_Servers address to find available DHCP servers. Any
	// server that can meet the client's requirements responds with an Advertise
	// message. The client then chooses one of the servers and sends a Request message
	// to the server asking for confirmed assignment of addresses and other
	// configuration information. The server responds with a Reply message that
	// contains the confirmed addresses and configuration. SOLICIT - A client sends a
	// Solicit message to locate servers. ADVERTISE - A server sends and Advertise
	// message to indicate that it is available. REQUEST - A client sends a Request
	// message to request configuration parameters. REPLY - A server sends a Reply
	// message containing assigned addresses and configuration parameters.
	MsgType Dhcpv6HeaderMsgType `json:"msg_type,omitempty" yaml:"msg_type,omitempty" mapstructure:"msg_type,omitempty"`
}

type Dhcpv6HeaderMsgType string

const Dhcpv6HeaderMsgTypeADVERTISE Dhcpv6HeaderMsgType = "ADVERTISE"
const Dhcpv6HeaderMsgTypeREPLY Dhcpv6HeaderMsgType = "REPLY"
const Dhcpv6HeaderMsgTypeREQUEST Dhcpv6HeaderMsgType = "REQUEST"
const Dhcpv6HeaderMsgTypeSOLICIT Dhcpv6HeaderMsgType = "SOLICIT"

var enumValues_Dhcpv6HeaderMsgType = []interface{}{
	"SOLICIT",
	"ADVERTISE",
	"REQUEST",
	"REPLY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Dhcpv6HeaderMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Dhcpv6HeaderMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Dhcpv6HeaderMsgType, v)
	}
	*j = Dhcpv6HeaderMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Dhcpv6Header) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Dhcpv6Header
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		plain.MsgType = "SOLICIT"
	}
	*j = Dhcpv6Header(plain)
	return nil
}

type DiscoveredResourceScope struct {
	// Specifies the scope id of discovered resource.
	ScopeId *string `json:"scope_id,omitempty" yaml:"scope_id,omitempty" mapstructure:"scope_id,omitempty"`

	// Type of the scope for the discovered resource.
	ScopeType *DiscoveredResourceScopeScopeType `json:"scope_type,omitempty" yaml:"scope_type,omitempty" mapstructure:"scope_type,omitempty"`
}

type DiscoveredResourceScopeScopeType string

const DiscoveredResourceScopeScopeTypeCONTAINERCLUSTER DiscoveredResourceScopeScopeType = "CONTAINER_CLUSTER"
const DiscoveredResourceScopeScopeTypeVPC DiscoveredResourceScopeScopeType = "VPC"

var enumValues_DiscoveredResourceScopeScopeType = []interface{}{
	"CONTAINER_CLUSTER",
	"VPC",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DiscoveredResourceScopeScopeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DiscoveredResourceScopeScopeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DiscoveredResourceScopeScopeType, v)
	}
	*j = DiscoveredResourceScopeScopeType(v)
	return nil
}

type DnsHeader struct {
	// This is used to define what is being asked or responded.
	Address *string `json:"address,omitempty" yaml:"address,omitempty" mapstructure:"address,omitempty"`

	// This is used to specify the type of the address. V4 - The address provided is
	// an IPv4 domain name/IP address, the Type in query or response will be A V6 -
	// The address provided is an IPv6 domain name/IP address, the Type in query or
	// response will be AAAA
	AddressType DnsHeaderAddressType `json:"address_type,omitempty" yaml:"address_type,omitempty" mapstructure:"address_type,omitempty"`

	// MessageType corresponds to the JSON schema field "message_type".
	MessageType DnsHeaderMessageType `json:"message_type,omitempty" yaml:"message_type,omitempty" mapstructure:"message_type,omitempty"`
}

type DnsHeaderAddressType string

const DnsHeaderAddressTypeV4 DnsHeaderAddressType = "V4"
const DnsHeaderAddressTypeV6 DnsHeaderAddressType = "V6"

var enumValues_DnsHeaderAddressType = []interface{}{
	"V4",
	"V6",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DnsHeaderAddressType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DnsHeaderAddressType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DnsHeaderAddressType, v)
	}
	*j = DnsHeaderAddressType(v)
	return nil
}

type DnsHeaderMessageType string

const DnsHeaderMessageTypeQUERY DnsHeaderMessageType = "QUERY"
const DnsHeaderMessageTypeRESPONSE DnsHeaderMessageType = "RESPONSE"

var enumValues_DnsHeaderMessageType = []interface{}{
	"QUERY",
	"RESPONSE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DnsHeaderMessageType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_DnsHeaderMessageType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_DnsHeaderMessageType, v)
	}
	*j = DnsHeaderMessageType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *DnsHeader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain DnsHeader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["address_type"]; !ok || v == nil {
		plain.AddressType = "V4"
	}
	if v, ok := raw["message_type"]; !ok || v == nil {
		plain.MessageType = "QUERY"
	}
	*j = DnsHeader(plain)
	return nil
}

// Domain.
type Domain struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Domain) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Domain
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Domain(plain)
	return nil
}

type EpochMsTimestamp int

type EtherTypeServiceEntry struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// EtherType corresponds to the JSON schema field "ether_type".
	EtherType *int `json:"ether_type,omitempty" yaml:"ether_type,omitempty" mapstructure:"ether_type,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *EtherTypeServiceEntryResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type EtherTypeServiceEntryResourceType string

const EtherTypeServiceEntryResourceTypeALGTypeServiceEntry EtherTypeServiceEntryResourceType = "ALGTypeServiceEntry"
const EtherTypeServiceEntryResourceTypeEtherTypeServiceEntry EtherTypeServiceEntryResourceType = "EtherTypeServiceEntry"
const EtherTypeServiceEntryResourceTypeICMPTypeServiceEntry EtherTypeServiceEntryResourceType = "ICMPTypeServiceEntry"
const EtherTypeServiceEntryResourceTypeIGMPTypeServiceEntry EtherTypeServiceEntryResourceType = "IGMPTypeServiceEntry"
const EtherTypeServiceEntryResourceTypeIPProtocolServiceEntry EtherTypeServiceEntryResourceType = "IPProtocolServiceEntry"
const EtherTypeServiceEntryResourceTypeL4PortSetServiceEntry EtherTypeServiceEntryResourceType = "L4PortSetServiceEntry"
const EtherTypeServiceEntryResourceTypeNestedServiceServiceEntry EtherTypeServiceEntryResourceType = "NestedServiceServiceEntry"

var enumValues_EtherTypeServiceEntryResourceType = []interface{}{
	"IPProtocolServiceEntry",
	"IGMPTypeServiceEntry",
	"ICMPTypeServiceEntry",
	"ALGTypeServiceEntry",
	"L4PortSetServiceEntry",
	"EtherTypeServiceEntry",
	"NestedServiceServiceEntry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EtherTypeServiceEntryResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_EtherTypeServiceEntryResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_EtherTypeServiceEntryResourceType, v)
	}
	*j = EtherTypeServiceEntryResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EtherTypeServiceEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain EtherTypeServiceEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = EtherTypeServiceEntry(plain)
	return nil
}

type EthernetHeader struct {
	// The destination MAC address of form:
	// "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$". For example: 00:00:00:00:00:00.
	DstMac *string `json:"dst_mac,omitempty" yaml:"dst_mac,omitempty" mapstructure:"dst_mac,omitempty"`

	// This field defaults to IPv4.
	EthType int `json:"eth_type,omitempty" yaml:"eth_type,omitempty" mapstructure:"eth_type,omitempty"`

	// The source MAC address of form: "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$".
	// For example: 00:00:00:00:00:00.
	SrcMac *string `json:"src_mac,omitempty" yaml:"src_mac,omitempty" mapstructure:"src_mac,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *EthernetHeader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain EthernetHeader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["eth_type"]; !ok || v == nil {
		plain.EthType = 2048.0
	}
	*j = EthernetHeader(plain)
	return nil
}

// Represents the list of members that need to be excluded
type ExcludedMembersList struct {
	// IpAddressExpression corresponds to the JSON schema field
	// "ip_address_expression".
	IpAddressExpression *IPAddressExpression `json:"ip_address_expression,omitempty" yaml:"ip_address_expression,omitempty" mapstructure:"ip_address_expression,omitempty"`

	// Paths can be only IP address based groups. Upto 50 paths are allowed.
	PathExpression *PathExpression `json:"path_expression,omitempty" yaml:"path_expression,omitempty" mapstructure:"path_expression,omitempty"`
}

// All the nodes of the expression extend from this abstract class. This is present
// for extensibility.
type Expression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ExpressionResourceType string

const ExpressionResourceTypeCondition ExpressionResourceType = "Condition"
const ExpressionResourceTypeConjunctionOperator ExpressionResourceType = "ConjunctionOperator"
const ExpressionResourceTypeExternalIDExpression ExpressionResourceType = "ExternalIDExpression"
const ExpressionResourceTypeIPAddressExpression ExpressionResourceType = "IPAddressExpression"
const ExpressionResourceTypeIdentityGroupExpression ExpressionResourceType = "IdentityGroupExpression"
const ExpressionResourceTypeMACAddressExpression ExpressionResourceType = "MACAddressExpression"
const ExpressionResourceTypeNestedExpression ExpressionResourceType = "NestedExpression"
const ExpressionResourceTypePathExpression ExpressionResourceType = "PathExpression"

var enumValues_ExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExpressionResourceType, v)
	}
	*j = ExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Expression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Expression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Expression(plain)
	return nil
}

// Represents external Id expressions in the form of an array, to support addition
// of objects like virtual interfaces, virtual machines, CloudNativeServiceInstance
// PhysicalServer to a group.
type ExternalIDExpression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// This array can consist of one or more external IDs for the specified member
	// type.
	ExternalIds []string `json:"external_ids,omitempty" yaml:"external_ids,omitempty" mapstructure:"external_ids,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// MemberType corresponds to the JSON schema field "member_type".
	MemberType *ExternalIDExpressionMemberType `json:"member_type,omitempty" yaml:"member_type,omitempty" mapstructure:"member_type,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ExternalIDExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ExternalIDExpressionMemberType string

const ExternalIDExpressionMemberTypeCloudNativeServiceInstance ExternalIDExpressionMemberType = "CloudNativeServiceInstance"
const ExternalIDExpressionMemberTypePhysicalServer ExternalIDExpressionMemberType = "PhysicalServer"
const ExternalIDExpressionMemberTypeVirtualMachine ExternalIDExpressionMemberType = "VirtualMachine"
const ExternalIDExpressionMemberTypeVirtualNetworkInterface ExternalIDExpressionMemberType = "VirtualNetworkInterface"

var enumValues_ExternalIDExpressionMemberType = []interface{}{
	"VirtualMachine",
	"VirtualNetworkInterface",
	"CloudNativeServiceInstance",
	"PhysicalServer",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExternalIDExpressionMemberType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExternalIDExpressionMemberType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExternalIDExpressionMemberType, v)
	}
	*j = ExternalIDExpressionMemberType(v)
	return nil
}

type ExternalIDExpressionResourceType string

const ExternalIDExpressionResourceTypeCondition ExternalIDExpressionResourceType = "Condition"
const ExternalIDExpressionResourceTypeConjunctionOperator ExternalIDExpressionResourceType = "ConjunctionOperator"
const ExternalIDExpressionResourceTypeExternalIDExpression ExternalIDExpressionResourceType = "ExternalIDExpression"
const ExternalIDExpressionResourceTypeIPAddressExpression ExternalIDExpressionResourceType = "IPAddressExpression"
const ExternalIDExpressionResourceTypeIdentityGroupExpression ExternalIDExpressionResourceType = "IdentityGroupExpression"
const ExternalIDExpressionResourceTypeMACAddressExpression ExternalIDExpressionResourceType = "MACAddressExpression"
const ExternalIDExpressionResourceTypeNestedExpression ExternalIDExpressionResourceType = "NestedExpression"
const ExternalIDExpressionResourceTypePathExpression ExternalIDExpressionResourceType = "PathExpression"

var enumValues_ExternalIDExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExternalIDExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ExternalIDExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ExternalIDExpressionResourceType, v)
	}
	*j = ExternalIDExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ExternalIDExpression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ExternalIDExpression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if plain.ExternalIds != nil && len(plain.ExternalIds) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "external_ids", 1)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = ExternalIDExpression(plain)
	return nil
}

// Additional configuration required for federation.
type FederationConnectivityConfig struct {
	// Global id for by Layer3 services for federation usecases.
	GlobalOverlayId *int `json:"global_overlay_id,omitempty" yaml:"global_overlay_id,omitempty" mapstructure:"global_overlay_id,omitempty"`
}

// Additional gateway configuration required for federation
type FederationGatewayConfig struct {
	// Global id for by Layer3 services for federation usecases.
	GlobalOverlayId *int `json:"global_overlay_id,omitempty" yaml:"global_overlay_id,omitempty" mapstructure:"global_overlay_id,omitempty"`

	// Indicies for cross site allocation for edge cluster and its members referred by
	// gateway.
	SiteAllocationIndices []SiteAllocationIndexForEdge `json:"site_allocation_indices,omitempty" yaml:"site_allocation_indices,omitempty" mapstructure:"site_allocation_indices,omitempty"`

	// Global UUID for transit segment id to be used by Layer2 services for federation
	// usecases.
	TransitSegmentId *string `json:"transit_segment_id,omitempty" yaml:"transit_segment_id,omitempty" mapstructure:"transit_segment_id,omitempty"`
}

type FieldsPacketData struct {
	// ArpHeader corresponds to the JSON schema field "arp_header".
	ArpHeader *ArpHeader `json:"arp_header,omitempty" yaml:"arp_header,omitempty" mapstructure:"arp_header,omitempty"`

	// EthHeader corresponds to the JSON schema field "eth_header".
	EthHeader *EthernetHeader `json:"eth_header,omitempty" yaml:"eth_header,omitempty" mapstructure:"eth_header,omitempty"`

	// If the requested frame_size is too small (given the payload and traceflow
	// metadata requirement of 16 bytes), the traceflow request will fail with an
	// appropriate message.  The frame will be zero padded to the requested size.
	FrameSize int `json:"frame_size,omitempty" yaml:"frame_size,omitempty" mapstructure:"frame_size,omitempty"`

	// IpHeader corresponds to the JSON schema field "ip_header".
	IpHeader *Ipv4Header `json:"ip_header,omitempty" yaml:"ip_header,omitempty" mapstructure:"ip_header,omitempty"`

	// Ipv6Header corresponds to the JSON schema field "ipv6_header".
	Ipv6Header *Ipv6Header `json:"ipv6_header,omitempty" yaml:"ipv6_header,omitempty" mapstructure:"ipv6_header,omitempty"`

	// Up to 1000 bytes of payload may be supplied (with a base64-encoded length of
	// 1336 bytes.) Additional bytes of traceflow metadata will be appended to the
	// payload. The payload contains any data the user wants to put after the
	// transport header.
	Payload *string `json:"payload,omitempty" yaml:"payload,omitempty" mapstructure:"payload,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType FieldsPacketDataResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// When this flag is set, traceflow packet will have its destination overwritten
	// as the gateway address of the logical router to which the source logical switch
	// is connected. More specifically: - For ARP request, the target IP will be
	// overwritten as gateway IP if the target   IP is not in the same subnet of
	// gateway. - For ARP response, the target IP and destination MAC will be
	// overwritten as   gateway IP/MAC respectively, if the target IP is not in the
	// same subnet of gateway. - For IP packet, the destination MAC will be
	// overwritten as gateway MAC. However, this flag will not be effective when
	// injecting the traceflow packet to a VLAN backed port. This is because the
	// gateway in this case is a physical gateway that is outside the scope of NSX.
	// Therefore, users need to manually populate the gateway MAC address. If the user
	// still sets this flag in this case, a validation error will be thrown. The
	// scenario where a user injects a packet with a VLAN tag into a parent port is
	// referred to as the traceflow container case. Please note that the value of
	// `routed` depends on the connected network of the child segment rather than the
	// connected network of segment of the parent port in this case. Here is the
	// explanation: The parent port in this context is the port on a segment which is
	// referred to by a SegmentConnectionBindingMap. The bound segment of the
	// SegmentConnectionBindingMap is the child segment. The user-crafted traceflow
	// packet will be directly forwarded to the corresponding child segment of the
	// parent port without interacting with any layer 2 forwarding/layer 3 routing in
	// this scenario. The crafted packet will follow the forwarding/routing polices of
	// the child segment's connected network. For example, if a user injects a crafted
	// packet to port_p, and the segment (seg_p) of port_p is referred to by the
	// binding map m1, where m1 is bound to segment seg_c, and the destination port
	// (port_d) of the packet is the VM vNIC connected to seg_p. Although port_p and
	// port_d are on the same segment, the 'routed' value should be set to true if the
	// user expects the crafted packet to be correctly delivered to the destination.
	// This is because the child segments seg_c and seg_d are on different segments
	// and require router interaction to communicate.
	Routed *bool `json:"routed,omitempty" yaml:"routed,omitempty" mapstructure:"routed,omitempty"`

	// This field contains a protocol that is above IP. It is not restricted to the
	// 'transport' defined by the OSI model (e.g., ICMP is supported).
	TransportHeader *TransportProtocolHeader `json:"transport_header,omitempty" yaml:"transport_header,omitempty" mapstructure:"transport_header,omitempty"`

	// This type takes effect only for IP packet.
	TransportType FieldsPacketDataTransportType `json:"transport_type,omitempty" yaml:"transport_type,omitempty" mapstructure:"transport_type,omitempty"`
}

type FieldsPacketDataResourceType string

const FieldsPacketDataResourceTypeBinaryPacketData FieldsPacketDataResourceType = "BinaryPacketData"
const FieldsPacketDataResourceTypeFieldsPacketData FieldsPacketDataResourceType = "FieldsPacketData"

var enumValues_FieldsPacketDataResourceType = []interface{}{
	"BinaryPacketData",
	"FieldsPacketData",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FieldsPacketDataResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_FieldsPacketDataResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FieldsPacketDataResourceType, v)
	}
	*j = FieldsPacketDataResourceType(v)
	return nil
}

type FieldsPacketDataTransportType string

const FieldsPacketDataTransportTypeBROADCAST FieldsPacketDataTransportType = "BROADCAST"
const FieldsPacketDataTransportTypeMULTICAST FieldsPacketDataTransportType = "MULTICAST"
const FieldsPacketDataTransportTypeUNICAST FieldsPacketDataTransportType = "UNICAST"
const FieldsPacketDataTransportTypeUNKNOWN FieldsPacketDataTransportType = "UNKNOWN"

var enumValues_FieldsPacketDataTransportType = []interface{}{
	"BROADCAST",
	"UNICAST",
	"MULTICAST",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FieldsPacketDataTransportType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_FieldsPacketDataTransportType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FieldsPacketDataTransportType, v)
	}
	*j = FieldsPacketDataTransportType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FieldsPacketData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain FieldsPacketData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["frame_size"]; !ok || v == nil {
		plain.FrameSize = 128.0
	}
	if plain.Payload != nil && len(*plain.Payload) > 1336 {
		return fmt.Errorf("field %s length: must be <= %d", "payload", 1336)
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "FieldsPacketData"
	}
	if v, ok := raw["transport_type"]; !ok || v == nil {
		plain.TransportType = "UNICAST"
	}
	*j = FieldsPacketData(plain)
	return nil
}

type FirewallRule struct {
	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Owner corresponds to the JSON schema field "_owner".
	Owner *OwnerResourceLink `json:"_owner,omitempty" yaml:"_owner,omitempty" mapstructure:"_owner,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Action enforced on the packets which matches the distributed service rule.
	// Currently DS Layer supports below actions. ALLOW           - Forward any packet
	// when a rule with this action gets a match (Used by Firewall). DROP            -
	// Drop any packet when a rule with this action gets a match. Packets won't go
	// further(Used by Firewall). REJECT          - Terminate TCP connection by
	// sending TCP reset for a packet when a rule with this action gets a match (Used
	// by Firewall). REDIRECT        - Redirect any packet to a partner appliance when
	// a rule with this action gets a match (Used by Service Insertion).
	// DO_NOT_REDIRECT - Do not redirect any packet to a partner appliance when a rule
	// with this action gets a match (Used by Service Insertion). DETECT          -
	// Detect IDS Signatures. ALLOW_CONTINUE  - Allows rules to jump from this rule.
	// Action on matching rules in the destination category will decide next step.
	// Application is default destination until new categories are supported to jump
	// to. DETECT_PREVENT  - Detect and Prevent IDS Signatures.
	Action *FirewallRuleAction `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// List of object where rule will be enforced. The section level field overrides
	// this one. Null will be treated as any.
	AppliedTos []ResourceReference `json:"applied_tos,omitempty" yaml:"applied_tos,omitempty" mapstructure:"applied_tos,omitempty"`

	// NS Profile object which accepts attributes and sub-attributes of various
	// network services (ex. L7 AppId, domain name, encryption algorithm) as key value
	// pairs.
	ContextProfiles []ResourceReference `json:"context_profiles,omitempty" yaml:"context_profiles,omitempty" mapstructure:"context_profiles,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// List of the destinations. Null will be treated as any.
	Destinations []ResourceReference `json:"destinations,omitempty" yaml:"destinations,omitempty" mapstructure:"destinations,omitempty"`

	// Negation of the destination.
	DestinationsExcluded bool `json:"destinations_excluded,omitempty" yaml:"destinations_excluded,omitempty" mapstructure:"destinations_excluded,omitempty"`

	// Rule direction in case of stateless distributed service rules. This will only
	// considered if section level parameter is set to stateless. Default to IN_OUT if
	// not specified.
	Direction FirewallRuleDirection `json:"direction,omitempty" yaml:"direction,omitempty" mapstructure:"direction,omitempty"`

	// Flag to disable rule. Disabled will only be persisted but never
	// provisioned/realized.
	Disabled bool `json:"disabled,omitempty" yaml:"disabled,omitempty" mapstructure:"disabled,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// List of NSGroups that have end point attributes like AD Groups(SID), process
	// name, process hash etc. For Flash release, only NSGroups containing AD Groups
	// are supported.
	ExtendedSources []ResourceReference `json:"extended_sources,omitempty" yaml:"extended_sources,omitempty" mapstructure:"extended_sources,omitempty"`

	// Identifier of the resource
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Type of IP packet that should be matched while enforcing the rule.
	IpProtocol FirewallRuleIpProtocol `json:"ip_protocol,omitempty" yaml:"ip_protocol,omitempty" mapstructure:"ip_protocol,omitempty"`

	// Flag to indicate whether rule is default.
	IsDefault *bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// Flag to enable packet logging. Default is disabled.
	Logged bool `json:"logged,omitempty" yaml:"logged,omitempty" mapstructure:"logged,omitempty"`

	// User notes specific to the rule.
	Notes *string `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`

	// Priority of the rule.
	Priority *int `json:"priority,omitempty" yaml:"priority,omitempty" mapstructure:"priority,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// User level field which will be printed in CLI and packet logs.
	RuleTag *string `json:"rule_tag,omitempty" yaml:"rule_tag,omitempty" mapstructure:"rule_tag,omitempty"`

	// Section Id of the section to which this rule belongs to.
	SectionId *string `json:"section_id,omitempty" yaml:"section_id,omitempty" mapstructure:"section_id,omitempty"`

	// List of the services. Null will be treated as any.
	Services []FirewallService `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`

	// List of sources. Null will be treated as any.
	Sources []ResourceReference `json:"sources,omitempty" yaml:"sources,omitempty" mapstructure:"sources,omitempty"`

	// Negation of the source.
	SourcesExcluded bool `json:"sources_excluded,omitempty" yaml:"sources_excluded,omitempty" mapstructure:"sources_excluded,omitempty"`
}

type FirewallRuleAction string

const FirewallRuleActionALLOW FirewallRuleAction = "ALLOW"
const FirewallRuleActionALLOWCONTINUE FirewallRuleAction = "ALLOW_CONTINUE"
const FirewallRuleActionDETECT FirewallRuleAction = "DETECT"
const FirewallRuleActionDETECTPREVENT FirewallRuleAction = "DETECT_PREVENT"
const FirewallRuleActionDONOTREDIRECT FirewallRuleAction = "DO_NOT_REDIRECT"
const FirewallRuleActionDROP FirewallRuleAction = "DROP"
const FirewallRuleActionREDIRECT FirewallRuleAction = "REDIRECT"
const FirewallRuleActionREJECT FirewallRuleAction = "REJECT"

var enumValues_FirewallRuleAction = []interface{}{
	"ALLOW",
	"DROP",
	"REJECT",
	"REDIRECT",
	"DO_NOT_REDIRECT",
	"DETECT",
	"ALLOW_CONTINUE",
	"DETECT_PREVENT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FirewallRuleAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_FirewallRuleAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FirewallRuleAction, v)
	}
	*j = FirewallRuleAction(v)
	return nil
}

type FirewallRuleDirection string

const FirewallRuleDirectionIN FirewallRuleDirection = "IN"
const FirewallRuleDirectionINOUT FirewallRuleDirection = "IN_OUT"
const FirewallRuleDirectionOUT FirewallRuleDirection = "OUT"

var enumValues_FirewallRuleDirection = []interface{}{
	"IN",
	"OUT",
	"IN_OUT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FirewallRuleDirection) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_FirewallRuleDirection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FirewallRuleDirection, v)
	}
	*j = FirewallRuleDirection(v)
	return nil
}

type FirewallRuleIpProtocol string

const FirewallRuleIpProtocolIPV4 FirewallRuleIpProtocol = "IPV4"
const FirewallRuleIpProtocolIPV4IPV6 FirewallRuleIpProtocol = "IPV4_IPV6"
const FirewallRuleIpProtocolIPV6 FirewallRuleIpProtocol = "IPV6"

var enumValues_FirewallRuleIpProtocol = []interface{}{
	"IPV4",
	"IPV6",
	"IPV4_IPV6",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FirewallRuleIpProtocol) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_FirewallRuleIpProtocol {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_FirewallRuleIpProtocol, v)
	}
	*j = FirewallRuleIpProtocol(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FirewallRule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain FirewallRule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.AppliedTos) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "applied_tos", 128)
	}
	if len(plain.ContextProfiles) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "context_profiles", 128)
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if len(plain.Destinations) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "destinations", 128)
	}
	if v, ok := raw["destinations_excluded"]; !ok || v == nil {
		plain.DestinationsExcluded = false
	}
	if v, ok := raw["direction"]; !ok || v == nil {
		plain.Direction = "IN_OUT"
	}
	if v, ok := raw["disabled"]; !ok || v == nil {
		plain.Disabled = false
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.ExtendedSources) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "extended_sources", 128)
	}
	if v, ok := raw["ip_protocol"]; !ok || v == nil {
		plain.IpProtocol = "IPV4_IPV6"
	}
	if v, ok := raw["logged"]; !ok || v == nil {
		plain.Logged = false
	}
	if plain.Notes != nil && len(*plain.Notes) > 2048 {
		return fmt.Errorf("field %s length: must be <= %d", "notes", 2048)
	}
	if plain.RuleTag != nil && len(*plain.RuleTag) > 32 {
		return fmt.Errorf("field %s length: must be <= %d", "rule_tag", 32)
	}
	if len(plain.Services) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "services", 128)
	}
	if len(plain.Sources) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "sources", 128)
	}
	if v, ok := raw["sources_excluded"]; !ok || v == nil {
		plain.SourcesExcluded = false
	}
	*j = FirewallRule(plain)
	return nil
}

type FirewallService struct {
	// Will be set to false if the referenced NSX resource has been deleted.
	IsValid *bool `json:"is_valid,omitempty" yaml:"is_valid,omitempty" mapstructure:"is_valid,omitempty"`

	// Distributed Service API accepts raw protocol and ports as part of NS service
	// element in Distributed Service Rule that describes traffic corresponding to an
	// NSService.
	Service *NSServiceElement `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// Display name of the NSX resource.
	TargetDisplayName *string `json:"target_display_name,omitempty" yaml:"target_display_name,omitempty" mapstructure:"target_display_name,omitempty"`

	// Identifier of the NSX resource.
	TargetId *string `json:"target_id,omitempty" yaml:"target_id,omitempty" mapstructure:"target_id,omitempty"`

	// Type of the NSX resource.
	TargetType *string `json:"target_type,omitempty" yaml:"target_type,omitempty" mapstructure:"target_type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *FirewallService) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain FirewallService
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.TargetDisplayName != nil && len(*plain.TargetDisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "target_display_name", 255)
	}
	if plain.TargetId != nil && len(*plain.TargetId) > 64 {
		return fmt.Errorf("field %s length: must be <= %d", "target_id", 64)
	}
	if plain.TargetType != nil && len(*plain.TargetType) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "target_type", 255)
	}
	*j = FirewallService(plain)
	return nil
}

type GatewayPolicy struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// - Distributed Firewall - Policy framework provides five pre-defined categories
	// for classifying a security policy. They are "Ethernet","Emergency",
	// "Infrastructure" "Environment" and "Application". There is a pre-determined
	// order in which the policy framework manages the priority of these security
	// policies. Ethernet category is for supporting layer 2 firewall rules. The other
	// four categories are applicable for layer 3 rules. Amongst them, the Emergency
	// category has the highest priority followed by Infrastructure, Environment and
	// then Application rules. Administrator can choose to categorize a security
	// policy into the above categories or can choose to leave it empty. If empty it
	// will have the least precedence w.r.t the above four categories. - Edge Firewall
	// - Policy Framework for Edge Firewall provides six pre-defined categories
	// "Emergency", "SystemRules", "SharedPreRules", "LocalGatewayRules",
	// "AutoServiceRules" and "Default", in order of priority of rules. All categories
	// are allowed for Gatetway Policies that belong to 'default' Domain. However, for
	// user created domains, category is restricted to "SharedPreRules" or
	// "LocalGatewayRules" only. Also, the users can add/modify/delete rules from only
	// the "SharedPreRules" and "LocalGatewayRules" categories. If user doesn't
	// specify the category then defaulted to "Rules". System generated category is
	// used by NSX created rules, for example BFD rules. Autoplumbed category used by
	// NSX verticals to autoplumb data path rules. Finally, "Default" category is the
	// placeholder default rules with lowest in the order of priority.
	Category *string `json:"category,omitempty" yaml:"category,omitempty" mapstructure:"category,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Comments for security policy lock/unlock.
	Comments *string `json:"comments,omitempty" yaml:"comments,omitempty" mapstructure:"comments,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// This field is to indicate the internal sequence number of a policy with respect
	// to the policies across categories.
	InternalSequenceNumber *int `json:"internal_sequence_number,omitempty" yaml:"internal_sequence_number,omitempty" mapstructure:"internal_sequence_number,omitempty"`

	// A flag to indicate whether policy is a default policy.
	IsDefault *bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// Id of the user who last modified the lock for the secruity policy.
	LockModifiedBy *string `json:"lock_modified_by,omitempty" yaml:"lock_modified_by,omitempty" mapstructure:"lock_modified_by,omitempty"`

	// SecurityPolicy locked/unlocked time in epoch milliseconds.
	LockModifiedTime *EpochMsTimestamp `json:"lock_modified_time,omitempty" yaml:"lock_modified_time,omitempty" mapstructure:"lock_modified_time,omitempty"`

	// Indicates whether a security policy should be locked. If the security policy is
	// locked by a user, then no other user would be able to modify this security
	// policy. Once the user releases the lock, other users can update this security
	// policy.
	Locked bool `json:"locked,omitempty" yaml:"locked,omitempty" mapstructure:"locked,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// The count of rules in the policy.
	RuleCount *int `json:"rule_count,omitempty" yaml:"rule_count,omitempty" mapstructure:"rule_count,omitempty"`

	// Rules corresponds to the JSON schema field "rules".
	Rules []Rule `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// Provides a mechanism to apply the rules in this policy for a specified time
	// duration.
	SchedulerPath *string `json:"scheduler_path,omitempty" yaml:"scheduler_path,omitempty" mapstructure:"scheduler_path,omitempty"`

	// The list of group paths where the rules in this policy will get applied. This
	// scope will take precedence over rule level scope. Supported only for security
	// and redirection policies. In case of RedirectionPolicy, it is expected only
	// when the policy is NS and redirecting to service chain.
	Scope []string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// This field is used to resolve conflicts between security policies across
	// domains. In order to change the sequence number of a policy one can fire a POST
	// request on the policy entity with a query parameter action=revise The sequence
	// number field will reflect the value of the computed sequence number upon
	// execution of the above mentioned POST request. For scenarios where the
	// administrator is using a template to update several security policies, the only
	// way to set the sequence number is to explicitly specify the sequence number for
	// each security policy. If no sequence number is specified in the payload, a
	// value of 0 is assigned by default. If there are multiple policies with the same
	// sequence number then their order is not deterministic. If a specific order of
	// policies is desired, then one has to specify unique sequence numbers or use the
	// POST request on the policy entity with a query parameter action=revise to let
	// the framework assign a sequence number. The value of sequence number must be
	// between 0 and 999,999.
	SequenceNumber *int `json:"sequence_number,omitempty" yaml:"sequence_number,omitempty" mapstructure:"sequence_number,omitempty"`

	// Stateful or Stateless nature of security policy is enforced on all rules in
	// this security policy. When it is stateful, the state of the network connects
	// are tracked and a stateful packet inspection is performed. Layer3 security
	// policies can be stateful or stateless. By default, they are stateful. Layer2
	// security policies can only be stateless.
	Stateful *bool `json:"stateful,omitempty" yaml:"stateful,omitempty" mapstructure:"stateful,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Ensures that a 3 way TCP handshake is done before the data packets are sent.
	// tcp_strict=true is supported only for stateful security policies. If the
	// tcp_strict flag is not specified and the security policy is stateful, then
	// tcp_strict will be set to true.
	TcpStrict *bool `json:"tcp_strict,omitempty" yaml:"tcp_strict,omitempty" mapstructure:"tcp_strict,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GatewayPolicy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain GatewayPolicy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["locked"]; !ok || v == nil {
		plain.Locked = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = GatewayPolicy(plain)
	return nil
}

type GatewayQosProfileConfig struct {
	// Policy path to gateway QoS profile in egress direction.
	EgressQosProfilePath *string `json:"egress_qos_profile_path,omitempty" yaml:"egress_qos_profile_path,omitempty" mapstructure:"egress_qos_profile_path,omitempty"`

	// Policy path to gateway QoS profile in ingress direction.
	IngressQosProfilePath *string `json:"ingress_qos_profile_path,omitempty" yaml:"ingress_qos_profile_path,omitempty" mapstructure:"ingress_qos_profile_path,omitempty"`
}

// Group.
type Group struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// The expression list must follow below criteria:   1. A non-empty expression
	// list, must be of odd size. In a list, with   indices starting from 0, all
	// non-conjunction expressions must be at   even indices, separated by a
	// conjunction expression at odd   indices.   2. The total of ConditionExpression
	// and NestedExpression in a list   should not exceed 5.   3. The total of
	// IPAddressExpression, MACAddressExpression, external   IDs in an
	// ExternalIDExpression and paths in a PathExpression must not exceed   the
	// defined Config Max limit for the form-factor of Manager nodes.   4. Each
	// expression must be a valid Expression. See the definition of   the Expression
	// type for more information.
	Expression []Expression `json:"expression,omitempty" yaml:"expression,omitempty" mapstructure:"expression,omitempty"`

	// Extended Expression allows additional higher level context to be specified for
	// grouping criteria. (e.g. user AD group) This field allow users to specified
	// user context as the source of a firewall rule for IDFW feature. Current version
	// only support a single IdentityGroupExpression. In the future, this might expand
	// to support other conjunction and non-conjunction expression.  The extended
	// expression list must follow below criteria: 1. Contains a single
	// IdentityGroupExpression. No conjunction expression is supported. 2. No other
	// non-conjunction expression is supported, except for IdentityGroupExpression. 3.
	// Each expression must be a valid Expression. See the definition of the
	// Expression type for more information. 4. Extended expression are implicitly AND
	// with expression. 5. No nesting can be supported if this value is used. 6. If a
	// Group is using extended expression, this group must be the only member in the
	// source field of an communication map.
	ExtendedExpression []Expression `json:"extended_expression,omitempty" yaml:"extended_expression,omitempty" mapstructure:"extended_expression,omitempty"`

	// Group type can be specified during create and update of a group. Empty group
	// type indicates a 'generic' group, ie group can include any entity from the
	// valid GroupMemberType.
	GroupType []GroupTypes `json:"group_type,omitempty" yaml:"group_type,omitempty" mapstructure:"group_type,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// If true, indicates that this is a remote reference group. Such group will have
	// span different from the its parent domain. Default value is false.
	Reference bool `json:"reference,omitempty" yaml:"reference,omitempty" mapstructure:"reference,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// State corresponds to the JSON schema field "state".
	State *GroupState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type GroupState string

const GroupStateFAILURE GroupState = "FAILURE"
const GroupStateINPROGRESS GroupState = "IN_PROGRESS"
const GroupStateSUCCESS GroupState = "SUCCESS"

var enumValues_GroupState = []interface{}{
	"IN_PROGRESS",
	"SUCCESS",
	"FAILURE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GroupState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GroupState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GroupState, v)
	}
	*j = GroupState(v)
	return nil
}

type GroupTypes string

const GroupTypesANTREA GroupTypes = "ANTREA"
const GroupTypesIPAddress GroupTypes = "IPAddress"

var enumValues_GroupTypes = []interface{}{
	"IPAddress",
	"ANTREA",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *GroupTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_GroupTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_GroupTypes, v)
	}
	*j = GroupTypes(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Group) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Group
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.ExtendedExpression) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "extended_expression", 1)
	}
	if len(plain.GroupType) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "group_type", 1)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if v, ok := raw["reference"]; !ok || v == nil {
		plain.Reference = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Group(plain)
	return nil
}

// Guest virtual machine details include OS name and computer name of guest VM.
type GuestInfo struct {
	// Computer name of guest virtual machine, which is set inside guest OS. Currently
	// this is supported for guests on ESXi that have VMware Tools installed.
	ComputerName *string `json:"computer_name,omitempty" yaml:"computer_name,omitempty" mapstructure:"computer_name,omitempty"`

	// OS name of guest virtual machine. Currently this is supported for guests on
	// ESXi that have VMware Tools installed.
	OsName *string `json:"os_name,omitempty" yaml:"os_name,omitempty" mapstructure:"os_name,omitempty"`
}

type ICMPTypeServiceEntry struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// IcmpCode corresponds to the JSON schema field "icmp_code".
	IcmpCode *int `json:"icmp_code,omitempty" yaml:"icmp_code,omitempty" mapstructure:"icmp_code,omitempty"`

	// IcmpType corresponds to the JSON schema field "icmp_type".
	IcmpType *int `json:"icmp_type,omitempty" yaml:"icmp_type,omitempty" mapstructure:"icmp_type,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Protocol corresponds to the JSON schema field "protocol".
	Protocol *ICMPTypeServiceEntryProtocol `json:"protocol,omitempty" yaml:"protocol,omitempty" mapstructure:"protocol,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ICMPTypeServiceEntryResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ICMPTypeServiceEntryProtocol string

const ICMPTypeServiceEntryProtocolICMPv4 ICMPTypeServiceEntryProtocol = "ICMPv4"
const ICMPTypeServiceEntryProtocolICMPv6 ICMPTypeServiceEntryProtocol = "ICMPv6"

var enumValues_ICMPTypeServiceEntryProtocol = []interface{}{
	"ICMPv4",
	"ICMPv6",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ICMPTypeServiceEntryProtocol) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ICMPTypeServiceEntryProtocol {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ICMPTypeServiceEntryProtocol, v)
	}
	*j = ICMPTypeServiceEntryProtocol(v)
	return nil
}

type ICMPTypeServiceEntryResourceType string

const ICMPTypeServiceEntryResourceTypeALGTypeServiceEntry ICMPTypeServiceEntryResourceType = "ALGTypeServiceEntry"
const ICMPTypeServiceEntryResourceTypeEtherTypeServiceEntry ICMPTypeServiceEntryResourceType = "EtherTypeServiceEntry"
const ICMPTypeServiceEntryResourceTypeICMPTypeServiceEntry ICMPTypeServiceEntryResourceType = "ICMPTypeServiceEntry"
const ICMPTypeServiceEntryResourceTypeIGMPTypeServiceEntry ICMPTypeServiceEntryResourceType = "IGMPTypeServiceEntry"
const ICMPTypeServiceEntryResourceTypeIPProtocolServiceEntry ICMPTypeServiceEntryResourceType = "IPProtocolServiceEntry"
const ICMPTypeServiceEntryResourceTypeL4PortSetServiceEntry ICMPTypeServiceEntryResourceType = "L4PortSetServiceEntry"
const ICMPTypeServiceEntryResourceTypeNestedServiceServiceEntry ICMPTypeServiceEntryResourceType = "NestedServiceServiceEntry"

var enumValues_ICMPTypeServiceEntryResourceType = []interface{}{
	"IPProtocolServiceEntry",
	"IGMPTypeServiceEntry",
	"ICMPTypeServiceEntry",
	"ALGTypeServiceEntry",
	"L4PortSetServiceEntry",
	"EtherTypeServiceEntry",
	"NestedServiceServiceEntry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ICMPTypeServiceEntryResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ICMPTypeServiceEntryResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ICMPTypeServiceEntryResourceType, v)
	}
	*j = ICMPTypeServiceEntryResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ICMPTypeServiceEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ICMPTypeServiceEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = ICMPTypeServiceEntry(plain)
	return nil
}

type IGMPTypeServiceEntry struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *IGMPTypeServiceEntryResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type IGMPTypeServiceEntryResourceType string

const IGMPTypeServiceEntryResourceTypeALGTypeServiceEntry IGMPTypeServiceEntryResourceType = "ALGTypeServiceEntry"
const IGMPTypeServiceEntryResourceTypeEtherTypeServiceEntry IGMPTypeServiceEntryResourceType = "EtherTypeServiceEntry"
const IGMPTypeServiceEntryResourceTypeICMPTypeServiceEntry IGMPTypeServiceEntryResourceType = "ICMPTypeServiceEntry"
const IGMPTypeServiceEntryResourceTypeIGMPTypeServiceEntry IGMPTypeServiceEntryResourceType = "IGMPTypeServiceEntry"
const IGMPTypeServiceEntryResourceTypeIPProtocolServiceEntry IGMPTypeServiceEntryResourceType = "IPProtocolServiceEntry"
const IGMPTypeServiceEntryResourceTypeL4PortSetServiceEntry IGMPTypeServiceEntryResourceType = "L4PortSetServiceEntry"
const IGMPTypeServiceEntryResourceTypeNestedServiceServiceEntry IGMPTypeServiceEntryResourceType = "NestedServiceServiceEntry"

var enumValues_IGMPTypeServiceEntryResourceType = []interface{}{
	"IPProtocolServiceEntry",
	"IGMPTypeServiceEntry",
	"ICMPTypeServiceEntry",
	"ALGTypeServiceEntry",
	"L4PortSetServiceEntry",
	"EtherTypeServiceEntry",
	"NestedServiceServiceEntry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IGMPTypeServiceEntryResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IGMPTypeServiceEntryResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IGMPTypeServiceEntryResourceType, v)
	}
	*j = IGMPTypeServiceEntryResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IGMPTypeServiceEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain IGMPTypeServiceEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = IGMPTypeServiceEntry(plain)
	return nil
}

type IPAddress string

// Represents IP address expressions in the form of an array, to support addition
// of IP addresses in a group.If duplicate IP Addresses are provided these will be
// filtered out and only unique IP Addresses will be considered. Avoid creating
// groups with multiple IPAddressExpression.In future releases, group will be
// restricted to contain a single IPAddressExpression. To group IPAddresses, use
// nested groups instead of multiple IPAddressExpressions.
type IPAddressExpression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// This array can consist of a single IP address, IP address range or a subnet.
	// Its type can be of either IPv4 or IPv6. Both IPv4 and IPv6 addresses within one
	// expression is not allowed. Supported list of formats are, "192.168.1.1",
	// "192.168.1.1-192.168.1.100", "192.168.0.0/24", "fe80::250:56ff:fe83:318c",
	// "fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c",
	// "fe80::250:56ff:fe83:318c/64". The max limit for number of IP addresses applies
	// across all expressions in a group. Please refer to Config Max limits
	// specification document for a given environment.
	IpAddresses []IPElement `json:"ip_addresses,omitempty" yaml:"ip_addresses,omitempty" mapstructure:"ip_addresses,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *IPAddressExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type IPAddressExpressionResourceType string

const IPAddressExpressionResourceTypeCondition IPAddressExpressionResourceType = "Condition"
const IPAddressExpressionResourceTypeConjunctionOperator IPAddressExpressionResourceType = "ConjunctionOperator"
const IPAddressExpressionResourceTypeExternalIDExpression IPAddressExpressionResourceType = "ExternalIDExpression"
const IPAddressExpressionResourceTypeIPAddressExpression IPAddressExpressionResourceType = "IPAddressExpression"
const IPAddressExpressionResourceTypeIdentityGroupExpression IPAddressExpressionResourceType = "IdentityGroupExpression"
const IPAddressExpressionResourceTypeMACAddressExpression IPAddressExpressionResourceType = "MACAddressExpression"
const IPAddressExpressionResourceTypeNestedExpression IPAddressExpressionResourceType = "NestedExpression"
const IPAddressExpressionResourceTypePathExpression IPAddressExpressionResourceType = "PathExpression"

var enumValues_IPAddressExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IPAddressExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IPAddressExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IPAddressExpressionResourceType, v)
	}
	*j = IPAddressExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IPAddressExpression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain IPAddressExpression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if plain.IpAddresses != nil && len(plain.IpAddresses) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "ip_addresses", 1)
	}
	if len(plain.IpAddresses) > 25000 {
		return fmt.Errorf("field %s length: must be <= %d", "ip_addresses", 25000)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = IPAddressExpression(plain)
	return nil
}

type IPCIDRBlock string

// IPElement can be a single IP address, IP address range or a Subnet. Its type can
// be of IPv4 or IPv6. Supported list of formats are "192.168.1.1",
// "192.168.1.1-192.168.1.100", "192.168.0.0/24", "fe80::250:56ff:fe83:318c",
// "fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c",
// "fe80::250:56ff:fe83:318c/64"
type IPElement string

// IPElement can be a single IP address, IP address range or a Subnet. Its type can
// be of IPv4 or IPv6. Supported list of formats are "192.168.1.1",
// "192.168.1.1-192.168.1.100", "192.168.0.0/24", "fe80::250:56ff:fe83:318c",
// "fe80::250:56ff:fe83:3181-fe80::250:56ff:fe83:318c",
// "fe80::250:56ff:fe83:318c/64"
type IPElementList string

type IPProtocolServiceEntry struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// ProtocolNumber corresponds to the JSON schema field "protocol_number".
	ProtocolNumber *int `json:"protocol_number,omitempty" yaml:"protocol_number,omitempty" mapstructure:"protocol_number,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *IPProtocolServiceEntryResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type IPProtocolServiceEntryResourceType string

const IPProtocolServiceEntryResourceTypeALGTypeServiceEntry IPProtocolServiceEntryResourceType = "ALGTypeServiceEntry"
const IPProtocolServiceEntryResourceTypeEtherTypeServiceEntry IPProtocolServiceEntryResourceType = "EtherTypeServiceEntry"
const IPProtocolServiceEntryResourceTypeICMPTypeServiceEntry IPProtocolServiceEntryResourceType = "ICMPTypeServiceEntry"
const IPProtocolServiceEntryResourceTypeIGMPTypeServiceEntry IPProtocolServiceEntryResourceType = "IGMPTypeServiceEntry"
const IPProtocolServiceEntryResourceTypeIPProtocolServiceEntry IPProtocolServiceEntryResourceType = "IPProtocolServiceEntry"
const IPProtocolServiceEntryResourceTypeL4PortSetServiceEntry IPProtocolServiceEntryResourceType = "L4PortSetServiceEntry"
const IPProtocolServiceEntryResourceTypeNestedServiceServiceEntry IPProtocolServiceEntryResourceType = "NestedServiceServiceEntry"

var enumValues_IPProtocolServiceEntryResourceType = []interface{}{
	"IPProtocolServiceEntry",
	"IGMPTypeServiceEntry",
	"ICMPTypeServiceEntry",
	"ALGTypeServiceEntry",
	"L4PortSetServiceEntry",
	"EtherTypeServiceEntry",
	"NestedServiceServiceEntry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IPProtocolServiceEntryResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IPProtocolServiceEntryResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IPProtocolServiceEntryResourceType, v)
	}
	*j = IPProtocolServiceEntryResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IPProtocolServiceEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain IPProtocolServiceEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = IPProtocolServiceEntry(plain)
	return nil
}

type IPv6Address netip.Addr

type IcmpEchoRequestHeader struct {
	// Id corresponds to the JSON schema field "id".
	Id int `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Sequence corresponds to the JSON schema field "sequence".
	Sequence int `json:"sequence,omitempty" yaml:"sequence,omitempty" mapstructure:"sequence,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IcmpEchoRequestHeader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain IcmpEchoRequestHeader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["id"]; !ok || v == nil {
		plain.Id = 0.0
	}
	if v, ok := raw["sequence"]; !ok || v == nil {
		plain.Sequence = 0.0
	}
	*j = IcmpEchoRequestHeader(plain)
	return nil
}

// Represents a list of identity group (Ad group SID) expressions.
type IdentityGroupExpression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// This array consists of set of identity group object. All members within this
	// array are implicitly OR'ed together.
	IdentityGroups []IdentityGroupInfo `json:"identity_groups,omitempty" yaml:"identity_groups,omitempty" mapstructure:"identity_groups,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *IdentityGroupExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type IdentityGroupExpressionResourceType string

const IdentityGroupExpressionResourceTypeCondition IdentityGroupExpressionResourceType = "Condition"
const IdentityGroupExpressionResourceTypeConjunctionOperator IdentityGroupExpressionResourceType = "ConjunctionOperator"
const IdentityGroupExpressionResourceTypeExternalIDExpression IdentityGroupExpressionResourceType = "ExternalIDExpression"
const IdentityGroupExpressionResourceTypeIPAddressExpression IdentityGroupExpressionResourceType = "IPAddressExpression"
const IdentityGroupExpressionResourceTypeIdentityGroupExpression IdentityGroupExpressionResourceType = "IdentityGroupExpression"
const IdentityGroupExpressionResourceTypeMACAddressExpression IdentityGroupExpressionResourceType = "MACAddressExpression"
const IdentityGroupExpressionResourceTypeNestedExpression IdentityGroupExpressionResourceType = "NestedExpression"
const IdentityGroupExpressionResourceTypePathExpression IdentityGroupExpressionResourceType = "PathExpression"

var enumValues_IdentityGroupExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IdentityGroupExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IdentityGroupExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IdentityGroupExpressionResourceType, v)
	}
	*j = IdentityGroupExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IdentityGroupExpression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain IdentityGroupExpression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if plain.IdentityGroups != nil && len(plain.IdentityGroups) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "identity_groups", 1)
	}
	if len(plain.IdentityGroups) > 500 {
		return fmt.Errorf("field %s length: must be <= %d", "identity_groups", 500)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = IdentityGroupExpression(plain)
	return nil
}

type IdentityGroupInfo struct {
	// Each LDAP object is uniquely identified by its distinguished name (DN). A DN is
	// a sequence of relative distinguished names (RDN) connected by commas. e.g.
	// CN=Larry Cole,CN=admin,DC=corp,DC=acme,DC=com. A valid fully qualified
	// distinguished name should be provided to include specific groups else the
	// create / update realization of the Group containing an invalid/ partial DN will
	// fail. This value is valid only if it matches to exactly 1 LDAP object on the
	// LDAP server.
	DistinguishedName *string `json:"distinguished_name,omitempty" yaml:"distinguished_name,omitempty" mapstructure:"distinguished_name,omitempty"`

	// This is the base distinguished name for the domain where this particular group
	// resides. (e.g. dc=example,dc=com) Each active directory domain has a domain
	// naming context (NC), which contains domain-specific data. The root of this
	// naming context is represented by a domain's distinguished name (DN) and is
	// typically referred to as the NC head.
	DomainBaseDistinguishedName *string `json:"domain_base_distinguished_name,omitempty" yaml:"domain_base_distinguished_name,omitempty" mapstructure:"domain_base_distinguished_name,omitempty"`

	// A security identifier (SID) is a unique value of variable length used to
	// identify a trustee. A SID consists of the following components: The revision
	// level of the SID structure; A 48-bit identifier authority value that identifies
	// the authority that issued the SID; A variable number of subauthority or
	// relative identifier (RID) values that uniquely identify the trustee relative to
	// the authority that issued the SID. This field is only populated for Microsoft
	// Active Directory identity store.
	Sid *string `json:"sid,omitempty" yaml:"sid,omitempty" mapstructure:"sid,omitempty"`
}

// Intersite gateway configuration.
type IntersiteGatewayConfig struct {
	// Fallback site to be used as new primary site on current primary site failure.
	// Disaster recovery must be initiated via API/UI. Fallback site configuration is
	// supported only for T0 gateway. T1 gateway will follow T0 gateway's primary site
	// during disaster recovery.
	FallbackSites []string `json:"fallback_sites,omitempty" yaml:"fallback_sites,omitempty" mapstructure:"fallback_sites,omitempty"`

	// IPv4 subnet for inter-site transit segment connecting service routers across
	// sites for stretched gateway. For IPv6 link local subnet is auto configured.
	IntersiteTransitSubnet string `json:"intersite_transit_subnet,omitempty" yaml:"intersite_transit_subnet,omitempty" mapstructure:"intersite_transit_subnet,omitempty"`

	// Epoch(in seconds) is auto updated based on system current timestamp when
	// primary locale service is updated. It is used for resolving conflict during
	// site failover. If system clock not in sync then User can optionally override
	// this. New value must be higher than the current value.
	LastAdminActiveEpoch *int `json:"last_admin_active_epoch,omitempty" yaml:"last_admin_active_epoch,omitempty" mapstructure:"last_admin_active_epoch,omitempty"`

	// Primary egress site for gateway. T0/T1 gateway in Active/Standby mode supports
	// stateful services on primary site. In this mode primary site must be set if
	// gateway is stretched to more than one site. For T0 gateway in Active/Active
	// primary site is optional field. If set then secondary site prefers routes
	// learned from primary over locally learned routes. This field is not applicable
	// for T1 gateway with no services.
	PrimarySitePath *string `json:"primary_site_path,omitempty" yaml:"primary_site_path,omitempty" mapstructure:"primary_site_path,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IntersiteGatewayConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain IntersiteGatewayConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["intersite_transit_subnet"]; !ok || v == nil {
		plain.IntersiteTransitSubnet = "169.254.32.0/20"
	}
	*j = IntersiteGatewayConfig(plain)
	return nil
}

type IpAddressInfo struct {
	// IpAddresses corresponds to the JSON schema field "ip_addresses".
	IpAddresses []IPAddress `json:"ip_addresses,omitempty" yaml:"ip_addresses,omitempty" mapstructure:"ip_addresses,omitempty"`

	// Source corresponds to the JSON schema field "source".
	Source *IpAddressInfoSource `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`
}

type IpAddressInfoSource string

const IpAddressInfoSourceVMTOOLS IpAddressInfoSource = "VM_TOOLS"

var enumValues_IpAddressInfoSource = []interface{}{
	"VM_TOOLS",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *IpAddressInfoSource) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_IpAddressInfoSource {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_IpAddressInfoSource, v)
	}
	*j = IpAddressInfoSource(v)
	return nil
}

type Ipv4Header struct {
	// DstIp corresponds to the JSON schema field "dst_ip".
	DstIp *IPAddress `json:"dst_ip,omitempty" yaml:"dst_ip,omitempty" mapstructure:"dst_ip,omitempty"`

	// Flags corresponds to the JSON schema field "flags".
	Flags int `json:"flags,omitempty" yaml:"flags,omitempty" mapstructure:"flags,omitempty"`

	// Protocol corresponds to the JSON schema field "protocol".
	Protocol int `json:"protocol,omitempty" yaml:"protocol,omitempty" mapstructure:"protocol,omitempty"`

	// SrcIp corresponds to the JSON schema field "src_ip".
	SrcIp *IPAddress `json:"src_ip,omitempty" yaml:"src_ip,omitempty" mapstructure:"src_ip,omitempty"`

	// This is used together with src_ip to calculate dst_ip for broadcast when dst_ip
	// is not given; not used in all other cases.
	SrcSubnetPrefixLen *int `json:"src_subnet_prefix_len,omitempty" yaml:"src_subnet_prefix_len,omitempty" mapstructure:"src_subnet_prefix_len,omitempty"`

	// Ttl corresponds to the JSON schema field "ttl".
	Ttl int `json:"ttl,omitempty" yaml:"ttl,omitempty" mapstructure:"ttl,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ipv4Header) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Ipv4Header
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["flags"]; !ok || v == nil {
		plain.Flags = 0.0
	}
	if v, ok := raw["protocol"]; !ok || v == nil {
		plain.Protocol = 1.0
	}
	if v, ok := raw["ttl"]; !ok || v == nil {
		plain.Ttl = 64.0
	}
	*j = Ipv4Header(plain)
	return nil
}

type Ipv6Header struct {
	// DstIp corresponds to the JSON schema field "dst_ip".
	DstIp *IPv6Address `json:"dst_ip,omitempty" yaml:"dst_ip,omitempty" mapstructure:"dst_ip,omitempty"`

	// Decremented by 1 by each node that forwards the packets. The packet is
	// discarded if Hop Limit is decremented to zero.
	HopLimit int `json:"hop_limit,omitempty" yaml:"hop_limit,omitempty" mapstructure:"hop_limit,omitempty"`

	// NextHeader corresponds to the JSON schema field "next_header".
	NextHeader int `json:"next_header,omitempty" yaml:"next_header,omitempty" mapstructure:"next_header,omitempty"`

	// SrcIp corresponds to the JSON schema field "src_ip".
	SrcIp *IPv6Address `json:"src_ip,omitempty" yaml:"src_ip,omitempty" mapstructure:"src_ip,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Ipv6Header) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Ipv6Header
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["hop_limit"]; !ok || v == nil {
		plain.HopLimit = 64.0
	}
	if v, ok := raw["next_header"]; !ok || v == nil {
		plain.NextHeader = 58.0
	}
	*j = Ipv6Header(plain)
	return nil
}

type L2Extension struct {
	// This property has been deprecated. Please use the property l2vpn_paths for
	// setting the paths of associated L2 VPN session. This property will continue to
	// work as expected to provide backwards compatibility. However, when both
	// l2vpn_path and l2vpn_paths properties are specified, only l2vpn_paths is used.
	L2VpnPath *string `json:"l2vpn_path,omitempty" yaml:"l2vpn_path,omitempty" mapstructure:"l2vpn_path,omitempty"`

	// Policy paths corresponding to the associated L2 VPN sessions
	L2VpnPaths []string `json:"l2vpn_paths,omitempty" yaml:"l2vpn_paths,omitempty" mapstructure:"l2vpn_paths,omitempty"`

	// Local Egress.
	LocalEgress *LocalEgress `json:"local_egress,omitempty" yaml:"local_egress,omitempty" mapstructure:"local_egress,omitempty"`

	// TunnelId corresponds to the JSON schema field "tunnel_id".
	TunnelId *int `json:"tunnel_id,omitempty" yaml:"tunnel_id,omitempty" mapstructure:"tunnel_id,omitempty"`
}

// L4PortSet can be specified in comma separated notation of parts. Parts of a
// L4PortSet includes single integer or range of port in hyphen notation. Example
// of a PortSet: "22, 33-70, 44".
type L4PortSetServiceEntry struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Number of values should not exceed 15, ranges count as 2 values.
	DestinationPorts []PortElement `json:"destination_ports,omitempty" yaml:"destination_ports,omitempty" mapstructure:"destination_ports,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// L4Protocol corresponds to the JSON schema field "l4_protocol".
	L4Protocol *L4PortSetServiceEntryL4Protocol `json:"l4_protocol,omitempty" yaml:"l4_protocol,omitempty" mapstructure:"l4_protocol,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *L4PortSetServiceEntryResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Number of values should not exceed 15, ranges count as 2 values.
	SourcePorts []PortElement `json:"source_ports,omitempty" yaml:"source_ports,omitempty" mapstructure:"source_ports,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type L4PortSetServiceEntryL4Protocol string

const L4PortSetServiceEntryL4ProtocolTCP L4PortSetServiceEntryL4Protocol = "TCP"
const L4PortSetServiceEntryL4ProtocolUDP L4PortSetServiceEntryL4Protocol = "UDP"

var enumValues_L4PortSetServiceEntryL4Protocol = []interface{}{
	"TCP",
	"UDP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L4PortSetServiceEntryL4Protocol) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_L4PortSetServiceEntryL4Protocol {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_L4PortSetServiceEntryL4Protocol, v)
	}
	*j = L4PortSetServiceEntryL4Protocol(v)
	return nil
}

type L4PortSetServiceEntryResourceType string

const L4PortSetServiceEntryResourceTypeALGTypeServiceEntry L4PortSetServiceEntryResourceType = "ALGTypeServiceEntry"
const L4PortSetServiceEntryResourceTypeEtherTypeServiceEntry L4PortSetServiceEntryResourceType = "EtherTypeServiceEntry"
const L4PortSetServiceEntryResourceTypeICMPTypeServiceEntry L4PortSetServiceEntryResourceType = "ICMPTypeServiceEntry"
const L4PortSetServiceEntryResourceTypeIGMPTypeServiceEntry L4PortSetServiceEntryResourceType = "IGMPTypeServiceEntry"
const L4PortSetServiceEntryResourceTypeIPProtocolServiceEntry L4PortSetServiceEntryResourceType = "IPProtocolServiceEntry"
const L4PortSetServiceEntryResourceTypeL4PortSetServiceEntry L4PortSetServiceEntryResourceType = "L4PortSetServiceEntry"
const L4PortSetServiceEntryResourceTypeNestedServiceServiceEntry L4PortSetServiceEntryResourceType = "NestedServiceServiceEntry"

var enumValues_L4PortSetServiceEntryResourceType = []interface{}{
	"IPProtocolServiceEntry",
	"IGMPTypeServiceEntry",
	"ICMPTypeServiceEntry",
	"ALGTypeServiceEntry",
	"L4PortSetServiceEntry",
	"EtherTypeServiceEntry",
	"NestedServiceServiceEntry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L4PortSetServiceEntryResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_L4PortSetServiceEntryResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_L4PortSetServiceEntryResourceType, v)
	}
	*j = L4PortSetServiceEntryResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *L4PortSetServiceEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain L4PortSetServiceEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if len(plain.DestinationPorts) > 15 {
		return fmt.Errorf("field %s length: must be <= %d", "destination_ports", 15)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.SourcePorts) > 15 {
		return fmt.Errorf("field %s length: must be <= %d", "source_ports", 15)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = L4PortSetServiceEntry(plain)
	return nil
}

// Local Egress is used on both server and client sites so that the gateway is used
// for N-S traffic and overhead on L2VPN tunnel is reduced.
type LocalEgress struct {
	// Gateway IP for Local Egress. Local egress is enabled only when this list is not
	// empty.
	OptimizedIps []IPAddress `json:"optimized_ips,omitempty" yaml:"optimized_ips,omitempty" mapstructure:"optimized_ips,omitempty"`
}

type LocalEgressRoutingEntry struct {
	// Next hop address for proximity routing.
	NexthopAddress *string `json:"nexthop_address,omitempty" yaml:"nexthop_address,omitempty" mapstructure:"nexthop_address,omitempty"`

	// The destination address of traffic matching a prefix-list is forwarded to the
	// nexthop_address. Traffic matching a prefix list with Action DENY will be
	// dropped. Individual prefix-lists specified could have different actions.
	PrefixListPaths []string `json:"prefix_list_paths,omitempty" yaml:"prefix_list_paths,omitempty" mapstructure:"prefix_list_paths,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LocalEgressRoutingEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain LocalEgressRoutingEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.PrefixListPaths) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "prefix_list_paths", 1)
	}
	*j = LocalEgressRoutingEntry(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *LocalEgress) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain LocalEgress
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.OptimizedIps != nil && len(plain.OptimizedIps) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "optimized_ips", 1)
	}
	if len(plain.OptimizedIps) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "optimized_ips", 1)
	}
	*j = LocalEgress(plain)
	return nil
}

// A MAC address. Must be 6 pairs of hexadecimal digits, upper or lower case,
// separated by colons or dashes. Examples: 01:23:45:67:89:ab, 01-23-45-67-89-AB.
type MACAddress string

// Represents MAC address expressions in the form of an array, to support addition
// of MAC addresses in a group. Avoid creating groups with multiple
// MACAddressExpression. In future releases, group will be restricted to contain a
// single MACAddressExpression. To group MAC addresses, use nested groups instead
// of multiple MACAddressExpression.
type MACAddressExpression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// This array can consist of one or more MAC addresses. Max limit of 4000 MAC
	// addresses applies across all the expressions.
	MacAddresses []MACAddress `json:"mac_addresses,omitempty" yaml:"mac_addresses,omitempty" mapstructure:"mac_addresses,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *MACAddressExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type MACAddressExpressionResourceType string

const MACAddressExpressionResourceTypeCondition MACAddressExpressionResourceType = "Condition"
const MACAddressExpressionResourceTypeConjunctionOperator MACAddressExpressionResourceType = "ConjunctionOperator"
const MACAddressExpressionResourceTypeExternalIDExpression MACAddressExpressionResourceType = "ExternalIDExpression"
const MACAddressExpressionResourceTypeIPAddressExpression MACAddressExpressionResourceType = "IPAddressExpression"
const MACAddressExpressionResourceTypeIdentityGroupExpression MACAddressExpressionResourceType = "IdentityGroupExpression"
const MACAddressExpressionResourceTypeMACAddressExpression MACAddressExpressionResourceType = "MACAddressExpression"
const MACAddressExpressionResourceTypeNestedExpression MACAddressExpressionResourceType = "NestedExpression"
const MACAddressExpressionResourceTypePathExpression MACAddressExpressionResourceType = "PathExpression"

var enumValues_MACAddressExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MACAddressExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_MACAddressExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_MACAddressExpressionResourceType, v)
	}
	*j = MACAddressExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *MACAddressExpression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain MACAddressExpression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if plain.MacAddresses != nil && len(plain.MacAddresses) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "mac_addresses", 1)
	}
	if len(plain.MacAddresses) > 4000 {
		return fmt.Errorf("field %s length: must be <= %d", "mac_addresses", 4000)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = MACAddressExpression(plain)
	return nil
}

type NSServiceElement struct {
	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *NSServiceElementResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`
}

type NSServiceElementResourceType string

const NSServiceElementResourceTypeALGTypeNSService NSServiceElementResourceType = "ALGTypeNSService"
const NSServiceElementResourceTypeEtherTypeNSService NSServiceElementResourceType = "EtherTypeNSService"
const NSServiceElementResourceTypeICMPTypeNSService NSServiceElementResourceType = "ICMPTypeNSService"
const NSServiceElementResourceTypeIGMPTypeNSService NSServiceElementResourceType = "IGMPTypeNSService"
const NSServiceElementResourceTypeIPProtocolNSService NSServiceElementResourceType = "IPProtocolNSService"
const NSServiceElementResourceTypeL4PortSetNSService NSServiceElementResourceType = "L4PortSetNSService"

var enumValues_NSServiceElementResourceType = []interface{}{
	"EtherTypeNSService",
	"IPProtocolNSService",
	"IGMPTypeNSService",
	"ICMPTypeNSService",
	"ALGTypeNSService",
	"L4PortSetNSService",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NSServiceElementResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NSServiceElementResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NSServiceElementResourceType, v)
	}
	*j = NSServiceElementResourceType(v)
	return nil
}

type NdpHeader struct {
	// The IP address of the destination of the solicitation. It MUST NOT be a
	// multicast address.
	DstIp *IPv6Address `json:"dst_ip,omitempty" yaml:"dst_ip,omitempty" mapstructure:"dst_ip,omitempty"`

	// This field specifies the type of the Neighbor discover message being sent.
	// NEIGHBOR_SOLICITATION - Neighbor Solicitation message to discover the
	// link-layer address of an on-link IPv6 node or to confirm a previously
	// determined link-layer address. NEIGHBOR_ADVERTISEMENT - Neighbor Advertisement
	// message in response to a Neighbor Solicitation message.
	MsgType NdpHeaderMsgType `json:"msg_type,omitempty" yaml:"msg_type,omitempty" mapstructure:"msg_type,omitempty"`
}

type NdpHeaderMsgType string

const NdpHeaderMsgTypeNEIGHBORADVERTISEMENT NdpHeaderMsgType = "NEIGHBOR_ADVERTISEMENT"
const NdpHeaderMsgTypeNEIGHBORSOLICITATION NdpHeaderMsgType = "NEIGHBOR_SOLICITATION"

var enumValues_NdpHeaderMsgType = []interface{}{
	"NEIGHBOR_SOLICITATION",
	"NEIGHBOR_ADVERTISEMENT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NdpHeaderMsgType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NdpHeaderMsgType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NdpHeaderMsgType, v)
	}
	*j = NdpHeaderMsgType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NdpHeader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain NdpHeader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["msg_type"]; !ok || v == nil {
		plain.MsgType = "NEIGHBOR_SOLICITATION"
	}
	*j = NdpHeader(plain)
	return nil
}

// Nested expressions is a list of condition expressions that must follow the below
// criteria: 0. Only allowed expressions in a NestedExpression are Condition and
// ConjunctionOperator. 1. A non-empty expression list, must be of odd size. In a
// list, with indices starting from 0, all condition expressions must be at even
// indices, separated by the conjunction expressions AND at odd indices. 2. There
// may be at most 5 condition expressions inside a list. 3. NestedExpressions are
// homogeneous in nature, i.e, all expressions inside a nested expression must have
// the same member type.
type NestedExpression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Expression.
	Expressions []Expression `json:"expressions,omitempty" yaml:"expressions,omitempty" mapstructure:"expressions,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *NestedExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type NestedExpressionResourceType string

const NestedExpressionResourceTypeCondition NestedExpressionResourceType = "Condition"
const NestedExpressionResourceTypeConjunctionOperator NestedExpressionResourceType = "ConjunctionOperator"
const NestedExpressionResourceTypeExternalIDExpression NestedExpressionResourceType = "ExternalIDExpression"
const NestedExpressionResourceTypeIPAddressExpression NestedExpressionResourceType = "IPAddressExpression"
const NestedExpressionResourceTypeIdentityGroupExpression NestedExpressionResourceType = "IdentityGroupExpression"
const NestedExpressionResourceTypeMACAddressExpression NestedExpressionResourceType = "MACAddressExpression"
const NestedExpressionResourceTypeNestedExpression NestedExpressionResourceType = "NestedExpression"
const NestedExpressionResourceTypePathExpression NestedExpressionResourceType = "PathExpression"

var enumValues_NestedExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NestedExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NestedExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NestedExpressionResourceType, v)
	}
	*j = NestedExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NestedExpression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain NestedExpression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if plain.Expressions != nil && len(plain.Expressions) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "expressions", 1)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = NestedExpression(plain)
	return nil
}

type NestedServiceServiceEntry struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// NestedServicePath corresponds to the JSON schema field "nested_service_path".
	NestedServicePath *string `json:"nested_service_path,omitempty" yaml:"nested_service_path,omitempty" mapstructure:"nested_service_path,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *NestedServiceServiceEntryResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type NestedServiceServiceEntryResourceType string

const NestedServiceServiceEntryResourceTypeALGTypeServiceEntry NestedServiceServiceEntryResourceType = "ALGTypeServiceEntry"
const NestedServiceServiceEntryResourceTypeEtherTypeServiceEntry NestedServiceServiceEntryResourceType = "EtherTypeServiceEntry"
const NestedServiceServiceEntryResourceTypeICMPTypeServiceEntry NestedServiceServiceEntryResourceType = "ICMPTypeServiceEntry"
const NestedServiceServiceEntryResourceTypeIGMPTypeServiceEntry NestedServiceServiceEntryResourceType = "IGMPTypeServiceEntry"
const NestedServiceServiceEntryResourceTypeIPProtocolServiceEntry NestedServiceServiceEntryResourceType = "IPProtocolServiceEntry"
const NestedServiceServiceEntryResourceTypeL4PortSetServiceEntry NestedServiceServiceEntryResourceType = "L4PortSetServiceEntry"
const NestedServiceServiceEntryResourceTypeNestedServiceServiceEntry NestedServiceServiceEntryResourceType = "NestedServiceServiceEntry"

var enumValues_NestedServiceServiceEntryResourceType = []interface{}{
	"IPProtocolServiceEntry",
	"IGMPTypeServiceEntry",
	"ICMPTypeServiceEntry",
	"ALGTypeServiceEntry",
	"L4PortSetServiceEntry",
	"EtherTypeServiceEntry",
	"NestedServiceServiceEntry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NestedServiceServiceEntryResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_NestedServiceServiceEntryResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_NestedServiceServiceEntryResourceType, v)
	}
	*j = NestedServiceServiceEntryResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *NestedServiceServiceEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain NestedServiceServiceEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = NestedServiceServiceEntry(plain)
	return nil
}

// The server will populate this field when returing the resource. Ignored on PUT
// and POST.
type OwnerResourceLink struct {
	// Action corresponds to the JSON schema field "action".
	Action *string `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Href corresponds to the JSON schema field "href".
	Href *string `json:"href,omitempty" yaml:"href,omitempty" mapstructure:"href,omitempty"`

	// Custom relation type (follows RFC 5988 where appropriate definitions exist)
	Rel *string `json:"rel,omitempty" yaml:"rel,omitempty" mapstructure:"rel,omitempty"`
}

type PacketData struct {
	// If the requested frame_size is too small (given the payload and traceflow
	// metadata requirement of 16 bytes), the traceflow request will fail with an
	// appropriate message.  The frame will be zero padded to the requested size.
	FrameSize int `json:"frame_size,omitempty" yaml:"frame_size,omitempty" mapstructure:"frame_size,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType PacketDataResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// When this flag is set, traceflow packet will have its destination overwritten
	// as the gateway address of the logical router to which the source logical switch
	// is connected. More specifically: - For ARP request, the target IP will be
	// overwritten as gateway IP if the target   IP is not in the same subnet of
	// gateway. - For ARP response, the target IP and destination MAC will be
	// overwritten as   gateway IP/MAC respectively, if the target IP is not in the
	// same subnet of gateway. - For IP packet, the destination MAC will be
	// overwritten as gateway MAC. However, this flag will not be effective when
	// injecting the traceflow packet to a VLAN backed port. This is because the
	// gateway in this case is a physical gateway that is outside the scope of NSX.
	// Therefore, users need to manually populate the gateway MAC address. If the user
	// still sets this flag in this case, a validation error will be thrown. The
	// scenario where a user injects a packet with a VLAN tag into a parent port is
	// referred to as the traceflow container case. Please note that the value of
	// `routed` depends on the connected network of the child segment rather than the
	// connected network of segment of the parent port in this case. Here is the
	// explanation: The parent port in this context is the port on a segment which is
	// referred to by a SegmentConnectionBindingMap. The bound segment of the
	// SegmentConnectionBindingMap is the child segment. The user-crafted traceflow
	// packet will be directly forwarded to the corresponding child segment of the
	// parent port without interacting with any layer 2 forwarding/layer 3 routing in
	// this scenario. The crafted packet will follow the forwarding/routing polices of
	// the child segment's connected network. For example, if a user injects a crafted
	// packet to port_p, and the segment (seg_p) of port_p is referred to by the
	// binding map m1, where m1 is bound to segment seg_c, and the destination port
	// (port_d) of the packet is the VM vNIC connected to seg_p. Although port_p and
	// port_d are on the same segment, the 'routed' value should be set to true if the
	// user expects the crafted packet to be correctly delivered to the destination.
	// This is because the child segments seg_c and seg_d are on different segments
	// and require router interaction to communicate.
	Routed *bool `json:"routed,omitempty" yaml:"routed,omitempty" mapstructure:"routed,omitempty"`

	// This type takes effect only for IP packet.
	TransportType PacketDataTransportType `json:"transport_type,omitempty" yaml:"transport_type,omitempty" mapstructure:"transport_type,omitempty"`
}

type PacketDataResourceType string

const PacketDataResourceTypeBinaryPacketData PacketDataResourceType = "BinaryPacketData"
const PacketDataResourceTypeFieldsPacketData PacketDataResourceType = "FieldsPacketData"

var enumValues_PacketDataResourceType = []interface{}{
	"BinaryPacketData",
	"FieldsPacketData",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PacketDataResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PacketDataResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PacketDataResourceType, v)
	}
	*j = PacketDataResourceType(v)
	return nil
}

type PacketDataTransportType string

const PacketDataTransportTypeBROADCAST PacketDataTransportType = "BROADCAST"
const PacketDataTransportTypeMULTICAST PacketDataTransportType = "MULTICAST"
const PacketDataTransportTypeUNICAST PacketDataTransportType = "UNICAST"
const PacketDataTransportTypeUNKNOWN PacketDataTransportType = "UNKNOWN"

var enumValues_PacketDataTransportType = []interface{}{
	"BROADCAST",
	"UNICAST",
	"MULTICAST",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PacketDataTransportType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PacketDataTransportType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PacketDataTransportType, v)
	}
	*j = PacketDataTransportType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PacketData) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PacketData
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["frame_size"]; !ok || v == nil {
		plain.FrameSize = 128.0
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "FieldsPacketData"
	}
	if v, ok := raw["transport_type"]; !ok || v == nil {
		plain.TransportType = "UNICAST"
	}
	*j = PacketData(plain)
	return nil
}

// Represents policy path expressions in the form of an array, to support addition
// of objects like groups, segments and policy logical ports in a group.
type PathExpression struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This array can consist of one or more policy paths. Only policy paths of
	// groups, segments and policy logical ports are allowed.
	Paths []string `json:"paths,omitempty" yaml:"paths,omitempty" mapstructure:"paths,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *PathExpressionResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type PathExpressionResourceType string

const PathExpressionResourceTypeCondition PathExpressionResourceType = "Condition"
const PathExpressionResourceTypeConjunctionOperator PathExpressionResourceType = "ConjunctionOperator"
const PathExpressionResourceTypeExternalIDExpression PathExpressionResourceType = "ExternalIDExpression"
const PathExpressionResourceTypeIPAddressExpression PathExpressionResourceType = "IPAddressExpression"
const PathExpressionResourceTypeIdentityGroupExpression PathExpressionResourceType = "IdentityGroupExpression"
const PathExpressionResourceTypeMACAddressExpression PathExpressionResourceType = "MACAddressExpression"
const PathExpressionResourceTypeNestedExpression PathExpressionResourceType = "NestedExpression"
const PathExpressionResourceTypePathExpression PathExpressionResourceType = "PathExpression"

var enumValues_PathExpressionResourceType = []interface{}{
	"Condition",
	"ConjunctionOperator",
	"NestedExpression",
	"IPAddressExpression",
	"MACAddressExpression",
	"ExternalIDExpression",
	"PathExpression",
	"IdentityGroupExpression",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PathExpressionResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PathExpressionResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PathExpressionResourceType, v)
	}
	*j = PathExpressionResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PathExpression) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PathExpression
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if plain.Paths != nil && len(plain.Paths) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "paths", 1)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = PathExpression(plain)
	return nil
}

// Alarm base class of realized policy object
type PolicyAlarmResource struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// ErrorDetails corresponds to the JSON schema field "error_details".
	ErrorDetails *PolicyApiError `json:"error_details,omitempty" yaml:"error_details,omitempty" mapstructure:"error_details,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Message corresponds to the JSON schema field "message".
	Message *string `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// SourceReference corresponds to the JSON schema field "source_reference".
	SourceReference *string `json:"source_reference,omitempty" yaml:"source_reference,omitempty" mapstructure:"source_reference,omitempty"`

	// This field will refer to the source site on which the alarm is generated. This
	// field is populated by GM, when it receives corresponding notification from LM.
	SourceSiteId *string `json:"source_site_id,omitempty" yaml:"source_site_id,omitempty" mapstructure:"source_site_id,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyAlarmResource) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PolicyAlarmResource
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = PolicyAlarmResource(plain)
	return nil
}

type PolicyApiError struct {
	// Details corresponds to the JSON schema field "details".
	Details *string `json:"details,omitempty" yaml:"details,omitempty" mapstructure:"details,omitempty"`

	// ErrorCode corresponds to the JSON schema field "error_code".
	ErrorCode *int `json:"error_code,omitempty" yaml:"error_code,omitempty" mapstructure:"error_code,omitempty"`

	// ErrorData corresponds to the JSON schema field "error_data".
	ErrorData PolicyApiErrorErrorData `json:"error_data,omitempty" yaml:"error_data,omitempty" mapstructure:"error_data,omitempty"`

	// ErrorMessage corresponds to the JSON schema field "error_message".
	ErrorMessage *string `json:"error_message,omitempty" yaml:"error_message,omitempty" mapstructure:"error_message,omitempty"`

	// ModuleName corresponds to the JSON schema field "module_name".
	ModuleName *string `json:"module_name,omitempty" yaml:"module_name,omitempty" mapstructure:"module_name,omitempty"`

	// RelatedErrors corresponds to the JSON schema field "related_errors".
	RelatedErrors []PolicyRelatedApiError `json:"related_errors,omitempty" yaml:"related_errors,omitempty" mapstructure:"related_errors,omitempty"`
}

type PolicyApiErrorErrorData map[string]interface{}

// Represents NAT section. This object is created by default when corresponding
// tier-0/tier-1 is created. Under tier-0/tier-1 there will be 4 different
// NATs(sections). (INTERNAL, USER, DEFAULT and NAT64).
type PolicyNat struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// Represents a NAT section under tier-0/tier-1.
	NatType *PolicyNatNatType `json:"nat_type,omitempty" yaml:"nat_type,omitempty" mapstructure:"nat_type,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type PolicyNatNatType string

const PolicyNatNatTypeDEFAULT PolicyNatNatType = "DEFAULT"
const PolicyNatNatTypeINTERNAL PolicyNatNatType = "INTERNAL"
const PolicyNatNatTypeNAT64 PolicyNatNatType = "NAT64"
const PolicyNatNatTypeUSER PolicyNatNatType = "USER"

var enumValues_PolicyNatNatType = []interface{}{
	"INTERNAL",
	"USER",
	"DEFAULT",
	"NAT64",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyNatNatType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyNatNatType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyNatNatType, v)
	}
	*j = PolicyNatNatType(v)
	return nil
}

// Represents a NAT rule between source and destination at T0/T1 router.
type PolicyNatRule struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Source NAT(SNAT) - translates a source IP address in an outbound packet so that
	// the packet appears to originate from a different network. SNAT is only
	// supported when the logical router is running in active-standby mode.
	// Destination NAT(DNAT) - translates the destination IP address of inbound
	// packets so that packets are delivered to a target address into another network.
	// DNAT is only supported when the logical router is running in active-standby
	// mode. Reflexive NAT(REFLEXIVE) - IP-Range and CIDR are supported to define the
	// "n". The number of original networks should be exactly the same as that of
	// translated networks. The address translation is deterministic. Reflexive is
	// supported on both Active/Standby and Active/Active LR. NO_SNAT and NO_DNAT -
	// These do not have support for translated_fields, only source_network and
	// destination_network fields are supported. NAT64 - translates an external IPv6
	// address to a internal IPv4 address.
	Action *PolicyNatRuleAction `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// This supports single IP address or comma separated list of single IP addresses
	// or CIDR. This does not support IP range or IP sets. For DNAT and NO_DNAT rules,
	// this is a mandatory field, and represents the destination network for the
	// incoming packets. For other type of rules, optionally it can contain
	// destination network of outgoing packets. NULL value for this field represents
	// ANY network. For VPC DNAT NATRule, destination network address should be IPv4
	// address allocated from External Block associated with VPC.
	DestinationNetwork *IPElementList `json:"destination_network,omitempty" yaml:"destination_network,omitempty" mapstructure:"destination_network,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// The flag, which suggests whether the NAT rule is enabled or disabled. The
	// default is True.
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// It indicates how the firewall matches the address after NATing if firewall
	// stage is not skipped.  MATCH_EXTERNAL_ADDRESS indicates the firewall will be
	// applied to external address of a NAT rule. For SNAT, the external address is
	// the translated source address after NAT is done. For DNAT, the external address
	// is the original destination address before NAT is done. For REFLEXIVE, to
	// egress traffic, the firewall will be applied to the translated source address
	// after NAT is done; To ingress traffic, the firewall will be applied to the
	// original destination address before NAT is done.  MATCH_INTERNAL_ADDRESS
	// indicates the firewall will be applied to internal address of a NAT rule. For
	// SNAT, the internal address is the original source address before NAT is done.
	// For DNAT, the internal address is the translated destination address after NAT
	// is done. For REFLEXIVE, to egress traffic, the firewall will be applied to the
	// original source address before NAT is done; To ingress traffic, the firewall
	// will be applied to the translated destination address after NAT is done.
	// BYPASS indicates the firewall stage will be skipped.  For NO_SNAT or NO_DNAT,
	// it must be BYPASS or leave it unassigned
	FirewallMatch PolicyNatRuleFirewallMatch `json:"firewall_match,omitempty" yaml:"firewall_match,omitempty" mapstructure:"firewall_match,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// The flag, which suggests whether the logging of NAT rule is enabled or
	// disabled. The default is False.
	Logging bool `json:"logging,omitempty" yaml:"logging,omitempty" mapstructure:"logging,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// It indicates how the NSX edge applies Nat Policy for VPN traffic. It is
	// supported only for Nat Rule action type DNAT and NO_DNAT. For all other NAT
	// action, leave it unassigned. BYPASS - Default vpn mode. It indicates that Nat
	// policy will be applied to the inbound traffic          on Routed Based VPN
	// tunnel, if the policy based VTI is in the "scope" for this rule.
	// Default value will be set to BYPASS if MATCH - It indicates that this NAT rule
	// will only match the Policy Based VPN traffic.
	PolicyBasedVpnMode *PolicyNatRulePolicyBasedVpnMode `json:"policy_based_vpn_mode,omitempty" yaml:"policy_based_vpn_mode,omitempty" mapstructure:"policy_based_vpn_mode,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Represents the array of policy paths of ProviderInterface or NetworkInterface
	// or labels of type ProviderInterface or NetworkInterface or IPSecVpnSession on
	// which the NAT rule should get enforced. The interfaces must belong to the same
	// router for which the NAT Rule is created.
	Scope []string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// The sequence_number decides the rule_priority of a NAT rule. Sequence_number
	// and rule_priority have 1:1 mapping.For each NAT section, there will be reserved
	// rule_priority numbers.The valid range of rule_priority number is from 0 to
	// 2147483647(MAX_INT). 1. INTERNAL section     rule_priority reserved from 0 -
	// 1023 (1024 rules)     valid sequence_number range  0 - 1023 2. USER section
	// rule_priority reserved from 1024 - 2147482623 (2147481600 rules)    valid
	// sequence_number range  0 - 2147481599 3. DEFAULT section    rule_priority
	// reserved from 2147482624 - 2147483647 (1024 rules)    valid sequence_number
	// range  0 - 1023
	SequenceNumber int `json:"sequence_number,omitempty" yaml:"sequence_number,omitempty" mapstructure:"sequence_number,omitempty"`

	// It represents the path of Service on which the NAT rule will be applied. If not
	// provided or if it is blank then Policy manager will consider it as ANY. Please
	// note, if this is a DNAT, the destination_port of the service will be realized
	// on NSX Manager as the translated_port. And if this is a SNAT, the
	// destination_port will be ignored.
	Service *string `json:"service,omitempty" yaml:"service,omitempty" mapstructure:"service,omitempty"`

	// This supports single IP address or comma separated list of single IP addresses
	// or CIDR. This does not support IP range or IP sets. For SNAT, NO_SNAT, NAT64
	// and REFLEXIVE rules, this is a mandatory field and represents the source
	// network of the packets leaving the network. For DNAT and NO_DNAT rules,
	// optionally it can contain source network of incoming packets. NULL value for
	// this field represents ANY network.
	SourceNetwork *IPElementList `json:"source_network,omitempty" yaml:"source_network,omitempty" mapstructure:"source_network,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This supports single IP address or comma separated list of single IP addresses
	// or CIDR. If user specify the CIDR, this value is actually used as an IP pool
	// that includes both the subnet and broadcast addresses as valid for NAT
	// translations. This does not support IP range or IP sets. Comma separated list
	// of single IP addresses is not suported for DNAT and REFLEXIVE rules. For SNAT,
	// DNAT, NAT64 and REFLEXIVE rules, this ia a mandatory field, which represents
	// the translated network address. For NO_SNAT and NO_DNAT this should be empty.
	// For VPC SNAT and Refelexive NATRule, translated network address should be IPv4
	// address allocated from External Block associated with VPC.
	TranslatedNetwork *IPElementList `json:"translated_network,omitempty" yaml:"translated_network,omitempty" mapstructure:"translated_network,omitempty"`

	// Please note, if there is service configured in this NAT rule, the
	// translated_port will be realized on NSX Manager as the destination_port. If
	// there is no sevice configured, the port will be ignored.
	TranslatedPorts *PortElement `json:"translated_ports,omitempty" yaml:"translated_ports,omitempty" mapstructure:"translated_ports,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type PolicyNatRuleAction string

const PolicyNatRuleActionDNAT PolicyNatRuleAction = "DNAT"
const PolicyNatRuleActionNAT64 PolicyNatRuleAction = "NAT64"
const PolicyNatRuleActionNODNAT PolicyNatRuleAction = "NO_DNAT"
const PolicyNatRuleActionNOSNAT PolicyNatRuleAction = "NO_SNAT"
const PolicyNatRuleActionREFLEXIVE PolicyNatRuleAction = "REFLEXIVE"
const PolicyNatRuleActionSNAT PolicyNatRuleAction = "SNAT"

var enumValues_PolicyNatRuleAction = []interface{}{
	"SNAT",
	"DNAT",
	"REFLEXIVE",
	"NO_SNAT",
	"NO_DNAT",
	"NAT64",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyNatRuleAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyNatRuleAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyNatRuleAction, v)
	}
	*j = PolicyNatRuleAction(v)
	return nil
}

type PolicyNatRuleFirewallMatch string

const PolicyNatRuleFirewallMatchBYPASS PolicyNatRuleFirewallMatch = "BYPASS"
const PolicyNatRuleFirewallMatchMATCHEXTERNALADDRESS PolicyNatRuleFirewallMatch = "MATCH_EXTERNAL_ADDRESS"
const PolicyNatRuleFirewallMatchMATCHINTERNALADDRESS PolicyNatRuleFirewallMatch = "MATCH_INTERNAL_ADDRESS"

var enumValues_PolicyNatRuleFirewallMatch = []interface{}{
	"MATCH_EXTERNAL_ADDRESS",
	"MATCH_INTERNAL_ADDRESS",
	"BYPASS",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyNatRuleFirewallMatch) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyNatRuleFirewallMatch {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyNatRuleFirewallMatch, v)
	}
	*j = PolicyNatRuleFirewallMatch(v)
	return nil
}

type PolicyNatRulePolicyBasedVpnMode string

const PolicyNatRulePolicyBasedVpnModeBYPASS PolicyNatRulePolicyBasedVpnMode = "BYPASS"
const PolicyNatRulePolicyBasedVpnModeMATCH PolicyNatRulePolicyBasedVpnMode = "MATCH"

var enumValues_PolicyNatRulePolicyBasedVpnMode = []interface{}{
	"BYPASS",
	"MATCH",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyNatRulePolicyBasedVpnMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyNatRulePolicyBasedVpnMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyNatRulePolicyBasedVpnMode, v)
	}
	*j = PolicyNatRulePolicyBasedVpnMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyNatRule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PolicyNatRule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		plain.Enabled = true
	}
	if v, ok := raw["firewall_match"]; !ok || v == nil {
		plain.FirewallMatch = "MATCH_INTERNAL_ADDRESS"
	}
	if v, ok := raw["logging"]; !ok || v == nil {
		plain.Logging = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if v, ok := raw["sequence_number"]; !ok || v == nil {
		plain.SequenceNumber = 0.0
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = PolicyNatRule(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyNat) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PolicyNat
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = PolicyNat(plain)
	return nil
}

type PolicyRelatedApiError struct {
	// Details corresponds to the JSON schema field "details".
	Details *string `json:"details,omitempty" yaml:"details,omitempty" mapstructure:"details,omitempty"`

	// ErrorCode corresponds to the JSON schema field "error_code".
	ErrorCode *int `json:"error_code,omitempty" yaml:"error_code,omitempty" mapstructure:"error_code,omitempty"`

	// ErrorData corresponds to the JSON schema field "error_data".
	ErrorData PolicyRelatedApiErrorErrorData `json:"error_data,omitempty" yaml:"error_data,omitempty" mapstructure:"error_data,omitempty"`

	// ErrorMessage corresponds to the JSON schema field "error_message".
	ErrorMessage *string `json:"error_message,omitempty" yaml:"error_message,omitempty" mapstructure:"error_message,omitempty"`

	// ModuleName corresponds to the JSON schema field "module_name".
	ModuleName *string `json:"module_name,omitempty" yaml:"module_name,omitempty" mapstructure:"module_name,omitempty"`
}

type PolicyRelatedApiErrorErrorData map[string]interface{}

// Optional API Request Parameter to be used in HAPI.
type PolicyRequestParameter struct {
	// The type of this request parameter.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`
}

type PolicyTraceflowObservationDelivered struct {
	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// The path of the interface into which the traceflow packet was delivered (e.g.,
	// Tier0 Interface, Tier1 Interface, Service Interface, and Virtual Tunnel
	// Interface).
	//
	InterfacePath *string `json:"interface_path,omitempty" yaml:"interface_path,omitempty" mapstructure:"interface_path,omitempty"`

	// LportId corresponds to the JSON schema field "lport_id".
	LportId *string `json:"lport_id,omitempty" yaml:"lport_id,omitempty" mapstructure:"lport_id,omitempty"`

	// LportName corresponds to the JSON schema field "lport_name".
	LportName *string `json:"lport_name,omitempty" yaml:"lport_name,omitempty" mapstructure:"lport_name,omitempty"`

	// The port path of the corresponding parent port for current deliver observation
	// point.
	//
	ParentPortPath *string `json:"parent_port_path,omitempty" yaml:"parent_port_path,omitempty" mapstructure:"parent_port_path,omitempty"`

	// This field specifies the resolution type of ARP ARP_SUPPRESSION_PORT_CACHE -
	// ARP request is suppressed by IP table. ARP_SUPPRESSION_TABLE - ARP request is
	// suppressed by ARP table. ARP_SUPPRESSION_CP_QUERY - ARP request is suppressed
	// by info derived from CP. ARP_VM - No suppression and the ARP request is
	// resolved by VM. ARP_LRP - No suppression and the ARP request is resolved by
	// logical router.
	ResolutionType *PolicyTraceflowObservationDeliveredResolutionType `json:"resolution_type,omitempty" yaml:"resolution_type,omitempty" mapstructure:"resolution_type,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// The path of the segment port into
	// which the traceflow packet was delivered.
	//
	SegmentPortPath *string `json:"segment_port_path,omitempty" yaml:"segment_port_path,omitempty" mapstructure:"segment_port_path,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// The source MAC address of form: "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$".
	// For example: 00:00:00:00:00:00.
	TargetMac *string `json:"target_mac,omitempty" yaml:"target_mac,omitempty" mapstructure:"target_mac,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`

	// VlanId corresponds to the JSON schema field "vlan_id".
	VlanId *VlanID `json:"vlan_id,omitempty" yaml:"vlan_id,omitempty" mapstructure:"vlan_id,omitempty"`
}

type PolicyTraceflowObservationDeliveredResolutionType string

const PolicyTraceflowObservationDeliveredResolutionTypeARPLRP PolicyTraceflowObservationDeliveredResolutionType = "ARP_LRP"
const PolicyTraceflowObservationDeliveredResolutionTypeARPSUPPRESSIONCPQUERY PolicyTraceflowObservationDeliveredResolutionType = "ARP_SUPPRESSION_CP_QUERY"
const PolicyTraceflowObservationDeliveredResolutionTypeARPSUPPRESSIONPORTCACHE PolicyTraceflowObservationDeliveredResolutionType = "ARP_SUPPRESSION_PORT_CACHE"
const PolicyTraceflowObservationDeliveredResolutionTypeARPSUPPRESSIONTABLE PolicyTraceflowObservationDeliveredResolutionType = "ARP_SUPPRESSION_TABLE"
const PolicyTraceflowObservationDeliveredResolutionTypeARPVM PolicyTraceflowObservationDeliveredResolutionType = "ARP_VM"
const PolicyTraceflowObservationDeliveredResolutionTypeUNKNOWN PolicyTraceflowObservationDeliveredResolutionType = "UNKNOWN"

var enumValues_PolicyTraceflowObservationDeliveredResolutionType = []interface{}{
	"UNKNOWN",
	"ARP_SUPPRESSION_PORT_CACHE",
	"ARP_SUPPRESSION_TABLE",
	"ARP_SUPPRESSION_CP_QUERY",
	"ARP_VM",
	"ARP_LRP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationDeliveredResolutionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyTraceflowObservationDeliveredResolutionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyTraceflowObservationDeliveredResolutionType, v)
	}
	*j = PolicyTraceflowObservationDeliveredResolutionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationDelivered) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PolicyTraceflowObservationDelivered
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = PolicyTraceflowObservationDelivered(plain)
	return nil
}

type PolicyTraceflowObservationDropped struct {
	// This field is specified when the traceflow packet matched a L3 firewall rule.
	AclRuleId *int `json:"acl_rule_id,omitempty" yaml:"acl_rule_id,omitempty" mapstructure:"acl_rule_id,omitempty"`

	// The path of the ACL rule that was applied to forward the traceflow packet
	AclRulePath *string `json:"acl_rule_path,omitempty" yaml:"acl_rule_path,omitempty" mapstructure:"acl_rule_path,omitempty"`

	// This field specifies the ARP fails reason ARP_TIMEOUT - ARP failure due to
	// query control plane timeout ARP_CPFAIL - ARP failure due post ARP query message
	// to control plane failure ARP_FROMCP - ARP failure due to deleting ARP entry
	// from control plane ARP_PORTDESTROY - ARP failure due to port destruction
	// ARP_TABLEDESTROY - ARP failure due to ARP table destruction ARP_NETDESTROY -
	// ARP failure due to overlay network destruction
	ArpFailReason *PolicyTraceflowObservationDroppedArpFailReason `json:"arp_fail_reason,omitempty" yaml:"arp_fail_reason,omitempty" mapstructure:"arp_fail_reason,omitempty"`

	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// The path of the interface at which the traceflow packet was dropped (e.g.,
	// Tier0 Interface, Tier1 Interface, Service Interface, and Virtual Tunnel
	// Interface).
	//
	InterfacePath *string `json:"interface_path,omitempty" yaml:"interface_path,omitempty" mapstructure:"interface_path,omitempty"`

	// This field specifies the IPSec VPN fails reason IPSEC_SA_NOT_FOUND   - IPSec SA
	// required for processing the packet does not exist IPSEC_UDP_ENC_STATE_MISMATCH
	// - ESP packet is UDP encapsulated but IPsec SA does not expect UDP encapsulation
	// IPSEC_SEQ_ROLLOVER   - IPSec SA sequence number has exceeded the maximum value
	// IPSEC_FRAG_NEEDED   - Received packet has DF bit set in IP header but requires
	// fragmentation due to ESP encapsulation IPSEC_TUN_IFACE_DOWN   - IPSec tunnel
	// interface is down IPSEC_POLICY_NOMATCH   - Received packet does not match IPSec
	// policy IPSEC_POLICY_BLOCK   - IPSec packet processing failed IPSEC_POLICY_ERROR
	// - IPSec packet processing failed IPSEC_REPLAY_SEQ_NUM_REPEAT   - IPSec packet
	// is dropped due to replay IPSEC_REPLAY_RECV_DELAY   - IPSec packet is dropped
	// due to replay IPSEC_REPLAY_PROC_DELAY   - IPSec packet is dropped due to replay
	// IPSEC_ZERO_SEQ_NUM_RECVD   - ESP packet is received with sequence number as
	// zero IPSEC_ENQUEUE_FAIL   - Packet processing failed during crypto operation
	// IPSEC_AUTH_DGST_MISMATCH   - Packet integrity check failed due to digest
	// mismatch IPSEC_AUTH_DGST_SIZE_MISMATCH   - Packet integrity check failed due to
	// invalid digest length IPSEC_AUTH_UNSUPPORTED_ALGO   - Packet integrity check
	// failed due to unsupported hash algorithm IPSEC_CRYPTO_FAIL   - Packet
	// processing failed during crypto operation IPSEC_CRYPTO_PROC_INCOMPLETE   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_SESSION_INV   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_ARGS_INV   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_PROC_ERROR   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_NO_BUF_SPACE   -
	// Packet processing failed during crypto operation
	// IPSEC_CRYPTO_UNSUPPORTED_CIPHER   - Packet processing failed during crypto
	// operation IPSEC_MALFORMED   - Received ESP packet is malformed
	// IPSEC_MALFORMED_INV_PADDING   - Received ESP packet is malformed
	// IPSEC_PADDING_REMOVAL_FAILED   - Received ESP packet is malformed
	// IPSEC_INNER_MALFORMED   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_IP   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_UDP   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_TCP   - IP packet after ESP decryption is malformed
	// IPSEC_UNKNOWN   - IPSec VPN failure reason is unknown
	IpsecFailReason *PolicyTraceflowObservationDroppedIpsecFailReason `json:"ipsec_fail_reason,omitempty" yaml:"ipsec_fail_reason,omitempty" mapstructure:"ipsec_fail_reason,omitempty"`

	// This field is specified when the traceflow packet matched a jump-to rule.
	JumptoRuleId *int `json:"jumpto_rule_id,omitempty" yaml:"jumpto_rule_id,omitempty" mapstructure:"jumpto_rule_id,omitempty"`

	// This field is specified when the traceflow packet matched a l2 rule.
	L2RuleId *int `json:"l2_rule_id,omitempty" yaml:"l2_rule_id,omitempty" mapstructure:"l2_rule_id,omitempty"`

	// LportId corresponds to the JSON schema field "lport_id".
	LportId *string `json:"lport_id,omitempty" yaml:"lport_id,omitempty" mapstructure:"lport_id,omitempty"`

	// LportName corresponds to the JSON schema field "lport_name".
	LportName *string `json:"lport_name,omitempty" yaml:"lport_name,omitempty" mapstructure:"lport_name,omitempty"`

	// This field is specified when the traceflow packet matched a NAT rule.
	NatRuleId *int `json:"nat_rule_id,omitempty" yaml:"nat_rule_id,omitempty" mapstructure:"nat_rule_id,omitempty"`

	// The path of the NAT rule that was applied to forward the traceflow packet
	NatRulePath *string `json:"nat_rule_path,omitempty" yaml:"nat_rule_path,omitempty" mapstructure:"nat_rule_path,omitempty"`

	// This field specifies the drop reason of traceflow packet. ARP_FAIL - ARP
	// request fails for some reasons, please refer arp_fail_reason for detail BFD -
	// BFD packet is dropped because traversed by non-operative interface or
	// encountering internal error (e.g., memory insufficient) BROADCAST - Packet is
	// dropped during traversing the interface (e.g., Edge uplink, Edge centralized
	// service port) which disallow ethernet broadcast DHCP - DHCP packet is malformed
	// DLB - The packet is disallowed by distributed load balancing FW_RULE - The
	// packet matches a drop or reject rule of DFW or Edge firewall GENEVE - GENEVE
	// packet is malformed GRE - GRE packet is malformed or traverses a non-operative
	// interface IFACE - Packet traverses a non-operative interface IP - Packet is
	// dropped because of IP related causes (e.g., ICMPv4/ICMPv6 packet is malformed,
	// or DF flag is set but fragment must be performed for the packet) or
	// corresponding interface is not found or inoperative IP_REASS - Packet is
	// dropped during IP reassembly IPSEC - IPsec protocol related packet is dropped
	// IPSEC_VTI - IPsec required SA is not found or traversing inoperative interface
	// cause packet dropped L2VPN - VLAN id of GRE packet is invalid L4PORT - Layer 4
	// packet (e.g., BFD, DHCP) is dropped LB - Packet is dropped by load balancing
	// rule LROUTER - Packet is dropped by logical router LSERVICE - Packet is
	// malformed or traverses inoperative logical service interface LSWITCH - Packet
	// is dropped by logical switch MANAGEMENT - Packet is dropped by Edge datapath
	// MANAGEMENT service port MD_PROXY - Packet is dropped by metadata proxy NAT -
	// Packet is dropped by NAT rule RTEP_TUNNEL - Unused drop reason ND_NS_FAIL -
	// Neighbor Discovery packet fails NEIGH - ARP or Neighbor Discovery packet fails
	// NO_EIP_FOUND - Destination IP is not an elastic IP NO_EIP_ASSOCIATION - Elastic
	// IP is not associated with active edge VDR ENI NO_ENI_FOR_IP - There is no ENI
	// found for the destination IP NO_ENI_FOR_LIF - Cannot find an ENI associated
	// with uplink LIF NO_ROUTE - Cannot find route for destination IP
	// NO_ROUTE_TABLE_FOUND - Cannot find associated route table
	// NO_UNDERLAY_ROUTE_FOUND - Cannot find AWS route to destination NOT_VDR_DOWNLINK
	// - Packet is not forwarded to VMC unmanaged VDR downlink NO_VDR_FOUND - VMC
	// unmanaged VDR associated with Edge uplink is not found NO_VDR_ON_HOST - Cannot
	// find VMC unmanaged VDR list on this host NOT_VDR_UPLINK - Packet is not
	// forwarded to VDR uplink SERVICE_INSERT - Packet from guest VM to service VM or
	// from service VM to guest VM is dropped by firewall rule SPOOFGUARD - Packet is
	// blocked by SpoofGuard policy TTL_ZERO - The IPv4 time to live field or the IPv6
	// hop limit field of packet is zero TUNNEL - Overlay tunnel management packet
	// (VNI value of GENEVE header is 0, e.g., BFD) is dropped VLAN - VLAN id of
	// packet is disallowed by the given port VXLAN - VXLAN packet is malformed or
	// cannot find tunnel port for it VXSTT - Unused drop reason VMC_NO_RESPONSE -
	// Failed to query VMC observations as no response from VMC app WRONG_UPLINK -
	// Packet is not routed to the expected Edge uplink by VMC unmanaged VDR FW_STATE
	// - Packet is dropped by stateful firewall NO_MAC - Drop by vswitch as no
	// destination MAC hit MAC Table. FILTERED_UPLINK - Filtering applied at the
	// corresponding UPLINK having no aggregation.
	Reason *PolicyTraceflowObservationDroppedReason `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// The path of the segment port at which the
	// traceflow packet was dropped.
	//
	SegmentPortPath *string `json:"segment_port_path,omitempty" yaml:"segment_port_path,omitempty" mapstructure:"segment_port_path,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`
}

type PolicyTraceflowObservationDroppedArpFailReason string

const PolicyTraceflowObservationDroppedArpFailReasonARPCPFAIL PolicyTraceflowObservationDroppedArpFailReason = "ARP_CPFAIL"
const PolicyTraceflowObservationDroppedArpFailReasonARPFROMCP PolicyTraceflowObservationDroppedArpFailReason = "ARP_FROMCP"
const PolicyTraceflowObservationDroppedArpFailReasonARPNETDESTROY PolicyTraceflowObservationDroppedArpFailReason = "ARP_NETDESTROY"
const PolicyTraceflowObservationDroppedArpFailReasonARPPORTDESTROY PolicyTraceflowObservationDroppedArpFailReason = "ARP_PORTDESTROY"
const PolicyTraceflowObservationDroppedArpFailReasonARPTABLEDESTROY PolicyTraceflowObservationDroppedArpFailReason = "ARP_TABLEDESTROY"
const PolicyTraceflowObservationDroppedArpFailReasonARPTIMEOUT PolicyTraceflowObservationDroppedArpFailReason = "ARP_TIMEOUT"
const PolicyTraceflowObservationDroppedArpFailReasonARPUNKNOWN PolicyTraceflowObservationDroppedArpFailReason = "ARP_UNKNOWN"

var enumValues_PolicyTraceflowObservationDroppedArpFailReason = []interface{}{
	"ARP_UNKNOWN",
	"ARP_TIMEOUT",
	"ARP_CPFAIL",
	"ARP_FROMCP",
	"ARP_PORTDESTROY",
	"ARP_TABLEDESTROY",
	"ARP_NETDESTROY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationDroppedArpFailReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyTraceflowObservationDroppedArpFailReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyTraceflowObservationDroppedArpFailReason, v)
	}
	*j = PolicyTraceflowObservationDroppedArpFailReason(v)
	return nil
}

type PolicyTraceflowObservationDroppedIpsecFailReason string

const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECAUTHDGSTMISMATCH PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_AUTH_DGST_MISMATCH"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECAUTHDGSTSIZEMISMATCH PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_AUTH_DGST_SIZE_MISMATCH"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECAUTHUNSUPPORTEDALGO PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_AUTH_UNSUPPORTED_ALGO"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOARGSINV PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_ARGS_INV"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOFAIL PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_FAIL"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECCRYPTONOBUFSPACE PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_NO_BUF_SPACE"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOPROCERROR PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_PROC_ERROR"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOPROCINCOMPLETE PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_PROC_INCOMPLETE"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOSESSIONINV PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_SESSION_INV"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOUNSUPPORTEDCIPHER PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_UNSUPPORTED_CIPHER"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECENQUEUEFAIL PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_ENQUEUE_FAIL"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECFRAGNEEDED PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_FRAG_NEEDED"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECINNERMALFORMED PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_INNER_MALFORMED"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECINNERMALFORMEDIP PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_INNER_MALFORMED_IP"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECINNERMALFORMEDTCP PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_INNER_MALFORMED_TCP"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECINNERMALFORMEDUDP PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_INNER_MALFORMED_UDP"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECMALFORMED PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_MALFORMED"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECMALFORMEDINVPADDING PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_MALFORMED_INV_PADDING"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECPADDINGREMOVALFAILED PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_PADDING_REMOVAL_FAILED"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECPOLICYBLOCK PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_POLICY_BLOCK"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECPOLICYERROR PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_POLICY_ERROR"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECPOLICYNOMATCH PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_POLICY_NOMATCH"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECREPLAYPROCDELAY PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_REPLAY_PROC_DELAY"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECREPLAYRECVDELAY PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_REPLAY_RECV_DELAY"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECREPLAYSEQNUMREPEAT PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_REPLAY_SEQ_NUM_REPEAT"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECSANOTFOUND PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_SA_NOT_FOUND"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECSEQROLLOVER PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_SEQ_ROLLOVER"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECTUNIFACEDOWN PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_TUN_IFACE_DOWN"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECUDPENCSTATEMISMATCH PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_UDP_ENC_STATE_MISMATCH"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECUNKNOWN PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_UNKNOWN"
const PolicyTraceflowObservationDroppedIpsecFailReasonIPSECZEROSEQNUMRECVD PolicyTraceflowObservationDroppedIpsecFailReason = "IPSEC_ZERO_SEQ_NUM_RECVD"

var enumValues_PolicyTraceflowObservationDroppedIpsecFailReason = []interface{}{
	"IPSEC_SA_NOT_FOUND",
	"IPSEC_UDP_ENC_STATE_MISMATCH",
	"IPSEC_SEQ_ROLLOVER",
	"IPSEC_FRAG_NEEDED",
	"IPSEC_TUN_IFACE_DOWN",
	"IPSEC_POLICY_NOMATCH",
	"IPSEC_POLICY_BLOCK",
	"IPSEC_POLICY_ERROR",
	"IPSEC_REPLAY_SEQ_NUM_REPEAT",
	"IPSEC_REPLAY_RECV_DELAY",
	"IPSEC_REPLAY_PROC_DELAY",
	"IPSEC_ZERO_SEQ_NUM_RECVD",
	"IPSEC_ENQUEUE_FAIL",
	"IPSEC_AUTH_DGST_MISMATCH",
	"IPSEC_AUTH_DGST_SIZE_MISMATCH",
	"IPSEC_AUTH_UNSUPPORTED_ALGO",
	"IPSEC_CRYPTO_FAIL",
	"IPSEC_CRYPTO_PROC_INCOMPLETE",
	"IPSEC_CRYPTO_SESSION_INV",
	"IPSEC_CRYPTO_ARGS_INV",
	"IPSEC_CRYPTO_PROC_ERROR",
	"IPSEC_CRYPTO_NO_BUF_SPACE",
	"IPSEC_CRYPTO_UNSUPPORTED_CIPHER",
	"IPSEC_MALFORMED",
	"IPSEC_MALFORMED_INV_PADDING",
	"IPSEC_PADDING_REMOVAL_FAILED",
	"IPSEC_INNER_MALFORMED",
	"IPSEC_INNER_MALFORMED_IP",
	"IPSEC_INNER_MALFORMED_UDP",
	"IPSEC_INNER_MALFORMED_TCP",
	"IPSEC_UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationDroppedIpsecFailReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyTraceflowObservationDroppedIpsecFailReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyTraceflowObservationDroppedIpsecFailReason, v)
	}
	*j = PolicyTraceflowObservationDroppedIpsecFailReason(v)
	return nil
}

type PolicyTraceflowObservationDroppedLogical struct {
	// This field is specified when the traceflow packet matched a L3 firewall rule.
	AclRuleId *int `json:"acl_rule_id,omitempty" yaml:"acl_rule_id,omitempty" mapstructure:"acl_rule_id,omitempty"`

	// The path of the ACL rule that was applied to forward the traceflow packet
	AclRulePath *string `json:"acl_rule_path,omitempty" yaml:"acl_rule_path,omitempty" mapstructure:"acl_rule_path,omitempty"`

	// This field specifies the ARP fails reason ARP_TIMEOUT - ARP failure due to
	// query control plane timeout ARP_CPFAIL - ARP failure due post ARP query message
	// to control plane failure ARP_FROMCP - ARP failure due to deleting ARP entry
	// from control plane ARP_PORTDESTROY - ARP failure due to port destruction
	// ARP_TABLEDESTROY - ARP failure due to ARP table destruction ARP_NETDESTROY -
	// ARP failure due to overlay network destruction
	ArpFailReason *PolicyTraceflowObservationDroppedLogicalArpFailReason `json:"arp_fail_reason,omitempty" yaml:"arp_fail_reason,omitempty" mapstructure:"arp_fail_reason,omitempty"`

	// ComponentId corresponds to the JSON schema field "component_id".
	ComponentId *string `json:"component_id,omitempty" yaml:"component_id,omitempty" mapstructure:"component_id,omitempty"`

	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentPath corresponds to the JSON schema field "component_path".
	ComponentPath *string `json:"component_path,omitempty" yaml:"component_path,omitempty" mapstructure:"component_path,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// The path of the interface at which traceflow packet was dropped (e.g.,
	// Tier0 Interface, Tier1 Interface, Service Interface, and Virtual Tunnel
	// Interface).
	//
	InterfacePath *string `json:"interface_path,omitempty" yaml:"interface_path,omitempty" mapstructure:"interface_path,omitempty"`

	// This field specifies the IPSec VPN fails reason IPSEC_SA_NOT_FOUND   - IPSec SA
	// required for processing the packet does not exist IPSEC_UDP_ENC_STATE_MISMATCH
	// - ESP packet is UDP encapsulated but IPsec SA does not expect UDP encapsulation
	// IPSEC_SEQ_ROLLOVER   - IPSec SA sequence number has exceeded the maximum value
	// IPSEC_FRAG_NEEDED   - Received packet has DF bit set in IP header but requires
	// fragmentation due to ESP encapsulation IPSEC_TUN_IFACE_DOWN   - IPSec tunnel
	// interface is down IPSEC_POLICY_NOMATCH   - Received packet does not match IPSec
	// policy IPSEC_POLICY_BLOCK   - IPSec packet processing failed IPSEC_POLICY_ERROR
	// - IPSec packet processing failed IPSEC_REPLAY_SEQ_NUM_REPEAT   - IPSec packet
	// is dropped due to replay IPSEC_REPLAY_RECV_DELAY   - IPSec packet is dropped
	// due to replay IPSEC_REPLAY_PROC_DELAY   - IPSec packet is dropped due to replay
	// IPSEC_ZERO_SEQ_NUM_RECVD   - ESP packet is received with sequence number as
	// zero IPSEC_ENQUEUE_FAIL   - Packet processing failed during crypto operation
	// IPSEC_AUTH_DGST_MISMATCH   - Packet integrity check failed due to digest
	// mismatch IPSEC_AUTH_DGST_SIZE_MISMATCH   - Packet integrity check failed due to
	// invalid digest length IPSEC_AUTH_UNSUPPORTED_ALGO   - Packet integrity check
	// failed due to unsupported hash algorithm IPSEC_CRYPTO_FAIL   - Packet
	// processing failed during crypto operation IPSEC_CRYPTO_PROC_INCOMPLETE   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_SESSION_INV   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_ARGS_INV   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_PROC_ERROR   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_NO_BUF_SPACE   -
	// Packet processing failed during crypto operation
	// IPSEC_CRYPTO_UNSUPPORTED_CIPHER   - Packet processing failed during crypto
	// operation IPSEC_MALFORMED   - Received ESP packet is malformed
	// IPSEC_MALFORMED_INV_PADDING   - Received ESP packet is malformed
	// IPSEC_PADDING_REMOVAL_FAILED   - Received ESP packet is malformed
	// IPSEC_INNER_MALFORMED   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_IP   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_UDP   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_TCP   - IP packet after ESP decryption is malformed
	// IPSEC_UNKNOWN   - IPSec VPN failure reason is unknown
	IpsecFailReason *PolicyTraceflowObservationDroppedLogicalIpsecFailReason `json:"ipsec_fail_reason,omitempty" yaml:"ipsec_fail_reason,omitempty" mapstructure:"ipsec_fail_reason,omitempty"`

	// This field is specified when the traceflow packet matched a jump-to rule.
	JumptoRuleId *int `json:"jumpto_rule_id,omitempty" yaml:"jumpto_rule_id,omitempty" mapstructure:"jumpto_rule_id,omitempty"`

	// The path of the jump-to rule that was applied to the traceflow packet
	JumptoRulePath *string `json:"jumpto_rule_path,omitempty" yaml:"jumpto_rule_path,omitempty" mapstructure:"jumpto_rule_path,omitempty"`

	// This field is specified when the traceflow packet matched a l2 rule.
	L2RuleId *int `json:"l2_rule_id,omitempty" yaml:"l2_rule_id,omitempty" mapstructure:"l2_rule_id,omitempty"`

	// The path of the l2 rule that was applied to the traceflow packet
	L2RulePath *string `json:"l2_rule_path,omitempty" yaml:"l2_rule_path,omitempty" mapstructure:"l2_rule_path,omitempty"`

	// LportId corresponds to the JSON schema field "lport_id".
	LportId *string `json:"lport_id,omitempty" yaml:"lport_id,omitempty" mapstructure:"lport_id,omitempty"`

	// LportName corresponds to the JSON schema field "lport_name".
	LportName *string `json:"lport_name,omitempty" yaml:"lport_name,omitempty" mapstructure:"lport_name,omitempty"`

	// This field is specified when the traceflow packet matched a NAT rule.
	NatRuleId *int `json:"nat_rule_id,omitempty" yaml:"nat_rule_id,omitempty" mapstructure:"nat_rule_id,omitempty"`

	// The path of the NAT rule that was applied to forward the traceflow packet
	NatRulePath *string `json:"nat_rule_path,omitempty" yaml:"nat_rule_path,omitempty" mapstructure:"nat_rule_path,omitempty"`

	// This field specifies the drop reason of traceflow packet. ARP_FAIL - ARP
	// request fails for some reasons, please refer arp_fail_reason for detail BFD -
	// BFD packet is dropped because traversed by non-operative interface or
	// encountering internal error (e.g., memory insufficient) BROADCAST - Packet is
	// dropped during traversing the interface (e.g., Edge uplink, Edge centralized
	// service port) which disallow ethernet broadcast DHCP - DHCP packet is malformed
	// DLB - The packet is disallowed by distributed load balancing FW_RULE - The
	// packet matches a drop or reject rule of DFW or Edge firewall GENEVE - GENEVE
	// packet is malformed GRE - GRE packet is malformed or traverses a non-operative
	// interface IFACE - Packet traverses a non-operative interface IP - Packet is
	// dropped because of IP related causes (e.g., ICMPv4/ICMPv6 packet is malformed,
	// or DF flag is set but fragment must be performed for the packet) or
	// corresponding interface is not found or inoperative IP_REASS - Packet is
	// dropped during IP reassembly IPSEC - IPsec protocol related packet is dropped
	// IPSEC_VTI - IPsec required SA is not found or traversing inoperative interface
	// cause packet dropped L2VPN - VLAN id of GRE packet is invalid L4PORT - Layer 4
	// packet (e.g., BFD, DHCP) is dropped LB - Packet is dropped by load balancing
	// rule LROUTER - Packet is dropped by logical router LSERVICE - Packet is
	// malformed or traverses inoperative logical service interface LSWITCH - Packet
	// is dropped by logical switch MANAGEMENT - Packet is dropped by Edge datapath
	// MANAGEMENT service port MD_PROXY - Packet is dropped by metadata proxy NAT -
	// Packet is dropped by NAT rule RTEP_TUNNEL - Unused drop reason ND_NS_FAIL -
	// Neighbor Discovery packet fails NEIGH - ARP or Neighbor Discovery packet fails
	// NO_EIP_FOUND - Destination IP is not an elastic IP NO_EIP_ASSOCIATION - Elastic
	// IP is not associated with active edge VDR ENI NO_ENI_FOR_IP - There is no ENI
	// found for the destination IP NO_ENI_FOR_LIF - Cannot find an ENI associated
	// with uplink LIF NO_ROUTE - Cannot find route for destination IP
	// NO_ROUTE_TABLE_FOUND - Cannot find associated route table
	// NO_UNDERLAY_ROUTE_FOUND - Cannot find AWS route to destination NOT_VDR_DOWNLINK
	// - Packet is not forwarded to VMC unmanaged VDR downlink NO_VDR_FOUND - VMC
	// unmanaged VDR associated with Edge uplink is not found NO_VDR_ON_HOST - Cannot
	// find VMC unmanaged VDR list on this host NOT_VDR_UPLINK - Packet is not
	// forwarded to VDR uplink SERVICE_INSERT - Packet from guest VM to service VM or
	// from service VM to guest VM is dropped by firewall rule SPOOFGUARD - Packet is
	// blocked by SpoofGuard policy TTL_ZERO - The IPv4 time to live field or the IPv6
	// hop limit field of packet is zero TUNNEL - Overlay tunnel management packet
	// (VNI value of GENEVE header is 0, e.g., BFD) is dropped VLAN - VLAN id of
	// packet is disallowed by the given port VXLAN - VXLAN packet is malformed or
	// cannot find tunnel port for it VXSTT - Unused drop reason VMC_NO_RESPONSE -
	// Failed to query VMC observations as no response from VMC app WRONG_UPLINK -
	// Packet is not routed to the expected Edge uplink by VMC unmanaged VDR FW_STATE
	// - Packet is dropped by stateful firewall NO_MAC - Drop by vswitch as no
	// destination MAC hit MAC Table. FILTERED_UPLINK - Filtering applied at the
	// corresponding UPLINK having no aggregation.
	Reason *PolicyTraceflowObservationDroppedLogicalReason `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// The path of the segment port at which traceflow packet
	// was dropped.
	//
	SegmentPortPath *string `json:"segment_port_path,omitempty" yaml:"segment_port_path,omitempty" mapstructure:"segment_port_path,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// The index of service path that is a chain of services represents the point
	// where the traceflow packet was dropped.
	ServicePathIndex *int `json:"service_path_index,omitempty" yaml:"service_path_index,omitempty" mapstructure:"service_path_index,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`
}

type PolicyTraceflowObservationDroppedLogicalArpFailReason string

const PolicyTraceflowObservationDroppedLogicalArpFailReasonARPCPFAIL PolicyTraceflowObservationDroppedLogicalArpFailReason = "ARP_CPFAIL"
const PolicyTraceflowObservationDroppedLogicalArpFailReasonARPFROMCP PolicyTraceflowObservationDroppedLogicalArpFailReason = "ARP_FROMCP"
const PolicyTraceflowObservationDroppedLogicalArpFailReasonARPNETDESTROY PolicyTraceflowObservationDroppedLogicalArpFailReason = "ARP_NETDESTROY"
const PolicyTraceflowObservationDroppedLogicalArpFailReasonARPPORTDESTROY PolicyTraceflowObservationDroppedLogicalArpFailReason = "ARP_PORTDESTROY"
const PolicyTraceflowObservationDroppedLogicalArpFailReasonARPTABLEDESTROY PolicyTraceflowObservationDroppedLogicalArpFailReason = "ARP_TABLEDESTROY"
const PolicyTraceflowObservationDroppedLogicalArpFailReasonARPTIMEOUT PolicyTraceflowObservationDroppedLogicalArpFailReason = "ARP_TIMEOUT"
const PolicyTraceflowObservationDroppedLogicalArpFailReasonARPUNKNOWN PolicyTraceflowObservationDroppedLogicalArpFailReason = "ARP_UNKNOWN"

var enumValues_PolicyTraceflowObservationDroppedLogicalArpFailReason = []interface{}{
	"ARP_UNKNOWN",
	"ARP_TIMEOUT",
	"ARP_CPFAIL",
	"ARP_FROMCP",
	"ARP_PORTDESTROY",
	"ARP_TABLEDESTROY",
	"ARP_NETDESTROY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationDroppedLogicalArpFailReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyTraceflowObservationDroppedLogicalArpFailReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyTraceflowObservationDroppedLogicalArpFailReason, v)
	}
	*j = PolicyTraceflowObservationDroppedLogicalArpFailReason(v)
	return nil
}

type PolicyTraceflowObservationDroppedLogicalIpsecFailReason string

const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECAUTHDGSTMISMATCH PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_AUTH_DGST_MISMATCH"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECAUTHDGSTSIZEMISMATCH PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_AUTH_DGST_SIZE_MISMATCH"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECAUTHUNSUPPORTEDALGO PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_AUTH_UNSUPPORTED_ALGO"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOARGSINV PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_ARGS_INV"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOFAIL PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_FAIL"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTONOBUFSPACE PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_NO_BUF_SPACE"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOPROCERROR PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_PROC_ERROR"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOPROCINCOMPLETE PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_PROC_INCOMPLETE"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOSESSIONINV PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_SESSION_INV"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOUNSUPPORTEDCIPHER PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_UNSUPPORTED_CIPHER"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECENQUEUEFAIL PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_ENQUEUE_FAIL"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECFRAGNEEDED PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_FRAG_NEEDED"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECINNERMALFORMED PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_INNER_MALFORMED"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECINNERMALFORMEDIP PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_INNER_MALFORMED_IP"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECINNERMALFORMEDTCP PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_INNER_MALFORMED_TCP"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECINNERMALFORMEDUDP PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_INNER_MALFORMED_UDP"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECMALFORMED PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_MALFORMED"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECMALFORMEDINVPADDING PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_MALFORMED_INV_PADDING"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECPADDINGREMOVALFAILED PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_PADDING_REMOVAL_FAILED"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECPOLICYBLOCK PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_POLICY_BLOCK"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECPOLICYERROR PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_POLICY_ERROR"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECPOLICYNOMATCH PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_POLICY_NOMATCH"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECREPLAYPROCDELAY PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_REPLAY_PROC_DELAY"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECREPLAYRECVDELAY PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_REPLAY_RECV_DELAY"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECREPLAYSEQNUMREPEAT PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_REPLAY_SEQ_NUM_REPEAT"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECSANOTFOUND PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_SA_NOT_FOUND"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECSEQROLLOVER PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_SEQ_ROLLOVER"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECTUNIFACEDOWN PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_TUN_IFACE_DOWN"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECUDPENCSTATEMISMATCH PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_UDP_ENC_STATE_MISMATCH"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECUNKNOWN PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_UNKNOWN"
const PolicyTraceflowObservationDroppedLogicalIpsecFailReasonIPSECZEROSEQNUMRECVD PolicyTraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_ZERO_SEQ_NUM_RECVD"

var enumValues_PolicyTraceflowObservationDroppedLogicalIpsecFailReason = []interface{}{
	"IPSEC_SA_NOT_FOUND",
	"IPSEC_UDP_ENC_STATE_MISMATCH",
	"IPSEC_SEQ_ROLLOVER",
	"IPSEC_FRAG_NEEDED",
	"IPSEC_TUN_IFACE_DOWN",
	"IPSEC_POLICY_NOMATCH",
	"IPSEC_POLICY_BLOCK",
	"IPSEC_POLICY_ERROR",
	"IPSEC_REPLAY_SEQ_NUM_REPEAT",
	"IPSEC_REPLAY_RECV_DELAY",
	"IPSEC_REPLAY_PROC_DELAY",
	"IPSEC_ZERO_SEQ_NUM_RECVD",
	"IPSEC_ENQUEUE_FAIL",
	"IPSEC_AUTH_DGST_MISMATCH",
	"IPSEC_AUTH_DGST_SIZE_MISMATCH",
	"IPSEC_AUTH_UNSUPPORTED_ALGO",
	"IPSEC_CRYPTO_FAIL",
	"IPSEC_CRYPTO_PROC_INCOMPLETE",
	"IPSEC_CRYPTO_SESSION_INV",
	"IPSEC_CRYPTO_ARGS_INV",
	"IPSEC_CRYPTO_PROC_ERROR",
	"IPSEC_CRYPTO_NO_BUF_SPACE",
	"IPSEC_CRYPTO_UNSUPPORTED_CIPHER",
	"IPSEC_MALFORMED",
	"IPSEC_MALFORMED_INV_PADDING",
	"IPSEC_PADDING_REMOVAL_FAILED",
	"IPSEC_INNER_MALFORMED",
	"IPSEC_INNER_MALFORMED_IP",
	"IPSEC_INNER_MALFORMED_UDP",
	"IPSEC_INNER_MALFORMED_TCP",
	"IPSEC_UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationDroppedLogicalIpsecFailReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyTraceflowObservationDroppedLogicalIpsecFailReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyTraceflowObservationDroppedLogicalIpsecFailReason, v)
	}
	*j = PolicyTraceflowObservationDroppedLogicalIpsecFailReason(v)
	return nil
}

type PolicyTraceflowObservationDroppedLogicalReason string

const PolicyTraceflowObservationDroppedLogicalReasonARPFAIL PolicyTraceflowObservationDroppedLogicalReason = "ARP_FAIL"
const PolicyTraceflowObservationDroppedLogicalReasonBFD PolicyTraceflowObservationDroppedLogicalReason = "BFD"
const PolicyTraceflowObservationDroppedLogicalReasonBROADCAST PolicyTraceflowObservationDroppedLogicalReason = "BROADCAST"
const PolicyTraceflowObservationDroppedLogicalReasonDHCP PolicyTraceflowObservationDroppedLogicalReason = "DHCP"
const PolicyTraceflowObservationDroppedLogicalReasonDLB PolicyTraceflowObservationDroppedLogicalReason = "DLB"
const PolicyTraceflowObservationDroppedLogicalReasonFILTEREDUPLINK PolicyTraceflowObservationDroppedLogicalReason = "FILTERED_UPLINK"
const PolicyTraceflowObservationDroppedLogicalReasonFWRULE PolicyTraceflowObservationDroppedLogicalReason = "FW_RULE"
const PolicyTraceflowObservationDroppedLogicalReasonFWSTATE PolicyTraceflowObservationDroppedLogicalReason = "FW_STATE"
const PolicyTraceflowObservationDroppedLogicalReasonGENEVE PolicyTraceflowObservationDroppedLogicalReason = "GENEVE"
const PolicyTraceflowObservationDroppedLogicalReasonGRE PolicyTraceflowObservationDroppedLogicalReason = "GRE"
const PolicyTraceflowObservationDroppedLogicalReasonIFACE PolicyTraceflowObservationDroppedLogicalReason = "IFACE"
const PolicyTraceflowObservationDroppedLogicalReasonIP PolicyTraceflowObservationDroppedLogicalReason = "IP"
const PolicyTraceflowObservationDroppedLogicalReasonIPREASS PolicyTraceflowObservationDroppedLogicalReason = "IP_REASS"
const PolicyTraceflowObservationDroppedLogicalReasonIPSEC PolicyTraceflowObservationDroppedLogicalReason = "IPSEC"
const PolicyTraceflowObservationDroppedLogicalReasonIPSECVTI PolicyTraceflowObservationDroppedLogicalReason = "IPSEC_VTI"
const PolicyTraceflowObservationDroppedLogicalReasonL2VPN PolicyTraceflowObservationDroppedLogicalReason = "L2VPN"
const PolicyTraceflowObservationDroppedLogicalReasonL4PORT PolicyTraceflowObservationDroppedLogicalReason = "L4PORT"
const PolicyTraceflowObservationDroppedLogicalReasonLB PolicyTraceflowObservationDroppedLogicalReason = "LB"
const PolicyTraceflowObservationDroppedLogicalReasonLROUTER PolicyTraceflowObservationDroppedLogicalReason = "LROUTER"
const PolicyTraceflowObservationDroppedLogicalReasonLSERVICE PolicyTraceflowObservationDroppedLogicalReason = "LSERVICE"
const PolicyTraceflowObservationDroppedLogicalReasonLSWITCH PolicyTraceflowObservationDroppedLogicalReason = "LSWITCH"
const PolicyTraceflowObservationDroppedLogicalReasonMANAGEMENT PolicyTraceflowObservationDroppedLogicalReason = "MANAGEMENT"
const PolicyTraceflowObservationDroppedLogicalReasonMDPROXY PolicyTraceflowObservationDroppedLogicalReason = "MD_PROXY"
const PolicyTraceflowObservationDroppedLogicalReasonNAT PolicyTraceflowObservationDroppedLogicalReason = "NAT"
const PolicyTraceflowObservationDroppedLogicalReasonNDNSFAIL PolicyTraceflowObservationDroppedLogicalReason = "ND_NS_FAIL"
const PolicyTraceflowObservationDroppedLogicalReasonNEIGH PolicyTraceflowObservationDroppedLogicalReason = "NEIGH"
const PolicyTraceflowObservationDroppedLogicalReasonNOEIPASSOCIATION PolicyTraceflowObservationDroppedLogicalReason = "NO_EIP_ASSOCIATION"
const PolicyTraceflowObservationDroppedLogicalReasonNOEIPFOUND PolicyTraceflowObservationDroppedLogicalReason = "NO_EIP_FOUND"
const PolicyTraceflowObservationDroppedLogicalReasonNOENIFORIP PolicyTraceflowObservationDroppedLogicalReason = "NO_ENI_FOR_IP"
const PolicyTraceflowObservationDroppedLogicalReasonNOENIFORLIF PolicyTraceflowObservationDroppedLogicalReason = "NO_ENI_FOR_LIF"
const PolicyTraceflowObservationDroppedLogicalReasonNOMAC PolicyTraceflowObservationDroppedLogicalReason = "NO_MAC"
const PolicyTraceflowObservationDroppedLogicalReasonNOROUTE PolicyTraceflowObservationDroppedLogicalReason = "NO_ROUTE"
const PolicyTraceflowObservationDroppedLogicalReasonNOROUTETABLEFOUND PolicyTraceflowObservationDroppedLogicalReason = "NO_ROUTE_TABLE_FOUND"
const PolicyTraceflowObservationDroppedLogicalReasonNOTVDRDOWNLINK PolicyTraceflowObservationDroppedLogicalReason = "NOT_VDR_DOWNLINK"
const PolicyTraceflowObservationDroppedLogicalReasonNOTVDRUPLINK PolicyTraceflowObservationDroppedLogicalReason = "NOT_VDR_UPLINK"
const PolicyTraceflowObservationDroppedLogicalReasonNOUNDERLAYROUTEFOUND PolicyTraceflowObservationDroppedLogicalReason = "NO_UNDERLAY_ROUTE_FOUND"
const PolicyTraceflowObservationDroppedLogicalReasonNOVDRFOUND PolicyTraceflowObservationDroppedLogicalReason = "NO_VDR_FOUND"
const PolicyTraceflowObservationDroppedLogicalReasonNOVDRONHOST PolicyTraceflowObservationDroppedLogicalReason = "NO_VDR_ON_HOST"
const PolicyTraceflowObservationDroppedLogicalReasonRTEPTUNNEL PolicyTraceflowObservationDroppedLogicalReason = "RTEP_TUNNEL"
const PolicyTraceflowObservationDroppedLogicalReasonSERVICEINSERT PolicyTraceflowObservationDroppedLogicalReason = "SERVICE_INSERT"
const PolicyTraceflowObservationDroppedLogicalReasonSPOOFGUARD PolicyTraceflowObservationDroppedLogicalReason = "SPOOFGUARD"
const PolicyTraceflowObservationDroppedLogicalReasonTTLZERO PolicyTraceflowObservationDroppedLogicalReason = "TTL_ZERO"
const PolicyTraceflowObservationDroppedLogicalReasonTUNNEL PolicyTraceflowObservationDroppedLogicalReason = "TUNNEL"
const PolicyTraceflowObservationDroppedLogicalReasonUNKNOWN PolicyTraceflowObservationDroppedLogicalReason = "UNKNOWN"
const PolicyTraceflowObservationDroppedLogicalReasonVLAN PolicyTraceflowObservationDroppedLogicalReason = "VLAN"
const PolicyTraceflowObservationDroppedLogicalReasonVMCNORESPONSE PolicyTraceflowObservationDroppedLogicalReason = "VMC_NO_RESPONSE"
const PolicyTraceflowObservationDroppedLogicalReasonVXLAN PolicyTraceflowObservationDroppedLogicalReason = "VXLAN"
const PolicyTraceflowObservationDroppedLogicalReasonVXSTT PolicyTraceflowObservationDroppedLogicalReason = "VXSTT"
const PolicyTraceflowObservationDroppedLogicalReasonWRONGUPLINK PolicyTraceflowObservationDroppedLogicalReason = "WRONG_UPLINK"

var enumValues_PolicyTraceflowObservationDroppedLogicalReason = []interface{}{
	"ARP_FAIL",
	"BFD",
	"BROADCAST",
	"DHCP",
	"DLB",
	"FW_RULE",
	"GENEVE",
	"GRE",
	"IFACE",
	"IP",
	"IP_REASS",
	"IPSEC",
	"IPSEC_VTI",
	"L2VPN",
	"L4PORT",
	"LB",
	"LROUTER",
	"LSERVICE",
	"LSWITCH",
	"MANAGEMENT",
	"MD_PROXY",
	"NAT",
	"RTEP_TUNNEL",
	"ND_NS_FAIL",
	"NEIGH",
	"NO_EIP_FOUND",
	"NO_EIP_ASSOCIATION",
	"NO_ENI_FOR_IP",
	"NO_ENI_FOR_LIF",
	"NO_ROUTE",
	"NO_ROUTE_TABLE_FOUND",
	"NO_UNDERLAY_ROUTE_FOUND",
	"NOT_VDR_DOWNLINK",
	"NO_VDR_FOUND",
	"NO_VDR_ON_HOST",
	"NOT_VDR_UPLINK",
	"SERVICE_INSERT",
	"SPOOFGUARD",
	"TTL_ZERO",
	"TUNNEL",
	"VLAN",
	"VXLAN",
	"VXSTT",
	"VMC_NO_RESPONSE",
	"WRONG_UPLINK",
	"FW_STATE",
	"NO_MAC",
	"UNKNOWN",
	"FILTERED_UPLINK",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationDroppedLogicalReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyTraceflowObservationDroppedLogicalReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyTraceflowObservationDroppedLogicalReason, v)
	}
	*j = PolicyTraceflowObservationDroppedLogicalReason(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationDroppedLogical) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PolicyTraceflowObservationDroppedLogical
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = PolicyTraceflowObservationDroppedLogical(plain)
	return nil
}

type PolicyTraceflowObservationDroppedReason string

const PolicyTraceflowObservationDroppedReasonARPFAIL PolicyTraceflowObservationDroppedReason = "ARP_FAIL"
const PolicyTraceflowObservationDroppedReasonBFD PolicyTraceflowObservationDroppedReason = "BFD"
const PolicyTraceflowObservationDroppedReasonBROADCAST PolicyTraceflowObservationDroppedReason = "BROADCAST"
const PolicyTraceflowObservationDroppedReasonDHCP PolicyTraceflowObservationDroppedReason = "DHCP"
const PolicyTraceflowObservationDroppedReasonDLB PolicyTraceflowObservationDroppedReason = "DLB"
const PolicyTraceflowObservationDroppedReasonFILTEREDUPLINK PolicyTraceflowObservationDroppedReason = "FILTERED_UPLINK"
const PolicyTraceflowObservationDroppedReasonFWRULE PolicyTraceflowObservationDroppedReason = "FW_RULE"
const PolicyTraceflowObservationDroppedReasonFWSTATE PolicyTraceflowObservationDroppedReason = "FW_STATE"
const PolicyTraceflowObservationDroppedReasonGENEVE PolicyTraceflowObservationDroppedReason = "GENEVE"
const PolicyTraceflowObservationDroppedReasonGRE PolicyTraceflowObservationDroppedReason = "GRE"
const PolicyTraceflowObservationDroppedReasonIFACE PolicyTraceflowObservationDroppedReason = "IFACE"
const PolicyTraceflowObservationDroppedReasonIP PolicyTraceflowObservationDroppedReason = "IP"
const PolicyTraceflowObservationDroppedReasonIPREASS PolicyTraceflowObservationDroppedReason = "IP_REASS"
const PolicyTraceflowObservationDroppedReasonIPSEC PolicyTraceflowObservationDroppedReason = "IPSEC"
const PolicyTraceflowObservationDroppedReasonIPSECVTI PolicyTraceflowObservationDroppedReason = "IPSEC_VTI"
const PolicyTraceflowObservationDroppedReasonL2VPN PolicyTraceflowObservationDroppedReason = "L2VPN"
const PolicyTraceflowObservationDroppedReasonL4PORT PolicyTraceflowObservationDroppedReason = "L4PORT"
const PolicyTraceflowObservationDroppedReasonLB PolicyTraceflowObservationDroppedReason = "LB"
const PolicyTraceflowObservationDroppedReasonLROUTER PolicyTraceflowObservationDroppedReason = "LROUTER"
const PolicyTraceflowObservationDroppedReasonLSERVICE PolicyTraceflowObservationDroppedReason = "LSERVICE"
const PolicyTraceflowObservationDroppedReasonLSWITCH PolicyTraceflowObservationDroppedReason = "LSWITCH"
const PolicyTraceflowObservationDroppedReasonMANAGEMENT PolicyTraceflowObservationDroppedReason = "MANAGEMENT"
const PolicyTraceflowObservationDroppedReasonMDPROXY PolicyTraceflowObservationDroppedReason = "MD_PROXY"
const PolicyTraceflowObservationDroppedReasonNAT PolicyTraceflowObservationDroppedReason = "NAT"
const PolicyTraceflowObservationDroppedReasonNDNSFAIL PolicyTraceflowObservationDroppedReason = "ND_NS_FAIL"
const PolicyTraceflowObservationDroppedReasonNEIGH PolicyTraceflowObservationDroppedReason = "NEIGH"
const PolicyTraceflowObservationDroppedReasonNOEIPASSOCIATION PolicyTraceflowObservationDroppedReason = "NO_EIP_ASSOCIATION"
const PolicyTraceflowObservationDroppedReasonNOEIPFOUND PolicyTraceflowObservationDroppedReason = "NO_EIP_FOUND"
const PolicyTraceflowObservationDroppedReasonNOENIFORIP PolicyTraceflowObservationDroppedReason = "NO_ENI_FOR_IP"
const PolicyTraceflowObservationDroppedReasonNOENIFORLIF PolicyTraceflowObservationDroppedReason = "NO_ENI_FOR_LIF"
const PolicyTraceflowObservationDroppedReasonNOMAC PolicyTraceflowObservationDroppedReason = "NO_MAC"
const PolicyTraceflowObservationDroppedReasonNOROUTE PolicyTraceflowObservationDroppedReason = "NO_ROUTE"
const PolicyTraceflowObservationDroppedReasonNOROUTETABLEFOUND PolicyTraceflowObservationDroppedReason = "NO_ROUTE_TABLE_FOUND"
const PolicyTraceflowObservationDroppedReasonNOTVDRDOWNLINK PolicyTraceflowObservationDroppedReason = "NOT_VDR_DOWNLINK"
const PolicyTraceflowObservationDroppedReasonNOTVDRUPLINK PolicyTraceflowObservationDroppedReason = "NOT_VDR_UPLINK"
const PolicyTraceflowObservationDroppedReasonNOUNDERLAYROUTEFOUND PolicyTraceflowObservationDroppedReason = "NO_UNDERLAY_ROUTE_FOUND"
const PolicyTraceflowObservationDroppedReasonNOVDRFOUND PolicyTraceflowObservationDroppedReason = "NO_VDR_FOUND"
const PolicyTraceflowObservationDroppedReasonNOVDRONHOST PolicyTraceflowObservationDroppedReason = "NO_VDR_ON_HOST"
const PolicyTraceflowObservationDroppedReasonRTEPTUNNEL PolicyTraceflowObservationDroppedReason = "RTEP_TUNNEL"
const PolicyTraceflowObservationDroppedReasonSERVICEINSERT PolicyTraceflowObservationDroppedReason = "SERVICE_INSERT"
const PolicyTraceflowObservationDroppedReasonSPOOFGUARD PolicyTraceflowObservationDroppedReason = "SPOOFGUARD"
const PolicyTraceflowObservationDroppedReasonTTLZERO PolicyTraceflowObservationDroppedReason = "TTL_ZERO"
const PolicyTraceflowObservationDroppedReasonTUNNEL PolicyTraceflowObservationDroppedReason = "TUNNEL"
const PolicyTraceflowObservationDroppedReasonUNKNOWN PolicyTraceflowObservationDroppedReason = "UNKNOWN"
const PolicyTraceflowObservationDroppedReasonVLAN PolicyTraceflowObservationDroppedReason = "VLAN"
const PolicyTraceflowObservationDroppedReasonVMCNORESPONSE PolicyTraceflowObservationDroppedReason = "VMC_NO_RESPONSE"
const PolicyTraceflowObservationDroppedReasonVXLAN PolicyTraceflowObservationDroppedReason = "VXLAN"
const PolicyTraceflowObservationDroppedReasonVXSTT PolicyTraceflowObservationDroppedReason = "VXSTT"
const PolicyTraceflowObservationDroppedReasonWRONGUPLINK PolicyTraceflowObservationDroppedReason = "WRONG_UPLINK"

var enumValues_PolicyTraceflowObservationDroppedReason = []interface{}{
	"ARP_FAIL",
	"BFD",
	"BROADCAST",
	"DHCP",
	"DLB",
	"FW_RULE",
	"GENEVE",
	"GRE",
	"IFACE",
	"IP",
	"IP_REASS",
	"IPSEC",
	"IPSEC_VTI",
	"L2VPN",
	"L4PORT",
	"LB",
	"LROUTER",
	"LSERVICE",
	"LSWITCH",
	"MANAGEMENT",
	"MD_PROXY",
	"NAT",
	"RTEP_TUNNEL",
	"ND_NS_FAIL",
	"NEIGH",
	"NO_EIP_FOUND",
	"NO_EIP_ASSOCIATION",
	"NO_ENI_FOR_IP",
	"NO_ENI_FOR_LIF",
	"NO_ROUTE",
	"NO_ROUTE_TABLE_FOUND",
	"NO_UNDERLAY_ROUTE_FOUND",
	"NOT_VDR_DOWNLINK",
	"NO_VDR_FOUND",
	"NO_VDR_ON_HOST",
	"NOT_VDR_UPLINK",
	"SERVICE_INSERT",
	"SPOOFGUARD",
	"TTL_ZERO",
	"TUNNEL",
	"VLAN",
	"VXLAN",
	"VXSTT",
	"VMC_NO_RESPONSE",
	"WRONG_UPLINK",
	"FW_STATE",
	"NO_MAC",
	"UNKNOWN",
	"FILTERED_UPLINK",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationDroppedReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyTraceflowObservationDroppedReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyTraceflowObservationDroppedReason, v)
	}
	*j = PolicyTraceflowObservationDroppedReason(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationDropped) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PolicyTraceflowObservationDropped
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = PolicyTraceflowObservationDropped(plain)
	return nil
}

type PolicyTraceflowObservationForwardedLogical struct {
	// This field is specified when the traceflow packet matched a L3 firewall rule.
	AclRuleId *int `json:"acl_rule_id,omitempty" yaml:"acl_rule_id,omitempty" mapstructure:"acl_rule_id,omitempty"`

	// The path of the ACL rule that was applied to forward the traceflow packet
	AclRulePath *string `json:"acl_rule_path,omitempty" yaml:"acl_rule_path,omitempty" mapstructure:"acl_rule_path,omitempty"`

	// ComponentId corresponds to the JSON schema field "component_id".
	ComponentId *string `json:"component_id,omitempty" yaml:"component_id,omitempty" mapstructure:"component_id,omitempty"`

	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentPath corresponds to the JSON schema field "component_path".
	ComponentPath *string `json:"component_path,omitempty" yaml:"component_path,omitempty" mapstructure:"component_path,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// DstComponentId corresponds to the JSON schema field "dst_component_id".
	DstComponentId *string `json:"dst_component_id,omitempty" yaml:"dst_component_id,omitempty" mapstructure:"dst_component_id,omitempty"`

	// DstComponentName corresponds to the JSON schema field "dst_component_name".
	DstComponentName *string `json:"dst_component_name,omitempty" yaml:"dst_component_name,omitempty" mapstructure:"dst_component_name,omitempty"`

	// DstComponentPath corresponds to the JSON schema field "dst_component_path".
	DstComponentPath *string `json:"dst_component_path,omitempty" yaml:"dst_component_path,omitempty" mapstructure:"dst_component_path,omitempty"`

	// DstComponentType corresponds to the JSON schema field "dst_component_type".
	DstComponentType *TraceflowComponentType `json:"dst_component_type,omitempty" yaml:"dst_component_type,omitempty" mapstructure:"dst_component_type,omitempty"`

	// The path of the interface through which the traceflow packet was forwarded
	// (e.g.,
	// Tier0 Interface, Tier1 Interface, Service Interface, and Virtual Tunnel
	// Interface).
	//
	InterfacePath *string `json:"interface_path,omitempty" yaml:"interface_path,omitempty" mapstructure:"interface_path,omitempty"`

	// This field is specified when the traceflow packet was forwarded through IPSec
	// VPN.
	IpsecVpn *TraceflowObservationIpsecVpn `json:"ipsec_vpn,omitempty" yaml:"ipsec_vpn,omitempty" mapstructure:"ipsec_vpn,omitempty"`

	// IpsecVpnPath corresponds to the JSON schema field "ipsec_vpn_path".
	IpsecVpnPath *PolicyTraceflowObservationIpsecVpn `json:"ipsec_vpn_path,omitempty" yaml:"ipsec_vpn_path,omitempty" mapstructure:"ipsec_vpn_path,omitempty"`

	// This field is specified when the traceflow packet matched a jump-to rule.
	JumptoRuleId *int `json:"jumpto_rule_id,omitempty" yaml:"jumpto_rule_id,omitempty" mapstructure:"jumpto_rule_id,omitempty"`

	// The path of the jump-to rule that was applied to the traceflow packet
	JumptoRulePath *string `json:"jumpto_rule_path,omitempty" yaml:"jumpto_rule_path,omitempty" mapstructure:"jumpto_rule_path,omitempty"`

	// This field is specified when the traceflow packet matched a l2 rule.
	L2RuleId *int `json:"l2_rule_id,omitempty" yaml:"l2_rule_id,omitempty" mapstructure:"l2_rule_id,omitempty"`

	// The path of the l2 rule that was applied to the traceflow packet
	L2RulePath *string `json:"l2_rule_path,omitempty" yaml:"l2_rule_path,omitempty" mapstructure:"l2_rule_path,omitempty"`

	// LportId corresponds to the JSON schema field "lport_id".
	LportId *string `json:"lport_id,omitempty" yaml:"lport_id,omitempty" mapstructure:"lport_id,omitempty"`

	// LportName corresponds to the JSON schema field "lport_name".
	LportName *string `json:"lport_name,omitempty" yaml:"lport_name,omitempty" mapstructure:"lport_name,omitempty"`

	// This field is specified when the traceflow packet matched a NAT rule.
	NatRuleId *int `json:"nat_rule_id,omitempty" yaml:"nat_rule_id,omitempty" mapstructure:"nat_rule_id,omitempty"`

	// The path of the NAT rule that was applied to forward the traceflow packet
	NatRulePath *string `json:"nat_rule_path,omitempty" yaml:"nat_rule_path,omitempty" mapstructure:"nat_rule_path,omitempty"`

	// This field is specified when the traceflow packet was routed by logical router.
	NextHop *IPAddress `json:"next_hop,omitempty" yaml:"next_hop,omitempty" mapstructure:"next_hop,omitempty"`

	// ARP_UNKNOWN_FROM_CP - Unknown ARP query result emitted by control plane
	// ND_NS_UNKNOWN_FROM_CP - Unknown neighbor solicitation query result emitted by
	// control plane UNKNOWN - Unknown resend type
	ResendType *PolicyTraceflowObservationForwardedLogicalResendType `json:"resend_type,omitempty" yaml:"resend_type,omitempty" mapstructure:"resend_type,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// This field is specified when the traceflow packet was routed by logical router.
	RoutePrefix *IPCIDRBlock `json:"route_prefix,omitempty" yaml:"route_prefix,omitempty" mapstructure:"route_prefix,omitempty"`

	// The path of the segment port through which the
	// traceflow packet was forwarded.
	//
	SegmentPortPath *string `json:"segment_port_path,omitempty" yaml:"segment_port_path,omitempty" mapstructure:"segment_port_path,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// ServiceIndex corresponds to the JSON schema field "service_index".
	ServiceIndex *int `json:"service_index,omitempty" yaml:"service_index,omitempty" mapstructure:"service_index,omitempty"`

	// ServicePathIndex corresponds to the JSON schema field "service_path_index".
	ServicePathIndex *int `json:"service_path_index,omitempty" yaml:"service_path_index,omitempty" mapstructure:"service_path_index,omitempty"`

	// ServiceTtl corresponds to the JSON schema field "service_ttl".
	ServiceTtl *int `json:"service_ttl,omitempty" yaml:"service_ttl,omitempty" mapstructure:"service_ttl,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// This field specified the prefix IP address a traceflow packet matched in the
	// whitelist in spoofguard.
	SpoofguardIp *IPCIDRBlock `json:"spoofguard_ip,omitempty" yaml:"spoofguard_ip,omitempty" mapstructure:"spoofguard_ip,omitempty"`

	// The source MAC address of form: "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$".
	// For example: 00:00:00:00:00:00.
	SpoofguardMac *MACAddress `json:"spoofguard_mac,omitempty" yaml:"spoofguard_mac,omitempty" mapstructure:"spoofguard_mac,omitempty"`

	// This field specified the VLAN id a traceflow packet matched in the whitelist in
	// spoofguard.
	SpoofguardVlanId *VlanID `json:"spoofguard_vlan_id,omitempty" yaml:"spoofguard_vlan_id,omitempty" mapstructure:"spoofguard_vlan_id,omitempty"`

	// MAC address of nexthop for service insertion(SI) in service VM(SVM) where the
	// traceflow packet was received.
	SvcNhMac *string `json:"svc_nh_mac,omitempty" yaml:"svc_nh_mac,omitempty" mapstructure:"svc_nh_mac,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TranslatedDstIp corresponds to the JSON schema field "translated_dst_ip".
	TranslatedDstIp *IPAddress `json:"translated_dst_ip,omitempty" yaml:"translated_dst_ip,omitempty" mapstructure:"translated_dst_ip,omitempty"`

	// TranslatedSrcIp corresponds to the JSON schema field "translated_src_ip".
	TranslatedSrcIp *IPAddress `json:"translated_src_ip,omitempty" yaml:"translated_src_ip,omitempty" mapstructure:"translated_src_ip,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`

	// This field is specified when the traceflow packet was forwarded by a VLAN
	// logical network.
	Vlan *VlanID `json:"vlan,omitempty" yaml:"vlan,omitempty" mapstructure:"vlan,omitempty"`

	// This field is specified when the traceflow packet was forwarded by an overlay
	// logical network.
	Vni *int `json:"vni,omitempty" yaml:"vni,omitempty" mapstructure:"vni,omitempty"`
}

type PolicyTraceflowObservationForwardedLogicalResendType string

const PolicyTraceflowObservationForwardedLogicalResendTypeARPUNKNOWNFROMCP PolicyTraceflowObservationForwardedLogicalResendType = "ARP_UNKNOWN_FROM_CP"
const PolicyTraceflowObservationForwardedLogicalResendTypeNDNSUNKNWONFROMCP PolicyTraceflowObservationForwardedLogicalResendType = "ND_NS_UNKNWON_FROM_CP"
const PolicyTraceflowObservationForwardedLogicalResendTypeUNKNOWN PolicyTraceflowObservationForwardedLogicalResendType = "UNKNOWN"

var enumValues_PolicyTraceflowObservationForwardedLogicalResendType = []interface{}{
	"UNKNOWN",
	"ARP_UNKNOWN_FROM_CP",
	"ND_NS_UNKNWON_FROM_CP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationForwardedLogicalResendType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyTraceflowObservationForwardedLogicalResendType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyTraceflowObservationForwardedLogicalResendType, v)
	}
	*j = PolicyTraceflowObservationForwardedLogicalResendType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationForwardedLogical) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PolicyTraceflowObservationForwardedLogical
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = PolicyTraceflowObservationForwardedLogical(plain)
	return nil
}

type PolicyTraceflowObservationIpsecVpn struct {
	// SessionPath corresponds to the JSON schema field "session_path".
	SessionPath *string `json:"session_path,omitempty" yaml:"session_path,omitempty" mapstructure:"session_path,omitempty"`

	// VtiPath corresponds to the JSON schema field "vti_path".
	VtiPath *string `json:"vti_path,omitempty" yaml:"vti_path,omitempty" mapstructure:"vti_path,omitempty"`
}

type PolicyTraceflowObservationReceivedLogical struct {
	// ComponentId corresponds to the JSON schema field "component_id".
	ComponentId *string `json:"component_id,omitempty" yaml:"component_id,omitempty" mapstructure:"component_id,omitempty"`

	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentPath corresponds to the JSON schema field "component_path".
	ComponentPath *string `json:"component_path,omitempty" yaml:"component_path,omitempty" mapstructure:"component_path,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// The path of the interface at which the traceflow packet was received (e.g.,
	// Tier0 Interface, Tier1 Interface, Service Interface, and Virtual Tunnel
	// Interface).
	//
	InterfacePath *string `json:"interface_path,omitempty" yaml:"interface_path,omitempty" mapstructure:"interface_path,omitempty"`

	// This field is specified when the traceflow packet was received on IPSec VPN.
	IpsecVpn *TraceflowObservationIpsecVpn `json:"ipsec_vpn,omitempty" yaml:"ipsec_vpn,omitempty" mapstructure:"ipsec_vpn,omitempty"`

	// IpsecVpnPath corresponds to the JSON schema field "ipsec_vpn_path".
	IpsecVpnPath *PolicyTraceflowObservationIpsecVpn `json:"ipsec_vpn_path,omitempty" yaml:"ipsec_vpn_path,omitempty" mapstructure:"ipsec_vpn_path,omitempty"`

	// LportId corresponds to the JSON schema field "lport_id".
	LportId *string `json:"lport_id,omitempty" yaml:"lport_id,omitempty" mapstructure:"lport_id,omitempty"`

	// LportName corresponds to the JSON schema field "lport_name".
	LportName *string `json:"lport_name,omitempty" yaml:"lport_name,omitempty" mapstructure:"lport_name,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// The path of the segment port at which the
	// traceflow packet was received.
	//
	SegmentPortPath *string `json:"segment_port_path,omitempty" yaml:"segment_port_path,omitempty" mapstructure:"segment_port_path,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// SrcComponentId corresponds to the JSON schema field "src_component_id".
	SrcComponentId *string `json:"src_component_id,omitempty" yaml:"src_component_id,omitempty" mapstructure:"src_component_id,omitempty"`

	// SrcComponentName corresponds to the JSON schema field "src_component_name".
	SrcComponentName *string `json:"src_component_name,omitempty" yaml:"src_component_name,omitempty" mapstructure:"src_component_name,omitempty"`

	// SrcComponentPath corresponds to the JSON schema field "src_component_path".
	SrcComponentPath *string `json:"src_component_path,omitempty" yaml:"src_component_path,omitempty" mapstructure:"src_component_path,omitempty"`

	// SrcComponentType corresponds to the JSON schema field "src_component_type".
	SrcComponentType *TraceflowComponentType `json:"src_component_type,omitempty" yaml:"src_component_type,omitempty" mapstructure:"src_component_type,omitempty"`

	// MAC address of SAN volume controller for service insertion(SI) in service
	// VM(SVM) where the traceflow packet was received.
	SvcMac *string `json:"svc_mac,omitempty" yaml:"svc_mac,omitempty" mapstructure:"svc_mac,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`

	// This field is specified when the traceflow packet was received by a VLAN
	// logical network.
	Vlan *VlanID `json:"vlan,omitempty" yaml:"vlan,omitempty" mapstructure:"vlan,omitempty"`

	// This field is specified when the traceflow packet was received by an overlay
	// logical network.
	Vni *int `json:"vni,omitempty" yaml:"vni,omitempty" mapstructure:"vni,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationReceivedLogical) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PolicyTraceflowObservationReceivedLogical
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = PolicyTraceflowObservationReceivedLogical(plain)
	return nil
}

type PolicyTraceflowObservationRelayedLogical struct {
	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// This field specified the IP address of the destination which the packet will be
	// relayed.
	DstServerAddress *IPAddress `json:"dst_server_address,omitempty" yaml:"dst_server_address,omitempty" mapstructure:"dst_server_address,omitempty"`

	// This field specified the logical component that relay service located.
	LogicalCompUuid *string `json:"logical_comp_uuid,omitempty" yaml:"logical_comp_uuid,omitempty" mapstructure:"logical_comp_uuid,omitempty"`

	// This field specifies the logical component that relay service located on.
	LogicalComponentPath *string `json:"logical_component_path,omitempty" yaml:"logical_component_path,omitempty" mapstructure:"logical_component_path,omitempty"`

	// This field specified the message type of the relay service REQUEST - The relay
	// service will relay a request message to the destination server REPLY - The
	// relay service will relay a reply message to the client
	MessageType PolicyTraceflowObservationRelayedLogicalMessageType `json:"message_type,omitempty" yaml:"message_type,omitempty" mapstructure:"message_type,omitempty"`

	// This field specified the IP address of the relay service.
	RelayServerAddress *IPAddress `json:"relay_server_address,omitempty" yaml:"relay_server_address,omitempty" mapstructure:"relay_server_address,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`
}

type PolicyTraceflowObservationRelayedLogicalMessageType string

const PolicyTraceflowObservationRelayedLogicalMessageTypeREPLY PolicyTraceflowObservationRelayedLogicalMessageType = "REPLY"
const PolicyTraceflowObservationRelayedLogicalMessageTypeREQUEST PolicyTraceflowObservationRelayedLogicalMessageType = "REQUEST"

var enumValues_PolicyTraceflowObservationRelayedLogicalMessageType = []interface{}{
	"REQUEST",
	"REPLY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationRelayedLogicalMessageType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PolicyTraceflowObservationRelayedLogicalMessageType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PolicyTraceflowObservationRelayedLogicalMessageType, v)
	}
	*j = PolicyTraceflowObservationRelayedLogicalMessageType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PolicyTraceflowObservationRelayedLogical) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PolicyTraceflowObservationRelayedLogical
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["message_type"]; !ok || v == nil {
		plain.MessageType = "REQUEST"
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = PolicyTraceflowObservationRelayedLogical(plain)
	return nil
}

// Detailed information about static address for the port.
type PortAddressBindingEntry struct {
	// IP Address for port binding
	IpAddress *string `json:"ip_address,omitempty" yaml:"ip_address,omitempty" mapstructure:"ip_address,omitempty"`

	// Mac address for port binding
	MacAddress *MACAddress `json:"mac_address,omitempty" yaml:"mac_address,omitempty" mapstructure:"mac_address,omitempty"`

	// VLAN Id for port binding
	VlanId *VlanID `json:"vlan_id,omitempty" yaml:"vlan_id,omitempty" mapstructure:"vlan_id,omitempty"`
}

// Detail information about port attachment
type PortAttachment struct {
	// Indicate how IP will be allocated for the port. Enum BOTH references IP pool
	// and MAC pool.  Enum NONE is no allocation.
	AllocateAddresses *PortAttachmentAllocateAddresses `json:"allocate_addresses,omitempty" yaml:"allocate_addresses,omitempty" mapstructure:"allocate_addresses,omitempty"`

	// Id used to identify/look up a child attachment behind a parent attachment
	AppId *string `json:"app_id,omitempty" yaml:"app_id,omitempty" mapstructure:"app_id,omitempty"`

	// Indicate application interface configuration for Bare Metal Server.
	BmsInterfaceConfig *AttachedInterfaceEntry `json:"bms_interface_config,omitempty" yaml:"bms_interface_config,omitempty" mapstructure:"bms_interface_config,omitempty"`

	// If type is CHILD and the parent port is on the same segment as the child port,
	// then this field should be VIF Id of the parent port. If type is CHILD and the
	// parent port is on a different segment, then this field should be policy path of
	// the parent port. If type is INDEPENDENT/STATIC, then this field should be
	// transport node Id.
	ContextId *string `json:"context_id,omitempty" yaml:"context_id,omitempty" mapstructure:"context_id,omitempty"`

	// Set to PARENT when type field is CHILD. Read only field.
	ContextType *PortAttachmentContextType `json:"context_type,omitempty" yaml:"context_type,omitempty" mapstructure:"context_type,omitempty"`

	// List of Evpn tenant VLAN IDs the Parent logical-port serves in Evpn
	// Route-Server mode. Only effective when attachment type is PARENT and the
	// logical-port is attached to vRouter VM.
	EvpnVlans []string `json:"evpn_vlans,omitempty" yaml:"evpn_vlans,omitempty" mapstructure:"evpn_vlans,omitempty"`

	// Flag to indicate if hyperbus configuration is required.
	HyperbusMode PortAttachmentHyperbusMode `json:"hyperbus_mode,omitempty" yaml:"hyperbus_mode,omitempty" mapstructure:"hyperbus_mode,omitempty"`

	// VIF UUID on NSX Manager. If the attachement type is PARENT, this property is
	// required.
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Not valid when type field is INDEPENDENT, mainly used to identify traffic from
	// different ports in container use case.
	TrafficTag *VlanID `json:"traffic_tag,omitempty" yaml:"traffic_tag,omitempty" mapstructure:"traffic_tag,omitempty"`

	// Type of port attachment. STATIC is added to replace INDEPENDENT. INDEPENDENT
	// type and PARENT type are deprecated.
	Type *PortAttachmentType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

type PortAttachmentAllocateAddresses string

const PortAttachmentAllocateAddressesBOTH PortAttachmentAllocateAddresses = "BOTH"
const PortAttachmentAllocateAddressesDHCP PortAttachmentAllocateAddresses = "DHCP"
const PortAttachmentAllocateAddressesDHCPV6 PortAttachmentAllocateAddresses = "DHCPV6"
const PortAttachmentAllocateAddressesIPPOOL PortAttachmentAllocateAddresses = "IP_POOL"
const PortAttachmentAllocateAddressesMACPOOL PortAttachmentAllocateAddresses = "MAC_POOL"
const PortAttachmentAllocateAddressesNONE PortAttachmentAllocateAddresses = "NONE"
const PortAttachmentAllocateAddressesSLAAC PortAttachmentAllocateAddresses = "SLAAC"

var enumValues_PortAttachmentAllocateAddresses = []interface{}{
	"IP_POOL",
	"MAC_POOL",
	"BOTH",
	"DHCP",
	"DHCPV6",
	"SLAAC",
	"NONE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortAttachmentAllocateAddresses) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PortAttachmentAllocateAddresses {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PortAttachmentAllocateAddresses, v)
	}
	*j = PortAttachmentAllocateAddresses(v)
	return nil
}

type PortAttachmentContextType string

const PortAttachmentContextTypePARENT PortAttachmentContextType = "PARENT"

var enumValues_PortAttachmentContextType = []interface{}{
	"PARENT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortAttachmentContextType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PortAttachmentContextType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PortAttachmentContextType, v)
	}
	*j = PortAttachmentContextType(v)
	return nil
}

type PortAttachmentHyperbusMode string

const PortAttachmentHyperbusModeDISABLE PortAttachmentHyperbusMode = "DISABLE"
const PortAttachmentHyperbusModeENABLE PortAttachmentHyperbusMode = "ENABLE"

var enumValues_PortAttachmentHyperbusMode = []interface{}{
	"ENABLE",
	"DISABLE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortAttachmentHyperbusMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PortAttachmentHyperbusMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PortAttachmentHyperbusMode, v)
	}
	*j = PortAttachmentHyperbusMode(v)
	return nil
}

type PortAttachmentType string

const PortAttachmentTypeCHILD PortAttachmentType = "CHILD"
const PortAttachmentTypeINDEPENDENT PortAttachmentType = "INDEPENDENT"
const PortAttachmentTypePARENT PortAttachmentType = "PARENT"
const PortAttachmentTypeSTATIC PortAttachmentType = "STATIC"

var enumValues_PortAttachmentType = []interface{}{
	"PARENT",
	"CHILD",
	"INDEPENDENT",
	"STATIC",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortAttachmentType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_PortAttachmentType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_PortAttachmentType, v)
	}
	*j = PortAttachmentType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *PortAttachment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain PortAttachment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.EvpnVlans) > 1000 {
		return fmt.Errorf("field %s length: must be <= %d", "evpn_vlans", 1000)
	}
	if v, ok := raw["hyperbus_mode"]; !ok || v == nil {
		plain.HyperbusMode = "DISABLE"
	}
	*j = PortAttachment(plain)
	return nil
}

// Examples- Single port "8080", Range of ports "8090-8095"
type PortElement string

type RealizedVirtualMachine struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Alarms corresponds to the JSON schema field "alarms".
	Alarms []PolicyAlarmResource `json:"alarms,omitempty" yaml:"alarms,omitempty" mapstructure:"alarms,omitempty"`

	// ComputeIds corresponds to the JSON schema field "compute_ids".
	ComputeIds []string `json:"compute_ids,omitempty" yaml:"compute_ids,omitempty" mapstructure:"compute_ids,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// HostId corresponds to the JSON schema field "host_id".
	HostId *string `json:"host_id,omitempty" yaml:"host_id,omitempty" mapstructure:"host_id,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// IntentReference corresponds to the JSON schema field "intent_reference".
	IntentReference []string `json:"intent_reference,omitempty" yaml:"intent_reference,omitempty" mapstructure:"intent_reference,omitempty"`

	// LocalIdOnHost corresponds to the JSON schema field "local_id_on_host".
	LocalIdOnHost *string `json:"local_id_on_host,omitempty" yaml:"local_id_on_host,omitempty" mapstructure:"local_id_on_host,omitempty"`

	// Possible values could be UP, DOWN, UNKNOWN, FAILURE This list is not
	// exhaustive.
	OperationalStatus *string `json:"operational_status,omitempty" yaml:"operational_status,omitempty" mapstructure:"operational_status,omitempty"`

	// It defines the root cause for operational status error.
	OperationalStatusError *string `json:"operational_status_error,omitempty" yaml:"operational_status_error,omitempty" mapstructure:"operational_status_error,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// PowerState corresponds to the JSON schema field "power_state".
	PowerState *RealizedVirtualMachinePowerState `json:"power_state,omitempty" yaml:"power_state,omitempty" mapstructure:"power_state,omitempty"`

	// Possible values could be UP, DOWN, UNKNOWN, SUCCESS This list is not
	// exhaustive.
	PublishStatus *string `json:"publish_status,omitempty" yaml:"publish_status,omitempty" mapstructure:"publish_status,omitempty"`

	// It defines the root cause for publish status error.
	PublishStatusError *string `json:"publish_status_error,omitempty" yaml:"publish_status_error,omitempty" mapstructure:"publish_status_error,omitempty"`

	// It defines error code for publish status error.
	PublishStatusErrorCode *int `json:"publish_status_error_code,omitempty" yaml:"publish_status_error_code,omitempty" mapstructure:"publish_status_error_code,omitempty"`

	// Error details for publish status.
	PublishStatusErrorDetails []ConfigurationStateElement `json:"publish_status_error_details,omitempty" yaml:"publish_status_error_details,omitempty" mapstructure:"publish_status_error_details,omitempty"`

	// This is the time when our system detects that data has been pushed to the
	// transport nodes. This is based on a poll mechanism and hence this is not the
	// accurate time when the intent was published at the data path. The value of -1
	// indicates that either the publishing is still in progress or the runtime status
	// is UNKNOWN and hence not available. The Runtime status can be UNKNOWN if one or
	// more hosts are down and the rules could not be sent to those hosts. When the
	// host comes up, the runtime status will change to SUCCESS but the publish_time
	// will show the value of the last realization time. Any new configuration change
	// after this will start reflecting the proper value for publish_time
	PublishTime *EpochMsTimestamp `json:"publish_time,omitempty" yaml:"publish_time,omitempty" mapstructure:"publish_time,omitempty"`

	// RealizationApi corresponds to the JSON schema field "realization_api".
	RealizationApi *string `json:"realization_api,omitempty" yaml:"realization_api,omitempty" mapstructure:"realization_api,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// RealizationSpecificIdentifier corresponds to the JSON schema field
	// "realization_specific_identifier".
	RealizationSpecificIdentifier *string `json:"realization_specific_identifier,omitempty" yaml:"realization_specific_identifier,omitempty" mapstructure:"realization_specific_identifier,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// It define the root cause for runtime error.
	RuntimeError *string `json:"runtime_error,omitempty" yaml:"runtime_error,omitempty" mapstructure:"runtime_error,omitempty"`

	// Possible values could be UP, DOWN, UNKNOWN, DEGRADED This list is not
	// exhaustive.
	RuntimeStatus *string `json:"runtime_status,omitempty" yaml:"runtime_status,omitempty" mapstructure:"runtime_status,omitempty"`

	// State corresponds to the JSON schema field "state".
	State *RealizedVirtualMachineState `json:"state,omitempty" yaml:"state,omitempty" mapstructure:"state,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is an approximate time taken for the realization of the intent to the data
	// path. The actual time taken could be lesser than what is reported here. The
	// value of -1 indicates that either the publishing is still in progress or the
	// runtime status is UNKNOWN and hence not available. The Runtime status can be
	// UNKNOWN if one or more hosts are down and the rules could not be sent to those
	// hosts. When the host comes up, the runtime status will change to SUCCESS but
	// the time taken for realization will show the value of the last realization
	// time. Any new configuration change after this will start reflecting the proper
	// value for time_taken_for_realization
	TimeTakenForRealization *int `json:"time_taken_for_realization,omitempty" yaml:"time_taken_for_realization,omitempty" mapstructure:"time_taken_for_realization,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type RealizedVirtualMachinePowerState string

const RealizedVirtualMachinePowerStateUNKNOWN RealizedVirtualMachinePowerState = "UNKNOWN"
const RealizedVirtualMachinePowerStateVMRUNNING RealizedVirtualMachinePowerState = "VM_RUNNING"
const RealizedVirtualMachinePowerStateVMSTOPPED RealizedVirtualMachinePowerState = "VM_STOPPED"
const RealizedVirtualMachinePowerStateVMSUSPENDED RealizedVirtualMachinePowerState = "VM_SUSPENDED"

var enumValues_RealizedVirtualMachinePowerState = []interface{}{
	"VM_RUNNING",
	"VM_STOPPED",
	"VM_SUSPENDED",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RealizedVirtualMachinePowerState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RealizedVirtualMachinePowerState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RealizedVirtualMachinePowerState, v)
	}
	*j = RealizedVirtualMachinePowerState(v)
	return nil
}

type RealizedVirtualMachineState string

const RealizedVirtualMachineStateERROR RealizedVirtualMachineState = "ERROR"
const RealizedVirtualMachineStateREALIZED RealizedVirtualMachineState = "REALIZED"
const RealizedVirtualMachineStateUNAVAILABLE RealizedVirtualMachineState = "UNAVAILABLE"
const RealizedVirtualMachineStateUNREALIZED RealizedVirtualMachineState = "UNREALIZED"

var enumValues_RealizedVirtualMachineState = []interface{}{
	"UNAVAILABLE",
	"UNREALIZED",
	"REALIZED",
	"ERROR",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RealizedVirtualMachineState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RealizedVirtualMachineState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RealizedVirtualMachineState, v)
	}
	*j = RealizedVirtualMachineState(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RealizedVirtualMachine) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain RealizedVirtualMachine
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = RealizedVirtualMachine(plain)
	return nil
}

// Ordered list of rules long with the path of PolicyServiceInstance to which the
// traffic needs to be redirected. | Please note that the scope property must be
// provided for NS redirection | policy if redirect to is a service chain. For NS,
// when redirect to is not | to the service chain, and scope is specified on
// RedirectionPolicy, it | will be ignored. The scope will be determined from
// redirect to path | instead. For EW policy, scope must not be  supplied in the
// request. | Path to either Tier0 or Tier1 is allowed as the scope. Only 1 path |
// can be specified as a scope. | Also, note that, if stateful flag is not sent, it
// will be treated as true. If statelessness is intended, false must be sent
// explicitly as the value | for stateful field.
type RedirectionPolicy struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// - Distributed Firewall - Policy framework provides five pre-defined categories
	// for classifying a security policy. They are "Ethernet","Emergency",
	// "Infrastructure" "Environment" and "Application". There is a pre-determined
	// order in which the policy framework manages the priority of these security
	// policies. Ethernet category is for supporting layer 2 firewall rules. The other
	// four categories are applicable for layer 3 rules. Amongst them, the Emergency
	// category has the highest priority followed by Infrastructure, Environment and
	// then Application rules. Administrator can choose to categorize a security
	// policy into the above categories or can choose to leave it empty. If empty it
	// will have the least precedence w.r.t the above four categories. - Edge Firewall
	// - Policy Framework for Edge Firewall provides six pre-defined categories
	// "Emergency", "SystemRules", "SharedPreRules", "LocalGatewayRules",
	// "AutoServiceRules" and "Default", in order of priority of rules. All categories
	// are allowed for Gatetway Policies that belong to 'default' Domain. However, for
	// user created domains, category is restricted to "SharedPreRules" or
	// "LocalGatewayRules" only. Also, the users can add/modify/delete rules from only
	// the "SharedPreRules" and "LocalGatewayRules" categories. If user doesn't
	// specify the category then defaulted to "Rules". System generated category is
	// used by NSX created rules, for example BFD rules. Autoplumbed category used by
	// NSX verticals to autoplumb data path rules. Finally, "Default" category is the
	// placeholder default rules with lowest in the order of priority.
	Category *string `json:"category,omitempty" yaml:"category,omitempty" mapstructure:"category,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Comments for security policy lock/unlock.
	Comments *string `json:"comments,omitempty" yaml:"comments,omitempty" mapstructure:"comments,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// This field is to indicate the internal sequence number of a policy with respect
	// to the policies across categories.
	InternalSequenceNumber *int `json:"internal_sequence_number,omitempty" yaml:"internal_sequence_number,omitempty" mapstructure:"internal_sequence_number,omitempty"`

	// A flag to indicate whether policy is a default policy.
	IsDefault *bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// Id of the user who last modified the lock for the secruity policy.
	LockModifiedBy *string `json:"lock_modified_by,omitempty" yaml:"lock_modified_by,omitempty" mapstructure:"lock_modified_by,omitempty"`

	// SecurityPolicy locked/unlocked time in epoch milliseconds.
	LockModifiedTime *EpochMsTimestamp `json:"lock_modified_time,omitempty" yaml:"lock_modified_time,omitempty" mapstructure:"lock_modified_time,omitempty"`

	// Indicates whether a security policy should be locked. If the security policy is
	// locked by a user, then no other user would be able to modify this security
	// policy. Once the user releases the lock, other users can update this security
	// policy.
	Locked bool `json:"locked,omitempty" yaml:"locked,omitempty" mapstructure:"locked,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is the read only flag which will state the direction of this | redirection
	// policy. True denotes that it is NORTH-SOUTH and false | value means it is an
	// EAST-WEST redirection policy.
	NorthSouth *bool `json:"north_south,omitempty" yaml:"north_south,omitempty" mapstructure:"north_south,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Paths to which traffic will be redirected to. As of now, only 1 is | supported.
	// Paths allowed are | 1. Policy Service Instance | 2. Service Instance Endpoint |
	// 3. Virtual Endpoint | 4. Policy Service Chain
	RedirectTo []string `json:"redirect_to,omitempty" yaml:"redirect_to,omitempty" mapstructure:"redirect_to,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// The count of rules in the policy.
	RuleCount *int `json:"rule_count,omitempty" yaml:"rule_count,omitempty" mapstructure:"rule_count,omitempty"`

	// Redirection rules that are a part of this RedirectionPolicy. At max, there can
	// be 1000 rules in a given RedirectPolicy.
	Rules []RedirectionRule `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// Provides a mechanism to apply the rules in this policy for a specified time
	// duration.
	SchedulerPath *string `json:"scheduler_path,omitempty" yaml:"scheduler_path,omitempty" mapstructure:"scheduler_path,omitempty"`

	// The list of group paths where the rules in this policy will get applied. This
	// scope will take precedence over rule level scope. Supported only for security
	// and redirection policies. In case of RedirectionPolicy, it is expected only
	// when the policy is NS and redirecting to service chain.
	Scope []string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// This field is used to resolve conflicts between security policies across
	// domains. In order to change the sequence number of a policy one can fire a POST
	// request on the policy entity with a query parameter action=revise The sequence
	// number field will reflect the value of the computed sequence number upon
	// execution of the above mentioned POST request. For scenarios where the
	// administrator is using a template to update several security policies, the only
	// way to set the sequence number is to explicitly specify the sequence number for
	// each security policy. If no sequence number is specified in the payload, a
	// value of 0 is assigned by default. If there are multiple policies with the same
	// sequence number then their order is not deterministic. If a specific order of
	// policies is desired, then one has to specify unique sequence numbers or use the
	// POST request on the policy entity with a query parameter action=revise to let
	// the framework assign a sequence number. The value of sequence number must be
	// between 0 and 999,999.
	SequenceNumber *int `json:"sequence_number,omitempty" yaml:"sequence_number,omitempty" mapstructure:"sequence_number,omitempty"`

	// Stateful or Stateless nature of security policy is enforced on all rules in
	// this security policy. When it is stateful, the state of the network connects
	// are tracked and a stateful packet inspection is performed. Layer3 security
	// policies can be stateful or stateless. By default, they are stateful. Layer2
	// security policies can only be stateless.
	Stateful *bool `json:"stateful,omitempty" yaml:"stateful,omitempty" mapstructure:"stateful,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Ensures that a 3 way TCP handshake is done before the data packets are sent.
	// tcp_strict=true is supported only for stateful security policies. If the
	// tcp_strict flag is not specified and the security policy is stateful, then
	// tcp_strict will be set to true.
	TcpStrict *bool `json:"tcp_strict,omitempty" yaml:"tcp_strict,omitempty" mapstructure:"tcp_strict,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RedirectionPolicy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain RedirectionPolicy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["locked"]; !ok || v == nil {
		plain.Locked = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.RedirectTo) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "redirect_to", 1)
	}
	if len(plain.Rules) > 1000 {
		return fmt.Errorf("field %s length: must be <= %d", "rules", 1000)
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = RedirectionPolicy(plain)
	return nil
}

type RedirectionRule struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// The action to be applied to all the services
	Action *RedirectionRuleAction `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// We need paths as duplicate names may exist for groups under different domains.
	// Along with paths we support IP Address of type IPv4 and IPv6. IP Address can be
	// in one of the format(CIDR, IP Address, Range of IP Address). In order to
	// specify all groups, use the constant "ANY". This is case insensitive. If "ANY"
	// is used, it should be the ONLY element in the group array. Error will be thrown
	// if ANY is used in conjunction with other values.
	DestinationGroups []string `json:"destination_groups,omitempty" yaml:"destination_groups,omitempty" mapstructure:"destination_groups,omitempty"`

	// If set to true, the rule gets applied on all the groups that are NOT part of
	// the destination groups. If false, the rule applies to the destination groups
	DestinationsExcluded bool `json:"destinations_excluded,omitempty" yaml:"destinations_excluded,omitempty" mapstructure:"destinations_excluded,omitempty"`

	// Define direction of traffic.
	Direction RedirectionRuleDirection `json:"direction,omitempty" yaml:"direction,omitempty" mapstructure:"direction,omitempty"`

	// Flag to deactivate the rule. Default is activated.
	Disabled bool `json:"disabled,omitempty" yaml:"disabled,omitempty" mapstructure:"disabled,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Type of IP packet that should be matched while enforcing the rule. The value is
	// set to IPV4_IPV6 for Layer3 rule if not specified. For Layer2/Ether rule the
	// value must be null.
	IpProtocol *RedirectionRuleIpProtocol `json:"ip_protocol,omitempty" yaml:"ip_protocol,omitempty" mapstructure:"ip_protocol,omitempty"`

	// A flag to indicate whether rule is a default rule.
	IsDefault *bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// Flag to enable packet logging. Default is deactivated.
	Logged bool `json:"logged,omitempty" yaml:"logged,omitempty" mapstructure:"logged,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// Text for additional notes on changes.
	Notes *string `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Holds the list of layer 7 service profile paths. These profiles accept
	// attributes and sub-attributes of various network services (e.g. L4 AppId,
	// encryption algorithm, domain name, etc) as key value pairs. Instead of Layer 7
	// service profiles you can use a L7 access profile. One of either Layer 7 service
	// profiles or L7 Access Profile can be used in firewall rule. In case of L7
	// access profile only one is allowed.
	Profiles []string `json:"profiles,omitempty" yaml:"profiles,omitempty" mapstructure:"profiles,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// This is a unique 4 byte positive number that is assigned by the system.  This
	// rule id is passed all the way down to the data path. The first 1GB (1000 to
	// 2^30) will be shared by GM and LM with zebra style striped number space. For
	// E.g 1000 to (1Million -1) by LM, (1M - 2M-1) by GM and so on.
	RuleId *int `json:"rule_id,omitempty" yaml:"rule_id,omitempty" mapstructure:"rule_id,omitempty"`

	// The list of policy paths where the rule is applied LR/Edge/T0/T1/LRP etc. Note
	// that a given rule can be applied on multiple LRs/LRPs.
	Scope []string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// This field is used to resolve conflicts between multiple Rules under Security
	// or Gateway Policy for a Domain If no sequence number is specified in the
	// payload, a value of 0 is assigned by default. If there are multiple rules with
	// the same sequence number then their order is not deterministic. If a specific
	// order of rules is desired, then one has to specify unique sequence numbers or
	// use the POST request on the rule entity with a query parameter action=revise to
	// let the framework assign a sequence number
	SequenceNumber *int `json:"sequence_number,omitempty" yaml:"sequence_number,omitempty" mapstructure:"sequence_number,omitempty"`

	// In order to specify raw services this can be used, along with services which
	// contains path to services. This can be empty or null.
	ServiceEntries []ServiceEntry `json:"service_entries,omitempty" yaml:"service_entries,omitempty" mapstructure:"service_entries,omitempty"`

	// In order to specify all services, use the constant "ANY". This is case
	// insensitive. If "ANY" is used, it should be the ONLY element in the services
	// array. Error will be thrown if ANY is used in conjunction with other values.
	Services []string `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`

	// We need paths as duplicate names may exist for groups under different domains.
	// Along with paths we support IP Address of type IPv4 and IPv6. IP Address can be
	// in one of the format(CIDR, IP Address, Range of IP Address). In order to
	// specify all groups, use the constant "ANY". This is case insensitive. If "ANY"
	// is used, it should be the ONLY element in the group array. Error will be thrown
	// if ANY is used in conjunction with other values.
	SourceGroups []string `json:"source_groups,omitempty" yaml:"source_groups,omitempty" mapstructure:"source_groups,omitempty"`

	// If set to true, the rule gets applied on all the groups that are NOT part of
	// the source groups. If false, the rule applies to the source groups
	SourcesExcluded bool `json:"sources_excluded,omitempty" yaml:"sources_excluded,omitempty" mapstructure:"sources_excluded,omitempty"`

	// User level field which will be printed in CLI and packet logs. Even though
	// there is no limitation on length of a tag, internally tag will get truncated
	// after 32 characters.
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type RedirectionRuleAction string

const RedirectionRuleActionDONOTREDIRECT RedirectionRuleAction = "DO_NOT_REDIRECT"
const RedirectionRuleActionREDIRECT RedirectionRuleAction = "REDIRECT"

var enumValues_RedirectionRuleAction = []interface{}{
	"REDIRECT",
	"DO_NOT_REDIRECT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RedirectionRuleAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RedirectionRuleAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RedirectionRuleAction, v)
	}
	*j = RedirectionRuleAction(v)
	return nil
}

type RedirectionRuleDirection string

const RedirectionRuleDirectionIN RedirectionRuleDirection = "IN"
const RedirectionRuleDirectionINOUT RedirectionRuleDirection = "IN_OUT"
const RedirectionRuleDirectionOUT RedirectionRuleDirection = "OUT"

var enumValues_RedirectionRuleDirection = []interface{}{
	"IN",
	"OUT",
	"IN_OUT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RedirectionRuleDirection) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RedirectionRuleDirection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RedirectionRuleDirection, v)
	}
	*j = RedirectionRuleDirection(v)
	return nil
}

type RedirectionRuleIpProtocol string

const RedirectionRuleIpProtocolIPV4 RedirectionRuleIpProtocol = "IPV4"
const RedirectionRuleIpProtocolIPV4IPV6 RedirectionRuleIpProtocol = "IPV4_IPV6"
const RedirectionRuleIpProtocolIPV6 RedirectionRuleIpProtocol = "IPV6"

var enumValues_RedirectionRuleIpProtocol = []interface{}{
	"IPV4",
	"IPV6",
	"IPV4_IPV6",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RedirectionRuleIpProtocol) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RedirectionRuleIpProtocol {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RedirectionRuleIpProtocol, v)
	}
	*j = RedirectionRuleIpProtocol(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RedirectionRule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain RedirectionRule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if len(plain.DestinationGroups) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "destination_groups", 128)
	}
	if v, ok := raw["destinations_excluded"]; !ok || v == nil {
		plain.DestinationsExcluded = false
	}
	if v, ok := raw["direction"]; !ok || v == nil {
		plain.Direction = "IN_OUT"
	}
	if v, ok := raw["disabled"]; !ok || v == nil {
		plain.Disabled = false
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["logged"]; !ok || v == nil {
		plain.Logged = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if plain.Notes != nil && len(*plain.Notes) > 2048 {
		return fmt.Errorf("field %s length: must be <= %d", "notes", 2048)
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Profiles) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "profiles", 128)
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if len(plain.ServiceEntries) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "service_entries", 128)
	}
	if len(plain.Services) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "services", 128)
	}
	if len(plain.SourceGroups) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "source_groups", 128)
	}
	if v, ok := raw["sources_excluded"]; !ok || v == nil {
		plain.SourcesExcluded = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = RedirectionRule(plain)
	return nil
}

type ResourceLink struct {
	// Action corresponds to the JSON schema field "action".
	Action *string `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Href corresponds to the JSON schema field "href".
	Href *string `json:"href,omitempty" yaml:"href,omitempty" mapstructure:"href,omitempty"`

	// Custom relation type (follows RFC 5988 where appropriate definitions exist)
	Rel *string `json:"rel,omitempty" yaml:"rel,omitempty" mapstructure:"rel,omitempty"`
}

// A weak reference to an NSX resource.
type ResourceReference struct {
	// Will be set to false if the referenced NSX resource has been deleted.
	IsValid *bool `json:"is_valid,omitempty" yaml:"is_valid,omitempty" mapstructure:"is_valid,omitempty"`

	// Display name of the NSX resource.
	TargetDisplayName *string `json:"target_display_name,omitempty" yaml:"target_display_name,omitempty" mapstructure:"target_display_name,omitempty"`

	// Identifier of the NSX resource.
	TargetId *string `json:"target_id,omitempty" yaml:"target_id,omitempty" mapstructure:"target_id,omitempty"`

	// Type of the NSX resource.
	TargetType *string `json:"target_type,omitempty" yaml:"target_type,omitempty" mapstructure:"target_type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ResourceReference) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ResourceReference
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.TargetDisplayName != nil && len(*plain.TargetDisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "target_display_name", 255)
	}
	if plain.TargetId != nil && len(*plain.TargetId) > 64 {
		return fmt.Errorf("field %s length: must be <= %d", "target_id", 64)
	}
	if plain.TargetType != nil && len(*plain.TargetType) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "target_type", 255)
	}
	*j = ResourceReference(plain)
	return nil
}

type RouteAdvertisementRule struct {
	// Action to advertise filtered routes to the connected Tier0 gateway. PERMIT:
	// Enables the advertisment DENY: Disables the advertisement
	Action RouteAdvertisementRuleAction `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Display name should be unique.
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Prefix operator to filter subnets. GE prefix operator filters all the routes
	// with prefix length greater than or equal to the subnets configured. EQ prefix
	// operator filter all the routes with prefix length equal to the subnets
	// configured.
	PrefixOperator RouteAdvertisementRulePrefixOperator `json:"prefix_operator,omitempty" yaml:"prefix_operator,omitempty" mapstructure:"prefix_operator,omitempty"`

	// Enable different types of route advertisements. When not specified, routes to
	// IPSec VPN local-endpoint subnets (TIER1_IPSEC_LOCAL_ENDPOINT) are automatically
	// advertised.
	RouteAdvertisementTypes []Tier1RouteAdvertisentTypes `json:"route_advertisement_types,omitempty" yaml:"route_advertisement_types,omitempty" mapstructure:"route_advertisement_types,omitempty"`

	// Network CIDRs to be routed.
	Subnets []string `json:"subnets,omitempty" yaml:"subnets,omitempty" mapstructure:"subnets,omitempty"`
}

type RouteAdvertisementRuleAction string

const RouteAdvertisementRuleActionDENY RouteAdvertisementRuleAction = "DENY"
const RouteAdvertisementRuleActionPERMIT RouteAdvertisementRuleAction = "PERMIT"

var enumValues_RouteAdvertisementRuleAction = []interface{}{
	"PERMIT",
	"DENY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RouteAdvertisementRuleAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RouteAdvertisementRuleAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RouteAdvertisementRuleAction, v)
	}
	*j = RouteAdvertisementRuleAction(v)
	return nil
}

type RouteAdvertisementRulePrefixOperator string

const RouteAdvertisementRulePrefixOperatorEQ RouteAdvertisementRulePrefixOperator = "EQ"
const RouteAdvertisementRulePrefixOperatorGE RouteAdvertisementRulePrefixOperator = "GE"

var enumValues_RouteAdvertisementRulePrefixOperator = []interface{}{
	"GE",
	"EQ",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RouteAdvertisementRulePrefixOperator) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RouteAdvertisementRulePrefixOperator {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RouteAdvertisementRulePrefixOperator, v)
	}
	*j = RouteAdvertisementRulePrefixOperator(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RouteAdvertisementRule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain RouteAdvertisementRule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["action"]; !ok || v == nil {
		plain.Action = "PERMIT"
	}
	if v, ok := raw["prefix_operator"]; !ok || v == nil {
		plain.PrefixOperator = "GE"
	}
	*j = RouteAdvertisementRule(plain)
	return nil
}

// A rule indicates the action to be performed for various types of traffic flowing
// between workload groups.
type Rule struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// The action to be applied to all the services The JUMP_TO_APPLICATION action is
	// only supported for rules created in the Environment category. Once a match is
	// hit then the rule processing will jump to the rules present in the Application
	// category, skipping all further rules in the Environment category. If no rules
	// match in the Application category then the default application rule will be
	// hit. This is applicable only for DFW.
	Action *RuleAction `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// We need paths as duplicate names may exist for groups under different domains.
	// Along with paths we support IP Address of type IPv4 and IPv6. IP Address can be
	// in one of the format(CIDR, IP Address, Range of IP Address). In order to
	// specify all groups, use the constant "ANY". This is case insensitive. If "ANY"
	// is used, it should be the ONLY element in the group array. Error will be thrown
	// if ANY is used in conjunction with other values.
	DestinationGroups []string `json:"destination_groups,omitempty" yaml:"destination_groups,omitempty" mapstructure:"destination_groups,omitempty"`

	// If set to true, the rule gets applied on all the groups that are NOT part of
	// the destination groups. If false, the rule applies to the destination groups
	DestinationsExcluded bool `json:"destinations_excluded,omitempty" yaml:"destinations_excluded,omitempty" mapstructure:"destinations_excluded,omitempty"`

	// Define direction of traffic.
	Direction RuleDirection `json:"direction,omitempty" yaml:"direction,omitempty" mapstructure:"direction,omitempty"`

	// Flag to deactivate the rule. Default is activated.
	Disabled bool `json:"disabled,omitempty" yaml:"disabled,omitempty" mapstructure:"disabled,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Type of IP packet that should be matched while enforcing the rule. The value is
	// set to IPV4_IPV6 for Layer3 rule if not specified. For Layer2/Ether rule the
	// value must be null.
	IpProtocol *RuleIpProtocol `json:"ip_protocol,omitempty" yaml:"ip_protocol,omitempty" mapstructure:"ip_protocol,omitempty"`

	// A flag to indicate whether rule is a default rule.
	IsDefault *bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// Flag to enable packet logging. Default is deactivated.
	Logged bool `json:"logged,omitempty" yaml:"logged,omitempty" mapstructure:"logged,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// Text for additional notes on changes.
	Notes *string `json:"notes,omitempty" yaml:"notes,omitempty" mapstructure:"notes,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Holds the list of layer 7 service profile paths. These profiles accept
	// attributes and sub-attributes of various network services (e.g. L4 AppId,
	// encryption algorithm, domain name, etc) as key value pairs. Instead of Layer 7
	// service profiles you can use a L7 access profile. One of either Layer 7 service
	// profiles or L7 Access Profile can be used in firewall rule. In case of L7
	// access profile only one is allowed.
	Profiles []string `json:"profiles,omitempty" yaml:"profiles,omitempty" mapstructure:"profiles,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// This is a unique 4 byte positive number that is assigned by the system.  This
	// rule id is passed all the way down to the data path. The first 1GB (1000 to
	// 2^30) will be shared by GM and LM with zebra style striped number space. For
	// E.g 1000 to (1Million -1) by LM, (1M - 2M-1) by GM and so on.
	RuleId *int `json:"rule_id,omitempty" yaml:"rule_id,omitempty" mapstructure:"rule_id,omitempty"`

	// The list of policy paths where the rule is applied LR/Edge/T0/T1/LRP etc. Note
	// that a given rule can be applied on multiple LRs/LRPs.
	Scope []string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// This field is used to resolve conflicts between multiple Rules under Security
	// or Gateway Policy for a Domain If no sequence number is specified in the
	// payload, a value of 0 is assigned by default. If there are multiple rules with
	// the same sequence number then their order is not deterministic. If a specific
	// order of rules is desired, then one has to specify unique sequence numbers or
	// use the POST request on the rule entity with a query parameter action=revise to
	// let the framework assign a sequence number
	SequenceNumber *int `json:"sequence_number,omitempty" yaml:"sequence_number,omitempty" mapstructure:"sequence_number,omitempty"`

	// In order to specify raw services this can be used, along with services which
	// contains path to services. This can be empty or null.
	ServiceEntries []ServiceEntry `json:"service_entries,omitempty" yaml:"service_entries,omitempty" mapstructure:"service_entries,omitempty"`

	// In order to specify all services, use the constant "ANY". This is case
	// insensitive. If "ANY" is used, it should be the ONLY element in the services
	// array. Error will be thrown if ANY is used in conjunction with other values.
	Services []string `json:"services,omitempty" yaml:"services,omitempty" mapstructure:"services,omitempty"`

	// We need paths as duplicate names may exist for groups under different domains.
	// Along with paths we support IP Address of type IPv4 and IPv6. IP Address can be
	// in one of the format(CIDR, IP Address, Range of IP Address). In order to
	// specify all groups, use the constant "ANY". This is case insensitive. If "ANY"
	// is used, it should be the ONLY element in the group array. Error will be thrown
	// if ANY is used in conjunction with other values.
	SourceGroups []string `json:"source_groups,omitempty" yaml:"source_groups,omitempty" mapstructure:"source_groups,omitempty"`

	// If set to true, the rule gets applied on all the groups that are NOT part of
	// the source groups. If false, the rule applies to the source groups
	SourcesExcluded bool `json:"sources_excluded,omitempty" yaml:"sources_excluded,omitempty" mapstructure:"sources_excluded,omitempty"`

	// User level field which will be printed in CLI and packet logs. Even though
	// there is no limitation on length of a tag, internally tag will get truncated
	// after 32 characters.
	Tag *string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type RuleAction string

const RuleActionALLOW RuleAction = "ALLOW"
const RuleActionDROP RuleAction = "DROP"
const RuleActionJUMPTOAPPLICATION RuleAction = "JUMP_TO_APPLICATION"
const RuleActionREJECT RuleAction = "REJECT"

var enumValues_RuleAction = []interface{}{
	"ALLOW",
	"DROP",
	"REJECT",
	"JUMP_TO_APPLICATION",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleAction) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RuleAction {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RuleAction, v)
	}
	*j = RuleAction(v)
	return nil
}

type RuleDirection string

const RuleDirectionIN RuleDirection = "IN"
const RuleDirectionINOUT RuleDirection = "IN_OUT"
const RuleDirectionOUT RuleDirection = "OUT"

var enumValues_RuleDirection = []interface{}{
	"IN",
	"OUT",
	"IN_OUT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleDirection) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RuleDirection {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RuleDirection, v)
	}
	*j = RuleDirection(v)
	return nil
}

type RuleIpProtocol string

const RuleIpProtocolIPV4 RuleIpProtocol = "IPV4"
const RuleIpProtocolIPV4IPV6 RuleIpProtocol = "IPV4_IPV6"
const RuleIpProtocolIPV6 RuleIpProtocol = "IPV6"

var enumValues_RuleIpProtocol = []interface{}{
	"IPV4",
	"IPV6",
	"IPV4_IPV6",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *RuleIpProtocol) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_RuleIpProtocol {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_RuleIpProtocol, v)
	}
	*j = RuleIpProtocol(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Rule) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Rule
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if len(plain.DestinationGroups) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "destination_groups", 128)
	}
	if v, ok := raw["destinations_excluded"]; !ok || v == nil {
		plain.DestinationsExcluded = false
	}
	if v, ok := raw["direction"]; !ok || v == nil {
		plain.Direction = "IN_OUT"
	}
	if v, ok := raw["disabled"]; !ok || v == nil {
		plain.Disabled = false
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["logged"]; !ok || v == nil {
		plain.Logged = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if plain.Notes != nil && len(*plain.Notes) > 2048 {
		return fmt.Errorf("field %s length: must be <= %d", "notes", 2048)
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Profiles) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "profiles", 128)
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if len(plain.ServiceEntries) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "service_entries", 128)
	}
	if len(plain.Services) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "services", 128)
	}
	if len(plain.SourceGroups) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "source_groups", 128)
	}
	if v, ok := raw["sources_excluded"]; !ok || v == nil {
		plain.SourcesExcluded = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Rule(plain)
	return nil
}

// Ordered list of Rules.
type SecurityPolicy struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// This field indicates the application connectivity policy for the security
	// policy.
	ApplicationConnectivityStrategy []ApplicationConnectivityStrategy `json:"application_connectivity_strategy,omitempty" yaml:"application_connectivity_strategy,omitempty" mapstructure:"application_connectivity_strategy,omitempty"`

	// - Distributed Firewall - Policy framework provides five pre-defined categories
	// for classifying a security policy. They are "Ethernet","Emergency",
	// "Infrastructure" "Environment" and "Application". There is a pre-determined
	// order in which the policy framework manages the priority of these security
	// policies. Ethernet category is for supporting layer 2 firewall rules. The other
	// four categories are applicable for layer 3 rules. Amongst them, the Emergency
	// category has the highest priority followed by Infrastructure, Environment and
	// then Application rules. Administrator can choose to categorize a security
	// policy into the above categories or can choose to leave it empty. If empty it
	// will have the least precedence w.r.t the above four categories. - Edge Firewall
	// - Policy Framework for Edge Firewall provides six pre-defined categories
	// "Emergency", "SystemRules", "SharedPreRules", "LocalGatewayRules",
	// "AutoServiceRules" and "Default", in order of priority of rules. All categories
	// are allowed for Gatetway Policies that belong to 'default' Domain. However, for
	// user created domains, category is restricted to "SharedPreRules" or
	// "LocalGatewayRules" only. Also, the users can add/modify/delete rules from only
	// the "SharedPreRules" and "LocalGatewayRules" categories. If user doesn't
	// specify the category then defaulted to "Rules". System generated category is
	// used by NSX created rules, for example BFD rules. Autoplumbed category used by
	// NSX verticals to autoplumb data path rules. Finally, "Default" category is the
	// placeholder default rules with lowest in the order of priority.
	Category *string `json:"category,omitempty" yaml:"category,omitempty" mapstructure:"category,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Comments for security policy lock/unlock.
	Comments *string `json:"comments,omitempty" yaml:"comments,omitempty" mapstructure:"comments,omitempty"`

	// This field indicates the default connectivity policy for the security policy.
	// Based on the connectivity preference, a default rule for this security policy
	// will be created. An appropriate action will be set on the rule based on the
	// value of the connectivity preference. If NONE is selected or no connectivity
	// preference is specified, then no default rule for the security policy gets
	// created. The default rule that gets created will be a any-any rule and applied
	// to entities specified in the scope of the security policy. Specifying the
	// connectivity_preference without specifying the scope is not allowed. The scope
	// has to be a Group and one cannot specify IPAddress directly in the group that
	// is used as scope. This default rule is only applicable for the Layer3 security
	// policies. ALLOWLIST - Adds a default drop rule. Administrator can then use
	// "allow" rules to allow traffic between groups DENYLIST - Adds a default allow
	// rule. Admin can then use "drop" rules to block traffic between groups
	// ALLOWLIST_ENABLE_LOGGING - Allowlisting with logging enabled
	// DENYLIST_ENABLE_LOGGING - Denylisting with logging enabled NONE - No default
	// rule is created.
	ConnectivityPreference *SecurityPolicyConnectivityPreference `json:"connectivity_preference,omitempty" yaml:"connectivity_preference,omitempty" mapstructure:"connectivity_preference,omitempty"`

	// This field indicates the default connectivity policy for the security policy.
	// Based on the connectivity strategy, a default rule for this security policy
	// will be created. An appropriate action will be set on the rule based on the
	// value of the connectivity strategy. If NONE is selected or no connectivity
	// strategy is specified, then no default rule for the security policy gets
	// created. The default rule that gets created will be a any-any rule and applied
	// to entities specified in the scope of the security policy. Specifying the
	// connectivity_strategy without specifying the scope is not allowed. The scope
	// has to be a Group and one cannot specify IPAddress directly in the group that
	// is used as scope. This default rule is only applicable for the Layer3 security
	// policies. This property is deprecated. Use the type connectivity_preference
	// instead. WHITELIST - Adds a default drop rule. Administrator can then use
	// "allow" rules (aka whitelist) to allow traffic between groups BLACKLIST - Adds
	// a default allow rule. Admin can then use "drop" rules (aka blacklist) to block
	// traffic between groups WHITELIST_ENABLE_LOGGING - Whitelising with logging
	// enabled BLACKLIST_ENABLE_LOGGING - Blacklisting with logging enabled NONE - No
	// default rule is created.
	ConnectivityStrategy *SecurityPolicyConnectivityStrategy `json:"connectivity_strategy,omitempty" yaml:"connectivity_strategy,omitempty" mapstructure:"connectivity_strategy,omitempty"`

	// Based on the value of the connectivity strategy, a default rule is created for
	// the security policy. The rule id is internally assigned by the system for this
	// default rule.
	DefaultRuleId *int `json:"default_rule_id,omitempty" yaml:"default_rule_id,omitempty" mapstructure:"default_rule_id,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// This field is to indicate the internal sequence number of a policy with respect
	// to the policies across categories.
	InternalSequenceNumber *int `json:"internal_sequence_number,omitempty" yaml:"internal_sequence_number,omitempty" mapstructure:"internal_sequence_number,omitempty"`

	// A flag to indicate whether policy is a default policy.
	IsDefault *bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// Id of the user who last modified the lock for the secruity policy.
	LockModifiedBy *string `json:"lock_modified_by,omitempty" yaml:"lock_modified_by,omitempty" mapstructure:"lock_modified_by,omitempty"`

	// SecurityPolicy locked/unlocked time in epoch milliseconds.
	LockModifiedTime *EpochMsTimestamp `json:"lock_modified_time,omitempty" yaml:"lock_modified_time,omitempty" mapstructure:"lock_modified_time,omitempty"`

	// Indicates whether a security policy should be locked. If the security policy is
	// locked by a user, then no other user would be able to modify this security
	// policy. Once the user releases the lock, other users can update this security
	// policy.
	Locked bool `json:"locked,omitempty" yaml:"locked,omitempty" mapstructure:"locked,omitempty"`

	// This property is deprecated. Flag to enable logging for all the rules in the
	// security policy. If the value is true then logging will be enabled for all the
	// rules in the security policy. If the value is false, then the rule level
	// logging value will be honored.
	LoggingEnabled bool `json:"logging_enabled,omitempty" yaml:"logging_enabled,omitempty" mapstructure:"logging_enabled,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// The count of rules in the policy.
	RuleCount *int `json:"rule_count,omitempty" yaml:"rule_count,omitempty" mapstructure:"rule_count,omitempty"`

	// Rules corresponds to the JSON schema field "rules".
	Rules []Rule `json:"rules,omitempty" yaml:"rules,omitempty" mapstructure:"rules,omitempty"`

	// Provides a mechanism to apply the rules in this policy for a specified time
	// duration.
	SchedulerPath *string `json:"scheduler_path,omitempty" yaml:"scheduler_path,omitempty" mapstructure:"scheduler_path,omitempty"`

	// The list of group paths where the rules in this policy will get applied. This
	// scope will take precedence over rule level scope. Supported only for security
	// and redirection policies. In case of RedirectionPolicy, it is expected only
	// when the policy is NS and redirecting to service chain.
	Scope []string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// This field is used to resolve conflicts between security policies across
	// domains. In order to change the sequence number of a policy one can fire a POST
	// request on the policy entity with a query parameter action=revise The sequence
	// number field will reflect the value of the computed sequence number upon
	// execution of the above mentioned POST request. For scenarios where the
	// administrator is using a template to update several security policies, the only
	// way to set the sequence number is to explicitly specify the sequence number for
	// each security policy. If no sequence number is specified in the payload, a
	// value of 0 is assigned by default. If there are multiple policies with the same
	// sequence number then their order is not deterministic. If a specific order of
	// policies is desired, then one has to specify unique sequence numbers or use the
	// POST request on the policy entity with a query parameter action=revise to let
	// the framework assign a sequence number. The value of sequence number must be
	// between 0 and 999,999.
	SequenceNumber *int `json:"sequence_number,omitempty" yaml:"sequence_number,omitempty" mapstructure:"sequence_number,omitempty"`

	// Stateful or Stateless nature of security policy is enforced on all rules in
	// this security policy. When it is stateful, the state of the network connects
	// are tracked and a stateful packet inspection is performed. Layer3 security
	// policies can be stateful or stateless. By default, they are stateful. Layer2
	// security policies can only be stateless.
	Stateful *bool `json:"stateful,omitempty" yaml:"stateful,omitempty" mapstructure:"stateful,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Ensures that a 3 way TCP handshake is done before the data packets are sent.
	// tcp_strict=true is supported only for stateful security policies. If the
	// tcp_strict flag is not specified and the security policy is stateful, then
	// tcp_strict will be set to true.
	TcpStrict *bool `json:"tcp_strict,omitempty" yaml:"tcp_strict,omitempty" mapstructure:"tcp_strict,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type SecurityPolicyConnectivityPreference string

const SecurityPolicyConnectivityPreferenceALLOWLIST SecurityPolicyConnectivityPreference = "ALLOWLIST"
const SecurityPolicyConnectivityPreferenceALLOWLISTENABLELOGGING SecurityPolicyConnectivityPreference = "ALLOWLIST_ENABLE_LOGGING"
const SecurityPolicyConnectivityPreferenceDENYLIST SecurityPolicyConnectivityPreference = "DENYLIST"
const SecurityPolicyConnectivityPreferenceDENYLISTENABLELOGGING SecurityPolicyConnectivityPreference = "DENYLIST_ENABLE_LOGGING"
const SecurityPolicyConnectivityPreferenceNONE SecurityPolicyConnectivityPreference = "NONE"

var enumValues_SecurityPolicyConnectivityPreference = []interface{}{
	"ALLOWLIST",
	"DENYLIST",
	"ALLOWLIST_ENABLE_LOGGING",
	"DENYLIST_ENABLE_LOGGING",
	"NONE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SecurityPolicyConnectivityPreference) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SecurityPolicyConnectivityPreference {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SecurityPolicyConnectivityPreference, v)
	}
	*j = SecurityPolicyConnectivityPreference(v)
	return nil
}

type SecurityPolicyConnectivityStrategy string

const SecurityPolicyConnectivityStrategyBLACKLIST SecurityPolicyConnectivityStrategy = "BLACKLIST"
const SecurityPolicyConnectivityStrategyBLACKLISTENABLELOGGING SecurityPolicyConnectivityStrategy = "BLACKLIST_ENABLE_LOGGING"
const SecurityPolicyConnectivityStrategyNONE SecurityPolicyConnectivityStrategy = "NONE"
const SecurityPolicyConnectivityStrategyWHITELIST SecurityPolicyConnectivityStrategy = "WHITELIST"
const SecurityPolicyConnectivityStrategyWHITELISTENABLELOGGING SecurityPolicyConnectivityStrategy = "WHITELIST_ENABLE_LOGGING"

var enumValues_SecurityPolicyConnectivityStrategy = []interface{}{
	"WHITELIST",
	"BLACKLIST",
	"WHITELIST_ENABLE_LOGGING",
	"BLACKLIST_ENABLE_LOGGING",
	"NONE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SecurityPolicyConnectivityStrategy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SecurityPolicyConnectivityStrategy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SecurityPolicyConnectivityStrategy, v)
	}
	*j = SecurityPolicyConnectivityStrategy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SecurityPolicy) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SecurityPolicy
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.ApplicationConnectivityStrategy) > 3 {
		return fmt.Errorf("field %s length: must be <= %d", "application_connectivity_strategy", 3)
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["locked"]; !ok || v == nil {
		plain.Locked = false
	}
	if v, ok := raw["logging_enabled"]; !ok || v == nil {
		plain.LoggingEnabled = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = SecurityPolicy(plain)
	return nil
}

// Segment configuration to attach workloads.
type Segment struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Static address binding used for the Segment. This field is deprecated and will
	// be removed in a future release. Please use address_bindings in SegmentPort to
	// configure static bindings.
	AddressBindings []PortAddressBindingEntry `json:"address_bindings,omitempty" yaml:"address_bindings,omitempty" mapstructure:"address_bindings,omitempty"`

	// Admin state represents desired state of segment. It does not reflect the state
	// of other logical entities connected/attached to the segment.
	AdminState SegmentAdminState `json:"admin_state,omitempty" yaml:"admin_state,omitempty" mapstructure:"admin_state,omitempty"`

	// Advanced configuration for Segment.
	AdvancedConfig *SegmentAdvancedConfig `json:"advanced_config,omitempty" yaml:"advanced_config,omitempty" mapstructure:"advanced_config,omitempty"`

	// Multiple distinct L2 bridge profiles can be configured.
	BridgeProfiles []BridgeProfileConfig `json:"bridge_profiles,omitempty" yaml:"bridge_profiles,omitempty" mapstructure:"bridge_profiles,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Policy path to the connecting Tier-0 or Tier-1 or label of type Tier0. Valid
	// only for segments created under Infra. This field can only be used for overlay
	// segments. VLAN backed segments cannot have connectivity path set.
	ConnectivityPath *string `json:"connectivity_path,omitempty" yaml:"connectivity_path,omitempty" mapstructure:"connectivity_path,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Policy path to DHCP server or relay configuration to use for all IPv4 & IPv6
	// subnets configured on this segment.
	DhcpConfigPath *string `json:"dhcp_config_path,omitempty" yaml:"dhcp_config_path,omitempty" mapstructure:"dhcp_config_path,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// DomainName corresponds to the JSON schema field "domain_name".
	DomainName *string `json:"domain_name,omitempty" yaml:"domain_name,omitempty" mapstructure:"domain_name,omitempty"`

	// Flag to indicate if the Segment is a Child-Segment of type EVPN.
	EvpnSegment *bool `json:"evpn_segment,omitempty" yaml:"evpn_segment,omitempty" mapstructure:"evpn_segment,omitempty"`

	// Policy path to the EvpnTenantConfig resource. Supported only for Route-Server
	// Evpn Mode. Supported only for Overlay Segments. This will be populated for both
	// Parent and Child segments participating in Evpn Route-Server Mode.
	EvpnTenantConfigPath *string `json:"evpn_tenant_config_path,omitempty" yaml:"evpn_tenant_config_path,omitempty" mapstructure:"evpn_tenant_config_path,omitempty"`

	// This property could be used for vendor specific configuration in key value
	// string pairs, the setting in extra_configs will be automatically inheritted by
	// segment ports in the Segment.
	ExtraConfigs []SegmentExtraConfig `json:"extra_configs,omitempty" yaml:"extra_configs,omitempty" mapstructure:"extra_configs,omitempty"`

	// Additional config for federation.
	FederationConfig *FederationConnectivityConfig `json:"federation_config,omitempty" yaml:"federation_config,omitempty" mapstructure:"federation_config,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// L2Extension corresponds to the JSON schema field "l2_extension".
	L2Extension *L2Extension `json:"l2_extension,omitempty" yaml:"l2_extension,omitempty" mapstructure:"l2_extension,omitempty"`

	// This property is deprecated. The property will continue to work as expected for
	// existing segments. The segments that are newly created with ls_id will be
	// ignored. Sepcify pre-creted logical switch id for Segment.
	LsId *string `json:"ls_id,omitempty" yaml:"ls_id,omitempty" mapstructure:"ls_id,omitempty"`

	// Mac pool id that associated with a Segment.
	MacPoolId *string `json:"mac_pool_id,omitempty" yaml:"mac_pool_id,omitempty" mapstructure:"mac_pool_id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// Policy path to metadata proxy configuration. Multiple distinct MD proxies can
	// be configured.
	MetadataProxyPaths []string `json:"metadata_proxy_paths,omitempty" yaml:"metadata_proxy_paths,omitempty" mapstructure:"metadata_proxy_paths,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Used for overlay connectivity of segments. The overlay_id should be allocated
	// from the pool as definied by enforcement-point. If not provided, it is
	// auto-allocated from the default pool on the enforcement-point.
	OverlayId *int `json:"overlay_id,omitempty" yaml:"overlay_id,omitempty" mapstructure:"overlay_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// If this field is not set for overlay segment, then the default of MTEP will be
	// used.
	ReplicationMode SegmentReplicationMode `json:"replication_mode,omitempty" yaml:"replication_mode,omitempty" mapstructure:"replication_mode,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Subnets corresponds to the JSON schema field "subnets".
	Subnets []SegmentSubnet `json:"subnets,omitempty" yaml:"subnets,omitempty" mapstructure:"subnets,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Policy path to the transport zone. Supported for VLAN backed segments as well
	// as Overlay Segments. - This field is required for VLAN backed Segments. - For
	// overlay Segments, it is auto assigned if only one transport zone   exists in
	// the enforcement point. Default transport zone is auto   assigned for  overlay
	// segments if none specified.
	TransportZonePath *string `json:"transport_zone_path,omitempty" yaml:"transport_zone_path,omitempty" mapstructure:"transport_zone_path,omitempty"`

	// Segment type based on configuration.
	Type *SegmentType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`

	// VLAN ids for a VLAN backed Segment. Can be a VLAN id or a range of VLAN ids
	// specified with '-' in between.
	VlanIds []string `json:"vlan_ids,omitempty" yaml:"vlan_ids,omitempty" mapstructure:"vlan_ids,omitempty"`
}

type SegmentAdminState string

const SegmentAdminStateDOWN SegmentAdminState = "DOWN"
const SegmentAdminStateUP SegmentAdminState = "UP"

var enumValues_SegmentAdminState = []interface{}{
	"UP",
	"DOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentAdminState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentAdminState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentAdminState, v)
	}
	*j = SegmentAdminState(v)
	return nil
}

type SegmentAdvancedConfig struct {
	// Policy path to IP address pools.
	AddressPoolPaths []string `json:"address_pool_paths,omitempty" yaml:"address_pool_paths,omitempty" mapstructure:"address_pool_paths,omitempty"`

	// Connectivity configuration to manually connect (ON) or disconnect (OFF)
	// Tier-0/Tier1 segment from corresponding gateway. This property does not apply
	// to VLAN backed segments. VLAN backed segments with connectivity OFF does not
	// affect its layer-2 connectivity.
	Connectivity SegmentAdvancedConfigConnectivity `json:"connectivity,omitempty" yaml:"connectivity,omitempty" mapstructure:"connectivity,omitempty"`

	// When set to true, all the ports created on this segment will behave in a hybrid
	// fashion. The hybrid port indicates to NSX that the VM intends to operate in
	// underlay mode, but retains the ability to forward egress traffic to the NSX
	// overlay network. This property is only applicable for segment created with
	// transport zone type OVERLAY_STANDARD. This property cannot be modified after
	// segment is created.
	Hybrid bool `json:"hybrid,omitempty" yaml:"hybrid,omitempty" mapstructure:"hybrid,omitempty"`

	// When set to true, any port attached to this logical switch will not be visible
	// through VC/ESX UI
	InterRouter bool `json:"inter_router,omitempty" yaml:"inter_router,omitempty" mapstructure:"inter_router,omitempty"`

	// This property is used to enable proximity routing with local egress. When set
	// to true, logical router interface (downlink) connecting Segment to Tier0/Tier1
	// gateway is configured with prefix-length 32.
	LocalEgress bool `json:"local_egress,omitempty" yaml:"local_egress,omitempty" mapstructure:"local_egress,omitempty"`

	// An ordered list of routing policies to forward traffic to the next hop.
	LocalEgressRoutingPolicies []LocalEgressRoutingEntry `json:"local_egress_routing_policies,omitempty" yaml:"local_egress_routing_policies,omitempty" mapstructure:"local_egress_routing_policies,omitempty"`

	// Enable multicast on the downlink LRP created to connect the segment to
	// Tier0/Tier1 gateway.
	Multicast *bool `json:"multicast,omitempty" yaml:"multicast,omitempty" mapstructure:"multicast,omitempty"`

	// This profile is applie dto the downlink logical router port created while
	// attaching this semgnet to tier-0 or tier-1. If this field is empty, NDRA
	// profile of the router is applied to the newly created port.
	NdraProfilePath *string `json:"ndra_profile_path,omitempty" yaml:"ndra_profile_path,omitempty" mapstructure:"ndra_profile_path,omitempty"`

	// A behaviour required for Firewall As A Service (FaaS) where the segment BUM
	// traffic is confined within the edge node that this segment belongs to.
	NodeLocalSwitch *bool `json:"node_local_switch,omitempty" yaml:"node_local_switch,omitempty" mapstructure:"node_local_switch,omitempty"`

	// Id populated by NSX when NSX on DVPG is used to indicate the source DVPG.
	// Currently, only DVPortgroups are identified as Discovered Segments. The
	// origin_id is the identifier of DVPortgroup from the source vCenter server.
	OriginId *string `json:"origin_id,omitempty" yaml:"origin_id,omitempty" mapstructure:"origin_id,omitempty"`

	// The type of source from where the DVPortgroup is discovered
	OriginType *SegmentAdvancedConfigOriginType `json:"origin_type,omitempty" yaml:"origin_type,omitempty" mapstructure:"origin_type,omitempty"`

	// The name of the switching uplink teaming policy for the Segment. This name
	// corresponds to one of the switching uplink teaming policy names listed in
	// TransportZone associated with the Segment. See transport_zone_path property
	// above for more details. When this property is not specified, the segment will
	// not have a teaming policy associated with it and the host switch's default
	// teaming policy will be used by MP.
	UplinkTeamingPolicyName *string `json:"uplink_teaming_policy_name,omitempty" yaml:"uplink_teaming_policy_name,omitempty" mapstructure:"uplink_teaming_policy_name,omitempty"`

	// This URPF mode is applied to the downlink logical router port created while
	// attaching this segment to tier-0 or tier-1.
	UrpfMode SegmentAdvancedConfigUrpfMode `json:"urpf_mode,omitempty" yaml:"urpf_mode,omitempty" mapstructure:"urpf_mode,omitempty"`
}

type SegmentAdvancedConfigConnectivity string

const SegmentAdvancedConfigConnectivityOFF SegmentAdvancedConfigConnectivity = "OFF"
const SegmentAdvancedConfigConnectivityON SegmentAdvancedConfigConnectivity = "ON"

var enumValues_SegmentAdvancedConfigConnectivity = []interface{}{
	"ON",
	"OFF",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentAdvancedConfigConnectivity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentAdvancedConfigConnectivity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentAdvancedConfigConnectivity, v)
	}
	*j = SegmentAdvancedConfigConnectivity(v)
	return nil
}

type SegmentAdvancedConfigOriginType string

const SegmentAdvancedConfigOriginTypeVCENTER SegmentAdvancedConfigOriginType = "VCENTER"

var enumValues_SegmentAdvancedConfigOriginType = []interface{}{
	"VCENTER",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentAdvancedConfigOriginType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentAdvancedConfigOriginType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentAdvancedConfigOriginType, v)
	}
	*j = SegmentAdvancedConfigOriginType(v)
	return nil
}

type SegmentAdvancedConfigUrpfMode string

const SegmentAdvancedConfigUrpfModeNONE SegmentAdvancedConfigUrpfMode = "NONE"
const SegmentAdvancedConfigUrpfModeSTRICT SegmentAdvancedConfigUrpfMode = "STRICT"

var enumValues_SegmentAdvancedConfigUrpfMode = []interface{}{
	"NONE",
	"STRICT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentAdvancedConfigUrpfMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentAdvancedConfigUrpfMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentAdvancedConfigUrpfMode, v)
	}
	*j = SegmentAdvancedConfigUrpfMode(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentAdvancedConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SegmentAdvancedConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.AddressPoolPaths) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "address_pool_paths", 1)
	}
	if v, ok := raw["connectivity"]; !ok || v == nil {
		plain.Connectivity = "ON"
	}
	if v, ok := raw["hybrid"]; !ok || v == nil {
		plain.Hybrid = false
	}
	if v, ok := raw["inter_router"]; !ok || v == nil {
		plain.InterRouter = false
	}
	if v, ok := raw["local_egress"]; !ok || v == nil {
		plain.LocalEgress = false
	}
	if plain.LocalEgressRoutingPolicies != nil && len(plain.LocalEgressRoutingPolicies) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "local_egress_routing_policies", 1)
	}
	if v, ok := raw["urpf_mode"]; !ok || v == nil {
		plain.UrpfMode = "STRICT"
	}
	*j = SegmentAdvancedConfig(plain)
	return nil
}

// DHCP IPv4 and IPv6 configurations are extended from this abstract class.
type SegmentDhcpConfig struct {
	// IP address of DNS servers for subnet. DNS server IP address must belong to the
	// same address family as segment gateway_address property.
	DnsServers []IPAddress `json:"dns_servers,omitempty" yaml:"dns_servers,omitempty" mapstructure:"dns_servers,omitempty"`

	// DHCP lease time in seconds. When specified, this property overwrites lease time
	// configured DHCP server config.
	LeaseTime int `json:"lease_time,omitempty" yaml:"lease_time,omitempty" mapstructure:"lease_time,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *SegmentDhcpConfigResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// IP address of the DHCP server in CIDR format. The server_address is mandatory
	// in case this segment has provided a dhcp_config_path and it represents a DHCP
	// server config. If this SegmentDhcpConfig is a SegmentDhcpV4Config, the address
	// must be an IPv4 address. If this is a SegmentDhcpV6Config, the address must be
	// an IPv6 address. This address must not overlap the ip-ranges of the subnet, or
	// the gateway address of the subnet, or the DHCP static-binding addresses of this
	// segment.
	ServerAddress *IPCIDRBlock `json:"server_address,omitempty" yaml:"server_address,omitempty" mapstructure:"server_address,omitempty"`
}

type SegmentDhcpConfigResourceType string

const SegmentDhcpConfigResourceTypeSegmentDhcpV4Config SegmentDhcpConfigResourceType = "SegmentDhcpV4Config"
const SegmentDhcpConfigResourceTypeSegmentDhcpV6Config SegmentDhcpConfigResourceType = "SegmentDhcpV6Config"

var enumValues_SegmentDhcpConfigResourceType = []interface{}{
	"SegmentDhcpV4Config",
	"SegmentDhcpV6Config",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentDhcpConfigResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentDhcpConfigResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentDhcpConfigResourceType, v)
	}
	*j = SegmentDhcpConfigResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentDhcpConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SegmentDhcpConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.DnsServers) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "dns_servers", 2)
	}
	if v, ok := raw["lease_time"]; !ok || v == nil {
		plain.LeaseTime = 86400.0
	}
	*j = SegmentDhcpConfig(plain)
	return nil
}

// Segment extra config is intended for supporting vendor specific configuration on
// the data path, it can be set as key value string pairs on either segment or
// segment port.
type SegmentExtraConfig struct {
	// Key value pair in string for the configuration.
	ConfigPair *UnboundedKeyValuePair `json:"config_pair,omitempty" yaml:"config_pair,omitempty" mapstructure:"config_pair,omitempty"`
}

// Policy port will create LogicalPort on LogicalSwitch corresponding to the
// Segment. Address bindings cannot be removed after realization.
type SegmentPort struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Static address binding used for the port.
	AddressBindings []PortAddressBindingEntry `json:"address_bindings,omitempty" yaml:"address_bindings,omitempty" mapstructure:"address_bindings,omitempty"`

	// AdminState corresponds to the JSON schema field "admin_state".
	AdminState SegmentPortAdminState `json:"admin_state,omitempty" yaml:"admin_state,omitempty" mapstructure:"admin_state,omitempty"`

	// Only VIF attachment is supported
	Attachment *PortAttachment `json:"attachment,omitempty" yaml:"attachment,omitempty" mapstructure:"attachment,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// This property could be used for vendor specific configuration in key value
	// string pairs. Segment port setting will override segment setting if the same
	// key was set on both segment and segment port.
	ExtraConfigs []SegmentExtraConfig `json:"extra_configs,omitempty" yaml:"extra_configs,omitempty" mapstructure:"extra_configs,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// IP Discovery module uses various mechanisms to discover address bindings being
	// used on each segment port. If a user would like to ignore any specific
	// discovered address bindings or prevent the discovery of a particular set of
	// discovered bindings, then those address bindings can be provided here.
	// Currently IP range in CIDR format is not supported.
	IgnoredAddressBindings []PortAddressBindingEntry `json:"ignored_address_bindings,omitempty" yaml:"ignored_address_bindings,omitempty" mapstructure:"ignored_address_bindings,omitempty"`

	// Set initial state when a new logical port is created. 'UNBLOCKED_VLAN' means
	// new port will be unblocked on traffic in creation, also VLAN will be set with
	// corresponding logical switch setting. This port setting can only be configured
	// at port creation, and cannot be modified. 'RESTORE_VIF' fetches and restores
	// VIF attachment from ESX host.
	InitState *SegmentPortInitState `json:"init_state,omitempty" yaml:"init_state,omitempty" mapstructure:"init_state,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// Id populated by NSX when NSX on DVPG is used to indicate the source Distributed
	// Virtual Port and the corresponding Distributed Virtual Switch. This Id is
	// populated only for ports attached to discovered segments.
	OriginId *string `json:"origin_id,omitempty" yaml:"origin_id,omitempty" mapstructure:"origin_id,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// This field will refer to the source site on which the segment port is
	// discovered. This field is populated by GM, when it receives corresponding
	// notification from LM.
	SourceSiteId *string `json:"source_site_id,omitempty" yaml:"source_site_id,omitempty" mapstructure:"source_site_id,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type SegmentPortAdminState string

const SegmentPortAdminStateDOWN SegmentPortAdminState = "DOWN"
const SegmentPortAdminStateUP SegmentPortAdminState = "UP"

var enumValues_SegmentPortAdminState = []interface{}{
	"UP",
	"DOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentPortAdminState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentPortAdminState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentPortAdminState, v)
	}
	*j = SegmentPortAdminState(v)
	return nil
}

type SegmentPortInitState string

const SegmentPortInitStateRESTOREVIF SegmentPortInitState = "RESTORE_VIF"
const SegmentPortInitStateUNBLOCKEDVLAN SegmentPortInitState = "UNBLOCKED_VLAN"

var enumValues_SegmentPortInitState = []interface{}{
	"UNBLOCKED_VLAN",
	"RESTORE_VIF",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentPortInitState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentPortInitState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentPortInitState, v)
	}
	*j = SegmentPortInitState(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentPort) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SegmentPort
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.AddressBindings) > 512 {
		return fmt.Errorf("field %s length: must be <= %d", "address_bindings", 512)
	}
	if v, ok := raw["admin_state"]; !ok || v == nil {
		plain.AdminState = "UP"
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.IgnoredAddressBindings) > 16 {
		return fmt.Errorf("field %s length: must be <= %d", "ignored_address_bindings", 16)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = SegmentPort(plain)
	return nil
}

type SegmentReplicationMode string

const SegmentReplicationModeMTEP SegmentReplicationMode = "MTEP"
const SegmentReplicationModeSOURCE SegmentReplicationMode = "SOURCE"

var enumValues_SegmentReplicationMode = []interface{}{
	"MTEP",
	"SOURCE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentReplicationMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentReplicationMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentReplicationMode, v)
	}
	*j = SegmentReplicationMode(v)
	return nil
}

type SegmentSubnet struct {
	// Additional DHCP configuration for current subnet.
	DhcpConfig *SegmentDhcpConfig `json:"dhcp_config,omitempty" yaml:"dhcp_config,omitempty" mapstructure:"dhcp_config,omitempty"`

	// DHCP address ranges are used for dynamic IP allocation. Supports address range
	// and CIDR formats. First valid host address from the first value is assigned to
	// DHCP server IP address. Existing values cannot be deleted or modified, but
	// additional DHCP ranges can be added.
	DhcpRanges []IPElement `json:"dhcp_ranges,omitempty" yaml:"dhcp_ranges,omitempty" mapstructure:"dhcp_ranges,omitempty"`

	// Gateway IP address in CIDR format for both IPv4 and IPv6.
	GatewayAddress *string `json:"gateway_address,omitempty" yaml:"gateway_address,omitempty" mapstructure:"gateway_address,omitempty"`

	// Network CIDR for this subnet calculated from gateway_addresses and prefix_len.
	Network *string `json:"network,omitempty" yaml:"network,omitempty" mapstructure:"network,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentSubnet) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain SegmentSubnet
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.DhcpRanges != nil && len(plain.DhcpRanges) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "dhcp_ranges", 1)
	}
	if len(plain.DhcpRanges) > 99 {
		return fmt.Errorf("field %s length: must be <= %d", "dhcp_ranges", 99)
	}
	*j = SegmentSubnet(plain)
	return nil
}

type SegmentType string

const SegmentTypeDISCONNECTED SegmentType = "DISCONNECTED"
const SegmentTypeEXTENDED SegmentType = "EXTENDED"
const SegmentTypeROUTED SegmentType = "ROUTED"
const SegmentTypeROUTEDANDEXTENDED SegmentType = "ROUTED_AND_EXTENDED"

var enumValues_SegmentType = []interface{}{
	"ROUTED",
	"EXTENDED",
	"ROUTED_AND_EXTENDED",
	"DISCONNECTED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SegmentType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_SegmentType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_SegmentType, v)
	}
	*j = SegmentType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Segment) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Segment
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if len(plain.AddressBindings) > 512 {
		return fmt.Errorf("field %s length: must be <= %d", "address_bindings", 512)
	}
	if v, ok := raw["admin_state"]; !ok || v == nil {
		plain.AdminState = "UP"
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if v, ok := raw["replication_mode"]; !ok || v == nil {
		plain.ReplicationMode = "MTEP"
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Segment(plain)
	return nil
}

// The server will populate this field when returing the resource. Ignored on PUT
// and POST.
type SelfResourceLink struct {
	// Action corresponds to the JSON schema field "action".
	Action *string `json:"action,omitempty" yaml:"action,omitempty" mapstructure:"action,omitempty"`

	// Href corresponds to the JSON schema field "href".
	Href *string `json:"href,omitempty" yaml:"href,omitempty" mapstructure:"href,omitempty"`

	// Custom relation type (follows RFC 5988 where appropriate definitions exist)
	Rel *string `json:"rel,omitempty" yaml:"rel,omitempty" mapstructure:"rel,omitempty"`
}

// Used while defining a CommunicationEntry. A service may have multiple service
// entries.
type Service struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// The flag, if true, indicates that service is created in the system by default.
	// Such default services can't be modified/deleted.
	IsDefault bool `json:"is_default,omitempty" yaml:"is_default,omitempty" mapstructure:"is_default,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Service entries for this service
	ServiceEntries []ServiceEntry `json:"service_entries,omitempty" yaml:"service_entries,omitempty" mapstructure:"service_entries,omitempty"`

	// ServiceType corresponds to the JSON schema field "service_type".
	ServiceType *string `json:"service_type,omitempty" yaml:"service_type,omitempty" mapstructure:"service_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ServiceEntry struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType *ServiceEntryResourceType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type ServiceEntryResourceType string

const ServiceEntryResourceTypeALGTypeServiceEntry ServiceEntryResourceType = "ALGTypeServiceEntry"
const ServiceEntryResourceTypeEtherTypeServiceEntry ServiceEntryResourceType = "EtherTypeServiceEntry"
const ServiceEntryResourceTypeICMPTypeServiceEntry ServiceEntryResourceType = "ICMPTypeServiceEntry"
const ServiceEntryResourceTypeIGMPTypeServiceEntry ServiceEntryResourceType = "IGMPTypeServiceEntry"
const ServiceEntryResourceTypeIPProtocolServiceEntry ServiceEntryResourceType = "IPProtocolServiceEntry"
const ServiceEntryResourceTypeL4PortSetServiceEntry ServiceEntryResourceType = "L4PortSetServiceEntry"
const ServiceEntryResourceTypeNestedServiceServiceEntry ServiceEntryResourceType = "NestedServiceServiceEntry"

var enumValues_ServiceEntryResourceType = []interface{}{
	"IPProtocolServiceEntry",
	"IGMPTypeServiceEntry",
	"ICMPTypeServiceEntry",
	"ALGTypeServiceEntry",
	"L4PortSetServiceEntry",
	"EtherTypeServiceEntry",
	"NestedServiceServiceEntry",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServiceEntryResourceType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_ServiceEntryResourceType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_ServiceEntryResourceType, v)
	}
	*j = ServiceEntryResourceType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ServiceEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain ServiceEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = ServiceEntry(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Service) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Service
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["is_default"]; !ok || v == nil {
		plain.IsDefault = false
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Service(plain)
	return nil
}

// Index for cross site allocation for edge cluster and its members referred by
// gateway.
type SiteAllocationIndexForEdge struct {
	// Unqiue edge cluster node index across sites based on stretch of the Gateway.
	// For example, if a Gateway is streched to sites S1 with one edge cluster of 3
	// nodes and site S2 with one edge cluster of 2 nodes, the in the Global Manager
	// will allocate the index for 5 edge nodes and 2 cluster in the rage 0 to 7.
	Index *int `json:"index,omitempty" yaml:"index,omitempty" mapstructure:"index,omitempty"`

	// TargetResourcePath corresponds to the JSON schema field "target_resource_path".
	TargetResourcePath *string `json:"target_resource_path,omitempty" yaml:"target_resource_path,omitempty" mapstructure:"target_resource_path,omitempty"`
}

type Tag struct {
	// Tag searches may optionally be restricted by scope
	Scope string `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// Identifier meaningful to user with maximum length of 256 characters
	Tag string `json:"tag,omitempty" yaml:"tag,omitempty" mapstructure:"tag,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tag) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Tag
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["scope"]; !ok || v == nil {
		plain.Scope = ""
	}
	if len(plain.Scope) > 128 {
		return fmt.Errorf("field %s length: must be <= %d", "scope", 128)
	}
	if v, ok := raw["tag"]; !ok || v == nil {
		plain.Tag = ""
	}
	*j = Tag(plain)
	return nil
}

type TcpHeader struct {
	// DstPort corresponds to the JSON schema field "dst_port".
	DstPort *int `json:"dst_port,omitempty" yaml:"dst_port,omitempty" mapstructure:"dst_port,omitempty"`

	// SrcPort corresponds to the JSON schema field "src_port".
	SrcPort *int `json:"src_port,omitempty" yaml:"src_port,omitempty" mapstructure:"src_port,omitempty"`

	// TcpFlags corresponds to the JSON schema field "tcp_flags".
	TcpFlags *int `json:"tcp_flags,omitempty" yaml:"tcp_flags,omitempty" mapstructure:"tcp_flags,omitempty"`
}

// Tier-0 configuration for external connectivity.
type Tier0 struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// NSX specific configuration for tier-0
	AdvancedConfig *Tier0AdvancedConfig `json:"advanced_config,omitempty" yaml:"advanced_config,omitempty" mapstructure:"advanced_config,omitempty"`

	// Maximum number of ARP entries per transport node.
	ArpLimit *int `json:"arp_limit,omitempty" yaml:"arp_limit,omitempty" mapstructure:"arp_limit,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Indicates if logging should be enabled for the default whitelisting rule. This
	// field is deprecated and recommended to change Rule logging field. Note that
	// this field is not synchronized with default logging field.
	DefaultRuleLogging bool `json:"default_rule_logging,omitempty" yaml:"default_rule_logging,omitempty" mapstructure:"default_rule_logging,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// DHCP configuration for Segments connected to Tier-0. DHCP service is configured
	// in relay mode.
	DhcpConfigPaths []string `json:"dhcp_config_paths,omitempty" yaml:"dhcp_config_paths,omitempty" mapstructure:"dhcp_config_paths,omitempty"`

	// Disable or enable gateway fiewall.
	DisableFirewall bool `json:"disable_firewall,omitempty" yaml:"disable_firewall,omitempty" mapstructure:"disable_firewall,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// This field is enable that each edge node has a distinct route distinguisher per
	// edge node.
	EnableRdPerEdge *bool `json:"enable_rd_per_edge,omitempty" yaml:"enable_rd_per_edge,omitempty" mapstructure:"enable_rd_per_edge,omitempty"`

	// Determines the behavior when a Tier-0 instance in ACTIVE-STANDBY
	// high-availability mode restarts after a failure. If set to PREEMPTIVE, the
	// preferred node will take over, even if it causes another failure. If set to
	// NON_PREEMPTIVE, then the instance that restarted will remain secondary. This
	// property is not used when the ha_mode property is set to ACTIVE_ACTIVE. Only
	// applicable when edge cluster is configured in Tier0 locale-service.
	FailoverMode Tier0FailoverMode `json:"failover_mode,omitempty" yaml:"failover_mode,omitempty" mapstructure:"failover_mode,omitempty"`

	// Additional config for federation.
	FederationConfig *FederationGatewayConfig `json:"federation_config,omitempty" yaml:"federation_config,omitempty" mapstructure:"federation_config,omitempty"`

	// This field is deprecated and recommended to change Rule action field. Note that
	// this field is not synchronized with default rule field.
	ForceWhitelisting bool `json:"force_whitelisting,omitempty" yaml:"force_whitelisting,omitempty" mapstructure:"force_whitelisting,omitempty"`

	// Specify high-availability mode for Tier-0. Default is ACTIVE_ACTIVE. When
	// ha_mode is changed from ACTIVE_ACTIVE to ACTIVE_STANDBY, inter SR iBGP (in BGP)
	// is disabled. Changing ha_mode from ACTIVE_STANDBY to ACTIVE_ACTIVE will enable
	// inter SR iBGP (in BGP) and previously configured preferred edge nodes (in Tier0
	// locale-service) are removed.
	HaMode Tier0HaMode `json:"ha_mode,omitempty" yaml:"ha_mode,omitempty" mapstructure:"ha_mode,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Specify subnets that are used to assign addresses to logical links connecting
	// service routers and distributed routers. Only IPv4 addresses are supported.
	// When not specified, subnet 169.254.0.0/24 is assigned by default in
	// ACTIVE_ACTIVE HA mode or 169.254.0.0/28 in ACTIVE_STANDBY mode.
	InternalTransitSubnets []string `json:"internal_transit_subnets,omitempty" yaml:"internal_transit_subnets,omitempty" mapstructure:"internal_transit_subnets,omitempty"`

	// Inter site routing configuration when the gateway is streched.
	IntersiteConfig *IntersiteGatewayConfig `json:"intersite_config,omitempty" yaml:"intersite_config,omitempty" mapstructure:"intersite_config,omitempty"`

	// IPv6 NDRA and DAD profiles configuration on Tier0. Either or both NDRA and/or
	// DAD profiles can be configured.
	Ipv6ProfilePaths []string `json:"ipv6_profile_paths,omitempty" yaml:"ipv6_profile_paths,omitempty" mapstructure:"ipv6_profile_paths,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// If you are using EVPN service, then route distinguisher administrator address
	// should be defined if you need auto generation of route distinguisher on your
	// VRF configuration.
	RdAdminField *IPAddress `json:"rd_admin_field,omitempty" yaml:"rd_admin_field,omitempty" mapstructure:"rd_admin_field,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// For ACTIVE-ACTIVE, this is used to enable/disable stateful services.
	StatefulServices *Tier0StatefulServicesConfig `json:"stateful_services,omitempty" yaml:"stateful_services,omitempty" mapstructure:"stateful_services,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Specify transit subnets that are used to assign addresses to logical links
	// connecting tier-0 and tier-1s. Both IPv4 and IPv6 addresses are supported. When
	// not specified, subnet 100.64.0.0/16 is configured by default. When modifying,
	// for stateful active-active Tier-0 number of IPs should be at least attached
	// Tier-1s count * 16 and for other type of Tier-0 number of IPs should be at
	// least attached Tier-1s count * 2. Modification not allowed if there are child
	// tier-0 VRFs and there are any Tier-1s connected to those VRFs. The value in VRF
	// tier-0 is always inherited from the parent.
	TransitSubnets []string `json:"transit_subnets,omitempty" yaml:"transit_subnets,omitempty" mapstructure:"transit_subnets,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`

	// VRF config, required for VRF Tier0.
	VrfConfig *Tier0VrfConfig `json:"vrf_config,omitempty" yaml:"vrf_config,omitempty" mapstructure:"vrf_config,omitempty"`

	// Specify subnets that are used to assign addresses to logical links connecting
	// default T0 and child VRFs. When not specified, subnet 169.254.2.0/23 is
	// assigned by default.
	VrfTransitSubnets []string `json:"vrf_transit_subnets,omitempty" yaml:"vrf_transit_subnets,omitempty" mapstructure:"vrf_transit_subnets,omitempty"`
}

// NSX specific configuration for tier-0
type Tier0AdvancedConfig struct {
	// Connectivity configuration to manually connect (ON) or disconnect (OFF)
	// Tier-0/Tier1 segment from corresponding gateway. This property does not apply
	// to VLAN backed segments. VLAN backed segments with connectivity OFF does not
	// affect its layer-2 connectivity.
	Connectivity Tier0AdvancedConfigConnectivity `json:"connectivity,omitempty" yaml:"connectivity,omitempty" mapstructure:"connectivity,omitempty"`

	// Extra time in seconds the router must wait before sending the UP notification
	// after the peer routing session is established. Default means forward
	// immediately. VRF logical router will set it same as parent logical router.The
	// functionality of this timer is to ensure that a given node when coming up does
	// not claim as active until it has learned the northbound routes. This minimizes
	// any impact on traffic. 5 seconds is a smarter default as it allows to learn a
	// few thousand routes (which should cover a lot of customers). Customers that
	// have larger scale of course today would have to set it to higher value.
	// Exception for the this default setting is single node case, i.e; no redundancy
	// (which is anyway not recommended,not sure if anyone deploys like that). For
	// single node case, it should be set to 0.
	ForwardingUpTimer int `json:"forwarding_up_timer,omitempty" yaml:"forwarding_up_timer,omitempty" mapstructure:"forwarding_up_timer,omitempty"`
}

type Tier0AdvancedConfigConnectivity string

const Tier0AdvancedConfigConnectivityOFF Tier0AdvancedConfigConnectivity = "OFF"
const Tier0AdvancedConfigConnectivityON Tier0AdvancedConfigConnectivity = "ON"

var enumValues_Tier0AdvancedConfigConnectivity = []interface{}{
	"ON",
	"OFF",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier0AdvancedConfigConnectivity) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Tier0AdvancedConfigConnectivity {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Tier0AdvancedConfigConnectivity, v)
	}
	*j = Tier0AdvancedConfigConnectivity(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier0AdvancedConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Tier0AdvancedConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["connectivity"]; !ok || v == nil {
		plain.Connectivity = "ON"
	}
	if v, ok := raw["forwarding_up_timer"]; !ok || v == nil {
		plain.ForwardingUpTimer = 5.0
	}
	*j = Tier0AdvancedConfig(plain)
	return nil
}

type Tier0FailoverMode string

const Tier0FailoverModeNONPREEMPTIVE Tier0FailoverMode = "NON_PREEMPTIVE"
const Tier0FailoverModePREEMPTIVE Tier0FailoverMode = "PREEMPTIVE"

var enumValues_Tier0FailoverMode = []interface{}{
	"PREEMPTIVE",
	"NON_PREEMPTIVE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier0FailoverMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Tier0FailoverMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Tier0FailoverMode, v)
	}
	*j = Tier0FailoverMode(v)
	return nil
}

type Tier0HaMode string

const Tier0HaModeACTIVEACTIVE Tier0HaMode = "ACTIVE_ACTIVE"
const Tier0HaModeACTIVESTANDBY Tier0HaMode = "ACTIVE_STANDBY"

var enumValues_Tier0HaMode = []interface{}{
	"ACTIVE_ACTIVE",
	"ACTIVE_STANDBY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier0HaMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Tier0HaMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Tier0HaMode, v)
	}
	*j = Tier0HaMode(v)
	return nil
}

// Tier0 stateful services config to define stateful
type Tier0StatefulServicesConfig struct {
	// This is used to enable or disable ACTIVE-ACTIVE stateful services.
	Enabled bool `json:"enabled,omitempty" yaml:"enabled,omitempty" mapstructure:"enabled,omitempty"`

	// Redirection policy to load balance traffic among nodes IP_HASH: Hash Source IP
	// or destination ip to redirect packet for load sharing and stateful services.
	// NONE: Disable redirection. It requires user to define static traffic group per
	// edge node and expects external router to forward return packet back to the same
	// edge node. SRC_DST_IP_HASH: Hash both source and desitnation ip to redirect
	// packet for load sharing. This mode doesn't support NAT and presumes source and
	// destination IP remains same in either direction.
	RedirectionPolicy Tier0StatefulServicesConfigRedirectionPolicy `json:"redirection_policy,omitempty" yaml:"redirection_policy,omitempty" mapstructure:"redirection_policy,omitempty"`
}

type Tier0StatefulServicesConfigRedirectionPolicy string

const Tier0StatefulServicesConfigRedirectionPolicyIPHASH Tier0StatefulServicesConfigRedirectionPolicy = "IP_HASH"
const Tier0StatefulServicesConfigRedirectionPolicyNONE Tier0StatefulServicesConfigRedirectionPolicy = "NONE"
const Tier0StatefulServicesConfigRedirectionPolicySRCDSTIPHASH Tier0StatefulServicesConfigRedirectionPolicy = "SRC_DST_IP_HASH"

var enumValues_Tier0StatefulServicesConfigRedirectionPolicy = []interface{}{
	"IP_HASH",
	"NONE",
	"SRC_DST_IP_HASH",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier0StatefulServicesConfigRedirectionPolicy) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Tier0StatefulServicesConfigRedirectionPolicy {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Tier0StatefulServicesConfigRedirectionPolicy, v)
	}
	*j = Tier0StatefulServicesConfigRedirectionPolicy(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier0StatefulServicesConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Tier0StatefulServicesConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["enabled"]; !ok || v == nil {
		plain.Enabled = false
	}
	if v, ok := raw["redirection_policy"]; !ok || v == nil {
		plain.RedirectionPolicy = "IP_HASH"
	}
	*j = Tier0StatefulServicesConfig(plain)
	return nil
}

// Tier-0 vrf configuration.
type Tier0VrfConfig struct {
	// It is required for VRF to participate in the EVPN service in ROUTE_SERVER mode.
	EvpnL2VniConfig *VrfEvpnL2VniConfig `json:"evpn_l2_vni_config,omitempty" yaml:"evpn_l2_vni_config,omitempty" mapstructure:"evpn_l2_vni_config,omitempty"`

	// L3 VNI associated with the VRF for overlay traffic of ethernet virtual private
	// network (EVPN). It must be unique and available from the VNI pool defined for
	// EVPN service. It is required for VRF to participate in the EVPN service in
	// INLINE mode.
	EvpnTransitVni *int `json:"evpn_transit_vni,omitempty" yaml:"evpn_transit_vni,omitempty" mapstructure:"evpn_transit_vni,omitempty"`

	// route distinguisher pool for edge nodes.
	RdPerEdgePool []string `json:"rd_per_edge_pool,omitempty" yaml:"rd_per_edge_pool,omitempty" mapstructure:"rd_per_edge_pool,omitempty"`

	// Route distinguisher with format in IPAddress:<number> or ASN:<number>.
	RouteDistinguisher *string `json:"route_distinguisher,omitempty" yaml:"route_distinguisher,omitempty" mapstructure:"route_distinguisher,omitempty"`

	// Route targets.
	RouteTargets []VrfRouteTargets `json:"route_targets,omitempty" yaml:"route_targets,omitempty" mapstructure:"route_targets,omitempty"`

	// Default tier0 path. Cannot be modified after realization.
	Tier0Path *string `json:"tier0_path,omitempty" yaml:"tier0_path,omitempty" mapstructure:"tier0_path,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier0VrfConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Tier0VrfConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.RouteTargets != nil && len(plain.RouteTargets) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "route_targets", 1)
	}
	if len(plain.RouteTargets) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "route_targets", 1)
	}
	*j = Tier0VrfConfig(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier0) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Tier0
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["default_rule_logging"]; !ok || v == nil {
		plain.DefaultRuleLogging = false
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if len(plain.DhcpConfigPaths) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "dhcp_config_paths", 1)
	}
	if v, ok := raw["disable_firewall"]; !ok || v == nil {
		plain.DisableFirewall = false
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["failover_mode"]; !ok || v == nil {
		plain.FailoverMode = "NON_PREEMPTIVE"
	}
	if v, ok := raw["force_whitelisting"]; !ok || v == nil {
		plain.ForceWhitelisting = false
	}
	if v, ok := raw["ha_mode"]; !ok || v == nil {
		plain.HaMode = "ACTIVE_ACTIVE"
	}
	if len(plain.InternalTransitSubnets) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "internal_transit_subnets", 1)
	}
	if len(plain.Ipv6ProfilePaths) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "ipv6_profile_paths", 2)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	if len(plain.VrfTransitSubnets) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "vrf_transit_subnets", 1)
	}
	*j = Tier0(plain)
	return nil
}

// Tier-1 instance configuration.
type Tier1 struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Maximum number of ARP entries per transport node.
	ArpLimit *int `json:"arp_limit,omitempty" yaml:"arp_limit,omitempty" mapstructure:"arp_limit,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Indicates if logging should be enabled for the default whitelisting rule. This
	// field is deprecated and recommended to change Rule logging field. Note that
	// this field is not synchronized with default logging field.
	DefaultRuleLogging bool `json:"default_rule_logging,omitempty" yaml:"default_rule_logging,omitempty" mapstructure:"default_rule_logging,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// DHCP configuration for Segments connected to Tier-1. DHCP service is enabled in
	// relay mode.
	DhcpConfigPaths []string `json:"dhcp_config_paths,omitempty" yaml:"dhcp_config_paths,omitempty" mapstructure:"dhcp_config_paths,omitempty"`

	// Disable or enable gateway fiewall.
	DisableFirewall bool `json:"disable_firewall,omitempty" yaml:"disable_firewall,omitempty" mapstructure:"disable_firewall,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Flag to enable standby service router relocation. Standby relocation is not
	// enabled until edge cluster is configured for Tier1.
	EnableStandbyRelocation bool `json:"enable_standby_relocation,omitempty" yaml:"enable_standby_relocation,omitempty" mapstructure:"enable_standby_relocation,omitempty"`

	// Determines the behavior when a Tier-1 instance restarts after a failure. If set
	// to PREEMPTIVE, the preferred node will take over, even if it causes another
	// failure. If set to NON_PREEMPTIVE, then the instance that restarted will remain
	// secondary. Only applicable when edge cluster is configured in Tier1
	// locale-service.
	FailoverMode Tier1FailoverMode `json:"failover_mode,omitempty" yaml:"failover_mode,omitempty" mapstructure:"failover_mode,omitempty"`

	// Additional config for federation.
	FederationConfig *FederationGatewayConfig `json:"federation_config,omitempty" yaml:"federation_config,omitempty" mapstructure:"federation_config,omitempty"`

	// This field is deprecated and recommended to change Rule action field. Note that
	// this field is not synchornied with default rule field.
	ForceWhitelisting bool `json:"force_whitelisting,omitempty" yaml:"force_whitelisting,omitempty" mapstructure:"force_whitelisting,omitempty"`

	// Specify high-availability mode for Tier-1.If Tier-1 is service router, HaMode
	// will be set as ACTIVE_STANDBY. If Tier-1 is distributed router, HaMode will be
	// set as null.
	HaMode *Tier1HaMode `json:"ha_mode,omitempty" yaml:"ha_mode,omitempty" mapstructure:"ha_mode,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// Inter site routing configuration when the gateway is streched.
	IntersiteConfig *IntersiteGatewayConfig `json:"intersite_config,omitempty" yaml:"intersite_config,omitempty" mapstructure:"intersite_config,omitempty"`

	// Configuration IPv6 NDRA and DAD profiles. Either or both NDRA and/or DAD
	// profiles can be configured.
	Ipv6ProfilePaths []string `json:"ipv6_profile_paths,omitempty" yaml:"ipv6_profile_paths,omitempty" mapstructure:"ipv6_profile_paths,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// Supports edge node allocation at different sizes for routing and load balancer
	// service to meet performance and scalability requirements.   ROUTING: Allocate
	// edge node to provide routing services.   LB_SMALL, LB_MEDIUM, LB_LARGE,
	// LB_XLARGE: Specify size of load balancer service that will be configured on
	// TIER1 gateway.
	PoolAllocation Tier1PoolAllocation `json:"pool_allocation,omitempty" yaml:"pool_allocation,omitempty" mapstructure:"pool_allocation,omitempty"`

	// QoS Profile configuration for Tier1 router link connected to Tier0 gateway.
	QosProfile *GatewayQosProfileConfig `json:"qos_profile,omitempty" yaml:"qos_profile,omitempty" mapstructure:"qos_profile,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// RouteAdvertisementRules corresponds to the JSON schema field
	// "route_advertisement_rules".
	RouteAdvertisementRules []RouteAdvertisementRule `json:"route_advertisement_rules,omitempty" yaml:"route_advertisement_rules,omitempty" mapstructure:"route_advertisement_rules,omitempty"`

	// Enable different types of route advertisements. When not specified, routes to
	// IPSec VPN local-endpoint subnets (TIER1_IPSEC_LOCAL_ENDPOINT) are automatically
	// advertised.
	RouteAdvertisementTypes []Tier1RouteAdvertisentTypes `json:"route_advertisement_types,omitempty" yaml:"route_advertisement_types,omitempty" mapstructure:"route_advertisement_types,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// The reference to the Tier-0 instance using the policy path of the Tier-0 or
	// label of type Provider. Specify the Tier-1 connectivity to Tier-0 instance. .
	Tier0Path *string `json:"tier0_path,omitempty" yaml:"tier0_path,omitempty" mapstructure:"tier0_path,omitempty"`

	// Tier1 connectivity type for reference. Property value is not validated with
	// Tier1 configuration.   ROUTED: Tier1 is connected to Tier0 gateway and routing
	// is enabled.   ISOLATED: Tier1 is not connected to any Tier0 gateway.   NATTED:
	// Tier1 is in ROUTED type with NAT configured locally.
	Type *Tier1Type `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

type Tier1FailoverMode string

const Tier1FailoverModeNONPREEMPTIVE Tier1FailoverMode = "NON_PREEMPTIVE"
const Tier1FailoverModePREEMPTIVE Tier1FailoverMode = "PREEMPTIVE"

var enumValues_Tier1FailoverMode = []interface{}{
	"PREEMPTIVE",
	"NON_PREEMPTIVE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier1FailoverMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Tier1FailoverMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Tier1FailoverMode, v)
	}
	*j = Tier1FailoverMode(v)
	return nil
}

type Tier1HaMode string

const Tier1HaModeACTIVEACTIVE Tier1HaMode = "ACTIVE_ACTIVE"
const Tier1HaModeACTIVESTANDBY Tier1HaMode = "ACTIVE_STANDBY"

var enumValues_Tier1HaMode = []interface{}{
	"ACTIVE_STANDBY",
	"ACTIVE_ACTIVE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier1HaMode) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Tier1HaMode {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Tier1HaMode, v)
	}
	*j = Tier1HaMode(v)
	return nil
}

type Tier1PoolAllocation string

const Tier1PoolAllocationLBLARGE Tier1PoolAllocation = "LB_LARGE"
const Tier1PoolAllocationLBMEDIUM Tier1PoolAllocation = "LB_MEDIUM"
const Tier1PoolAllocationLBSMALL Tier1PoolAllocation = "LB_SMALL"
const Tier1PoolAllocationLBXLARGE Tier1PoolAllocation = "LB_XLARGE"
const Tier1PoolAllocationROUTING Tier1PoolAllocation = "ROUTING"

var enumValues_Tier1PoolAllocation = []interface{}{
	"ROUTING",
	"LB_SMALL",
	"LB_MEDIUM",
	"LB_LARGE",
	"LB_XLARGE",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier1PoolAllocation) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Tier1PoolAllocation {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Tier1PoolAllocation, v)
	}
	*j = Tier1PoolAllocation(v)
	return nil
}

type Tier1RouteAdvertisentTypes string

const Tier1RouteAdvertisentTypesTIER1CONNECTED Tier1RouteAdvertisentTypes = "TIER1_CONNECTED"
const Tier1RouteAdvertisentTypesTIER1DNSFORWARDERIP Tier1RouteAdvertisentTypes = "TIER1_DNS_FORWARDER_IP"
const Tier1RouteAdvertisentTypesTIER1IPSECLOCALENDPOINT Tier1RouteAdvertisentTypes = "TIER1_IPSEC_LOCAL_ENDPOINT"
const Tier1RouteAdvertisentTypesTIER1LBSNAT Tier1RouteAdvertisentTypes = "TIER1_LB_SNAT"
const Tier1RouteAdvertisentTypesTIER1LBVIP Tier1RouteAdvertisentTypes = "TIER1_LB_VIP"
const Tier1RouteAdvertisentTypesTIER1NAT Tier1RouteAdvertisentTypes = "TIER1_NAT"
const Tier1RouteAdvertisentTypesTIER1STATICROUTES Tier1RouteAdvertisentTypes = "TIER1_STATIC_ROUTES"

var enumValues_Tier1RouteAdvertisentTypes = []interface{}{
	"TIER1_STATIC_ROUTES",
	"TIER1_CONNECTED",
	"TIER1_NAT",
	"TIER1_LB_VIP",
	"TIER1_LB_SNAT",
	"TIER1_DNS_FORWARDER_IP",
	"TIER1_IPSEC_LOCAL_ENDPOINT",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier1RouteAdvertisentTypes) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Tier1RouteAdvertisentTypes {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Tier1RouteAdvertisentTypes, v)
	}
	*j = Tier1RouteAdvertisentTypes(v)
	return nil
}

type Tier1Type string

const Tier1TypeISOLATED Tier1Type = "ISOLATED"
const Tier1TypeNATTED Tier1Type = "NATTED"
const Tier1TypeROUTED Tier1Type = "ROUTED"

var enumValues_Tier1Type = []interface{}{
	"ROUTED",
	"ISOLATED",
	"NATTED",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier1Type) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_Tier1Type {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_Tier1Type, v)
	}
	*j = Tier1Type(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Tier1) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain Tier1
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["default_rule_logging"]; !ok || v == nil {
		plain.DefaultRuleLogging = false
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if len(plain.DhcpConfigPaths) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "dhcp_config_paths", 1)
	}
	if v, ok := raw["disable_firewall"]; !ok || v == nil {
		plain.DisableFirewall = false
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["enable_standby_relocation"]; !ok || v == nil {
		plain.EnableStandbyRelocation = false
	}
	if v, ok := raw["failover_mode"]; !ok || v == nil {
		plain.FailoverMode = "NON_PREEMPTIVE"
	}
	if v, ok := raw["force_whitelisting"]; !ok || v == nil {
		plain.ForceWhitelisting = false
	}
	if len(plain.Ipv6ProfilePaths) > 2 {
		return fmt.Errorf("field %s length: must be <= %d", "ipv6_profile_paths", 2)
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if v, ok := raw["pool_allocation"]; !ok || v == nil {
		plain.PoolAllocation = "ROUTING"
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = Tier1(plain)
	return nil
}

type TraceflowComponentSubType string

const TraceflowComponentSubTypeAWSGATEWAY TraceflowComponentSubType = "AWS_GATEWAY"
const TraceflowComponentSubTypeDELLGATEWAY TraceflowComponentSubType = "DELL_GATEWAY"
const TraceflowComponentSubTypeEDGEUPLINK TraceflowComponentSubType = "EDGE_UPLINK"
const TraceflowComponentSubTypeENI TraceflowComponentSubType = "ENI"
const TraceflowComponentSubTypeLGWROUTE TraceflowComponentSubType = "LGW_ROUTE"
const TraceflowComponentSubTypeLRKNI TraceflowComponentSubType = "LR_KNI"
const TraceflowComponentSubTypeLRTIER0 TraceflowComponentSubType = "LR_TIER0"
const TraceflowComponentSubTypeLRTIER1 TraceflowComponentSubType = "LR_TIER1"
const TraceflowComponentSubTypeLRVRFTIER0 TraceflowComponentSubType = "LR_VRF_TIER0"
const TraceflowComponentSubTypeLSTRANSIT TraceflowComponentSubType = "LS_TRANSIT"
const TraceflowComponentSubTypeSICLASSIFIER TraceflowComponentSubType = "SI_CLASSIFIER"
const TraceflowComponentSubTypeSIPROXY TraceflowComponentSubType = "SI_PROXY"
const TraceflowComponentSubTypeTGWROUTE TraceflowComponentSubType = "TGW_ROUTE"
const TraceflowComponentSubTypeUNKNOWN TraceflowComponentSubType = "UNKNOWN"
const TraceflowComponentSubTypeVDR TraceflowComponentSubType = "VDR"

var enumValues_TraceflowComponentSubType = []interface{}{
	"LR_TIER0",
	"LR_TIER1",
	"LR_VRF_TIER0",
	"LS_TRANSIT",
	"SI_CLASSIFIER",
	"SI_PROXY",
	"VDR",
	"ENI",
	"AWS_GATEWAY",
	"TGW_ROUTE",
	"EDGE_UPLINK",
	"DELL_GATEWAY",
	"LGW_ROUTE",
	"LR_KNI",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowComponentSubType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowComponentSubType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowComponentSubType, v)
	}
	*j = TraceflowComponentSubType(v)
	return nil
}

type TraceflowComponentType string

const TraceflowComponentTypeANTREADFW TraceflowComponentType = "ANTREA_DFW"
const TraceflowComponentTypeANTREAFORWARDING TraceflowComponentType = "ANTREA_FORWARDING"
const TraceflowComponentTypeANTREALB TraceflowComponentType = "ANTREA_LB"
const TraceflowComponentTypeANTREAROUTING TraceflowComponentType = "ANTREA_ROUTING"
const TraceflowComponentTypeANTREASPOOFGUARD TraceflowComponentType = "ANTREA_SPOOFGUARD"
const TraceflowComponentTypeBRIDGE TraceflowComponentType = "BRIDGE"
const TraceflowComponentTypeDFW TraceflowComponentType = "DFW"
const TraceflowComponentTypeDLB TraceflowComponentType = "DLB"
const TraceflowComponentTypeEDGEFW TraceflowComponentType = "EDGE_FW"
const TraceflowComponentTypeEDGEHOSTSWITCH TraceflowComponentType = "EDGE_HOSTSWITCH"
const TraceflowComponentTypeEDGERTEPTUNNEL TraceflowComponentType = "EDGE_RTEP_TUNNEL"
const TraceflowComponentTypeEDGETUNNEL TraceflowComponentType = "EDGE_TUNNEL"
const TraceflowComponentTypeFWBRIDGE TraceflowComponentType = "FW_BRIDGE"
const TraceflowComponentTypeHOSTSWITCH TraceflowComponentType = "HOST_SWITCH"
const TraceflowComponentTypeIPSEC TraceflowComponentType = "IPSEC"
const TraceflowComponentTypeLOADBALANCER TraceflowComponentType = "LOAD_BALANCER"
const TraceflowComponentTypeLR TraceflowComponentType = "LR"
const TraceflowComponentTypeLS TraceflowComponentType = "LS"
const TraceflowComponentTypeNAT TraceflowComponentType = "NAT"
const TraceflowComponentTypePHYSICAL TraceflowComponentType = "PHYSICAL"
const TraceflowComponentTypeSERVICEINSERTION TraceflowComponentType = "SERVICE_INSERTION"
const TraceflowComponentTypeSPOOFGUARD TraceflowComponentType = "SPOOFGUARD"
const TraceflowComponentTypeUNKNOWN TraceflowComponentType = "UNKNOWN"
const TraceflowComponentTypeVMC TraceflowComponentType = "VMC"

var enumValues_TraceflowComponentType = []interface{}{
	"PHYSICAL",
	"LR",
	"LS",
	"DFW",
	"BRIDGE",
	"EDGE_TUNNEL",
	"EDGE_HOSTSWITCH",
	"FW_BRIDGE",
	"EDGE_RTEP_TUNNEL",
	"LOAD_BALANCER",
	"NAT",
	"IPSEC",
	"SERVICE_INSERTION",
	"VMC",
	"SPOOFGUARD",
	"EDGE_FW",
	"DLB",
	"ANTREA_SPOOFGUARD",
	"ANTREA_LB",
	"ANTREA_ROUTING",
	"ANTREA_DFW",
	"ANTREA_FORWARDING",
	"HOST_SWITCH",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowComponentType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowComponentType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowComponentType, v)
	}
	*j = TraceflowComponentType(v)
	return nil
}

// TraceflowConfig mainly records what type of packets the user wants to inject
// into which port. This configuration will be cleaned up by the system after two
// hours of inactivity if is_transient is true. Traceflow is not supported for VPC
// Admin role.
type TraceflowConfig struct {
	// Timestamp of resource creation
	CreateTime *EpochMsTimestamp `json:"_create_time,omitempty" yaml:"_create_time,omitempty" mapstructure:"_create_time,omitempty"`

	// Id of the user who created this resource
	CreateUser *string `json:"_create_user,omitempty" yaml:"_create_user,omitempty" mapstructure:"_create_user,omitempty"`

	// Timestamp of last modification
	LastModifiedTime *EpochMsTimestamp `json:"_last_modified_time,omitempty" yaml:"_last_modified_time,omitempty" mapstructure:"_last_modified_time,omitempty"`

	// Id of the user who last modified this resource
	LastModifiedUser *string `json:"_last_modified_user,omitempty" yaml:"_last_modified_user,omitempty" mapstructure:"_last_modified_user,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Protection status is one of the following: PROTECTED - the client who retrieved
	// the entity is not allowed             to modify it. NOT_PROTECTED - the client
	// who retrieved the entity is allowed                 to modify it
	// REQUIRE_OVERRIDE - the client who retrieved the entity is a super
	// user and can modify it, but only when providing                    the request
	// header X-Allow-Overwrite=true. UNKNOWN - the _protection field could not be
	// determined for this           entity.
	Protection *string `json:"_protection,omitempty" yaml:"_protection,omitempty" mapstructure:"_protection,omitempty"`

	// The _revision property describes the current revision of the resource. To
	// prevent clients from overwriting each other's changes, PUT operations must
	// include the current _revision of the resource, which clients should obtain by
	// issuing a GET operation. If the _revision provided in a PUT request is missing
	// or stale, the operation will be rejected.
	Revision *int `json:"_revision,omitempty" yaml:"_revision,omitempty" mapstructure:"_revision,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Indicates system owned resource
	SystemOwned *bool `json:"_system_owned,omitempty" yaml:"_system_owned,omitempty" mapstructure:"_system_owned,omitempty"`

	// Subtree for this type within policy tree containing nested elements. Note that
	// this type is applicable to be used in Hierarchical API only.
	Children []ChildPolicyConfigResource `json:"children,omitempty" yaml:"children,omitempty" mapstructure:"children,omitempty"`

	// Policy path of child segment connected to container port. Child segment
	// connection is configured through SegmentConnectionBindingMapDto. This field
	// should be provided only when source_id/segment_port_path is a VIF attached port
	// on the parent segment.
	ConnectedParentPathAsSource *string `json:"connected_parent_path_as_source,omitempty" yaml:"connected_parent_path_as_source,omitempty" mapstructure:"connected_parent_path_as_source,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// Id corresponds to the JSON schema field "id".
	Id *string `json:"id,omitempty" yaml:"id,omitempty" mapstructure:"id,omitempty"`

	// This field indicates if intent is transient and will be cleaned up by the
	// system if set to true
	IsTransient bool `json:"is_transient,omitempty" yaml:"is_transient,omitempty" mapstructure:"is_transient,omitempty"`

	// Intent objects are not directly deleted from the system when a delete is
	// invoked on them. They are marked for deletion and only when all the realized
	// entities for that intent object gets deleted, the intent object is deleted.
	// Objects that are marked for deletion are not returned in GET call. One can use
	// the search API to get these objects.
	MarkedForDelete bool `json:"marked_for_delete,omitempty" yaml:"marked_for_delete,omitempty" mapstructure:"marked_for_delete,omitempty"`

	// This is a UUID generated by the system for knowing which site owns an object.
	// This is used in NSX+.
	OriginSiteId *string `json:"origin_site_id,omitempty" yaml:"origin_site_id,omitempty" mapstructure:"origin_site_id,omitempty"`

	// Global intent objects cannot be modified by the user. However, certain global
	// intent objects can be overridden locally by use of this property. In such
	// cases, the overridden local values take precedence over the globally defined
	// values for the properties.
	Overridden bool `json:"overridden,omitempty" yaml:"overridden,omitempty" mapstructure:"overridden,omitempty"`

	// This is a UUID generated by the system for knowing who owns this object. This
	// is used in NSX+.
	OwnerId *string `json:"owner_id,omitempty" yaml:"owner_id,omitempty" mapstructure:"owner_id,omitempty"`

	// Configuration of packet data
	Packet *PacketData `json:"packet,omitempty" yaml:"packet,omitempty" mapstructure:"packet,omitempty"`

	// Path of its parent
	ParentPath *string `json:"parent_path,omitempty" yaml:"parent_path,omitempty" mapstructure:"parent_path,omitempty"`

	// Absolute path of this object
	Path *string `json:"path,omitempty" yaml:"path,omitempty" mapstructure:"path,omitempty"`

	// This is a UUID generated by the system for realizing the entity object. In most
	// cases this should be same as 'unique_id' of the entity. However, in some cases
	// this can be different because of entities have migrated their unique identifier
	// to NSX Policy intent objects later in the timeline and did not use unique_id
	// for realization. Realization id is helpful for users to debug data path to
	// correlate the configuration with corresponding intent.
	RealizationId *string `json:"realization_id,omitempty" yaml:"realization_id,omitempty" mapstructure:"realization_id,omitempty"`

	// Path relative from its parent
	RelativePath *string `json:"relative_path,omitempty" yaml:"relative_path,omitempty" mapstructure:"relative_path,omitempty"`

	// This is the path of the object on the local managers when queried on the NSX+
	// service, and path of the object on NSX+ service when queried from the local
	// managers.
	RemotePath *string `json:"remote_path,omitempty" yaml:"remote_path,omitempty" mapstructure:"remote_path,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Policy path or UUID of segment port to start traceflow from. Auto-plumbed ports
	// don't have corresponding policy path. Ports auto-created by policy as part of
	// connecting segment to Tier-0 or Tier-1 or DHCP server cannot be used. UUID is
	// validated for syntax only. This configuration will be cleaned up by the system
	// after two hours of inactivity.
	SegmentPortPath *string `json:"segment_port_path,omitempty" yaml:"segment_port_path,omitempty" mapstructure:"segment_port_path,omitempty"`

	// Policy path or UUID (validated for syntax only) of segment port to start
	// traceflow from. Auto-plumbed ports don't have corresponding policy path. Both
	// overlay backed port and VLAN backed port are supported.
	SourceId *string `json:"source_id,omitempty" yaml:"source_id,omitempty" mapstructure:"source_id,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Maximum time in seconds the management plane will wait for observation result
	// to be generated. The default, minimum and maximum timeout values, in seconds,
	// for: Single site environment - minimum 5, default 10, maximum 15. Federated
	// enviroment - minimum 15, default 30, maximum 60. These values are validated by
	// the system based on type of environment.
	Timeout int `json:"timeout,omitempty" yaml:"timeout,omitempty" mapstructure:"timeout,omitempty"`

	// This is a UUID generated by the GM/LM to uniquely identify entities in a
	// federated environment. For entities that are stretched across multiple sites,
	// the same Id will be used on all the stretched sites.
	UniqueId *string `json:"unique_id,omitempty" yaml:"unique_id,omitempty" mapstructure:"unique_id,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain TraceflowConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if v, ok := raw["is_transient"]; !ok || v == nil {
		plain.IsTransient = true
	}
	if v, ok := raw["marked_for_delete"]; !ok || v == nil {
		plain.MarkedForDelete = false
	}
	if v, ok := raw["overridden"]; !ok || v == nil {
		plain.Overridden = false
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	if v, ok := raw["timeout"]; !ok || v == nil {
		plain.Timeout = 10.0
	}
	*j = TraceflowConfig(plain)
	return nil
}

type TraceflowObservationDelivered struct {
	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// LportId corresponds to the JSON schema field "lport_id".
	LportId *string `json:"lport_id,omitempty" yaml:"lport_id,omitempty" mapstructure:"lport_id,omitempty"`

	// LportName corresponds to the JSON schema field "lport_name".
	LportName *string `json:"lport_name,omitempty" yaml:"lport_name,omitempty" mapstructure:"lport_name,omitempty"`

	// This field specifies the resolution type of ARP ARP_SUPPRESSION_PORT_CACHE -
	// ARP request is suppressed by IP table. ARP_SUPPRESSION_TABLE - ARP request is
	// suppressed by ARP table. ARP_SUPPRESSION_CP_QUERY - ARP request is suppressed
	// by info derived from CP. ARP_VM - No suppression and the ARP request is
	// resolved by VM. ARP_LRP - No suppression and the ARP request is resolved by
	// logical router.
	ResolutionType *TraceflowObservationDeliveredResolutionType `json:"resolution_type,omitempty" yaml:"resolution_type,omitempty" mapstructure:"resolution_type,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// The source MAC address of form: "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$".
	// For example: 00:00:00:00:00:00.
	TargetMac *string `json:"target_mac,omitempty" yaml:"target_mac,omitempty" mapstructure:"target_mac,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`

	// VlanId corresponds to the JSON schema field "vlan_id".
	VlanId *VlanID `json:"vlan_id,omitempty" yaml:"vlan_id,omitempty" mapstructure:"vlan_id,omitempty"`
}

type TraceflowObservationDeliveredResolutionType string

const TraceflowObservationDeliveredResolutionTypeARPLRP TraceflowObservationDeliveredResolutionType = "ARP_LRP"
const TraceflowObservationDeliveredResolutionTypeARPSUPPRESSIONCPQUERY TraceflowObservationDeliveredResolutionType = "ARP_SUPPRESSION_CP_QUERY"
const TraceflowObservationDeliveredResolutionTypeARPSUPPRESSIONPORTCACHE TraceflowObservationDeliveredResolutionType = "ARP_SUPPRESSION_PORT_CACHE"
const TraceflowObservationDeliveredResolutionTypeARPSUPPRESSIONTABLE TraceflowObservationDeliveredResolutionType = "ARP_SUPPRESSION_TABLE"
const TraceflowObservationDeliveredResolutionTypeARPVM TraceflowObservationDeliveredResolutionType = "ARP_VM"
const TraceflowObservationDeliveredResolutionTypeUNKNOWN TraceflowObservationDeliveredResolutionType = "UNKNOWN"

var enumValues_TraceflowObservationDeliveredResolutionType = []interface{}{
	"UNKNOWN",
	"ARP_SUPPRESSION_PORT_CACHE",
	"ARP_SUPPRESSION_TABLE",
	"ARP_SUPPRESSION_CP_QUERY",
	"ARP_VM",
	"ARP_LRP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationDeliveredResolutionType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowObservationDeliveredResolutionType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowObservationDeliveredResolutionType, v)
	}
	*j = TraceflowObservationDeliveredResolutionType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationDelivered) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain TraceflowObservationDelivered
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = TraceflowObservationDelivered(plain)
	return nil
}

type TraceflowObservationDropped struct {
	// This field is specified when the traceflow packet matched a L3 firewall rule.
	AclRuleId *int `json:"acl_rule_id,omitempty" yaml:"acl_rule_id,omitempty" mapstructure:"acl_rule_id,omitempty"`

	// This field specifies the ARP fails reason ARP_TIMEOUT - ARP failure due to
	// query control plane timeout ARP_CPFAIL - ARP failure due post ARP query message
	// to control plane failure ARP_FROMCP - ARP failure due to deleting ARP entry
	// from control plane ARP_PORTDESTROY - ARP failure due to port destruction
	// ARP_TABLEDESTROY - ARP failure due to ARP table destruction ARP_NETDESTROY -
	// ARP failure due to overlay network destruction
	ArpFailReason *TraceflowObservationDroppedArpFailReason `json:"arp_fail_reason,omitempty" yaml:"arp_fail_reason,omitempty" mapstructure:"arp_fail_reason,omitempty"`

	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// This field specifies the IPSec VPN fails reason IPSEC_SA_NOT_FOUND   - IPSec SA
	// required for processing the packet does not exist IPSEC_UDP_ENC_STATE_MISMATCH
	// - ESP packet is UDP encapsulated but IPsec SA does not expect UDP encapsulation
	// IPSEC_SEQ_ROLLOVER   - IPSec SA sequence number has exceeded the maximum value
	// IPSEC_FRAG_NEEDED   - Received packet has DF bit set in IP header but requires
	// fragmentation due to ESP encapsulation IPSEC_TUN_IFACE_DOWN   - IPSec tunnel
	// interface is down IPSEC_POLICY_NOMATCH   - Received packet does not match IPSec
	// policy IPSEC_POLICY_BLOCK   - IPSec packet processing failed IPSEC_POLICY_ERROR
	// - IPSec packet processing failed IPSEC_REPLAY_SEQ_NUM_REPEAT   - IPSec packet
	// is dropped due to replay IPSEC_REPLAY_RECV_DELAY   - IPSec packet is dropped
	// due to replay IPSEC_REPLAY_PROC_DELAY   - IPSec packet is dropped due to replay
	// IPSEC_ZERO_SEQ_NUM_RECVD   - ESP packet is received with sequence number as
	// zero IPSEC_ENQUEUE_FAIL   - Packet processing failed during crypto operation
	// IPSEC_AUTH_DGST_MISMATCH   - Packet integrity check failed due to digest
	// mismatch IPSEC_AUTH_DGST_SIZE_MISMATCH   - Packet integrity check failed due to
	// invalid digest length IPSEC_AUTH_UNSUPPORTED_ALGO   - Packet integrity check
	// failed due to unsupported hash algorithm IPSEC_CRYPTO_FAIL   - Packet
	// processing failed during crypto operation IPSEC_CRYPTO_PROC_INCOMPLETE   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_SESSION_INV   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_ARGS_INV   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_PROC_ERROR   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_NO_BUF_SPACE   -
	// Packet processing failed during crypto operation
	// IPSEC_CRYPTO_UNSUPPORTED_CIPHER   - Packet processing failed during crypto
	// operation IPSEC_MALFORMED   - Received ESP packet is malformed
	// IPSEC_MALFORMED_INV_PADDING   - Received ESP packet is malformed
	// IPSEC_PADDING_REMOVAL_FAILED   - Received ESP packet is malformed
	// IPSEC_INNER_MALFORMED   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_IP   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_UDP   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_TCP   - IP packet after ESP decryption is malformed
	// IPSEC_UNKNOWN   - IPSec VPN failure reason is unknown
	IpsecFailReason *TraceflowObservationDroppedIpsecFailReason `json:"ipsec_fail_reason,omitempty" yaml:"ipsec_fail_reason,omitempty" mapstructure:"ipsec_fail_reason,omitempty"`

	// This field is specified when the traceflow packet matched a jump-to rule.
	JumptoRuleId *int `json:"jumpto_rule_id,omitempty" yaml:"jumpto_rule_id,omitempty" mapstructure:"jumpto_rule_id,omitempty"`

	// This field is specified when the traceflow packet matched a l2 rule.
	L2RuleId *int `json:"l2_rule_id,omitempty" yaml:"l2_rule_id,omitempty" mapstructure:"l2_rule_id,omitempty"`

	// LportId corresponds to the JSON schema field "lport_id".
	LportId *string `json:"lport_id,omitempty" yaml:"lport_id,omitempty" mapstructure:"lport_id,omitempty"`

	// LportName corresponds to the JSON schema field "lport_name".
	LportName *string `json:"lport_name,omitempty" yaml:"lport_name,omitempty" mapstructure:"lport_name,omitempty"`

	// This field is specified when the traceflow packet matched a NAT rule.
	NatRuleId *int `json:"nat_rule_id,omitempty" yaml:"nat_rule_id,omitempty" mapstructure:"nat_rule_id,omitempty"`

	// This field specifies the drop reason of traceflow packet. ARP_FAIL - ARP
	// request fails for some reasons, please refer arp_fail_reason for detail BFD -
	// BFD packet is dropped because traversed by non-operative interface or
	// encountering internal error (e.g., memory insufficient) BROADCAST - Packet is
	// dropped during traversing the interface (e.g., Edge uplink, Edge centralized
	// service port) which disallow ethernet broadcast DHCP - DHCP packet is malformed
	// DLB - The packet is disallowed by distributed load balancing FW_RULE - The
	// packet matches a drop or reject rule of DFW or Edge firewall GENEVE - GENEVE
	// packet is malformed GRE - GRE packet is malformed or traverses a non-operative
	// interface IFACE - Packet traverses a non-operative interface IP - Packet is
	// dropped because of IP related causes (e.g., ICMPv4/ICMPv6 packet is malformed,
	// or DF flag is set but fragment must be performed for the packet) or
	// corresponding interface is not found or inoperative IP_REASS - Packet is
	// dropped during IP reassembly IPSEC - IPsec protocol related packet is dropped
	// IPSEC_VTI - IPsec required SA is not found or traversing inoperative interface
	// cause packet dropped L2VPN - VLAN id of GRE packet is invalid L4PORT - Layer 4
	// packet (e.g., BFD, DHCP) is dropped LB - Packet is dropped by load balancing
	// rule LROUTER - Packet is dropped by logical router LSERVICE - Packet is
	// malformed or traverses inoperative logical service interface LSWITCH - Packet
	// is dropped by logical switch MANAGEMENT - Packet is dropped by Edge datapath
	// MANAGEMENT service port MD_PROXY - Packet is dropped by metadata proxy NAT -
	// Packet is dropped by NAT rule RTEP_TUNNEL - Unused drop reason ND_NS_FAIL -
	// Neighbor Discovery packet fails NEIGH - ARP or Neighbor Discovery packet fails
	// NO_EIP_FOUND - Destination IP is not an elastic IP NO_EIP_ASSOCIATION - Elastic
	// IP is not associated with active edge VDR ENI NO_ENI_FOR_IP - There is no ENI
	// found for the destination IP NO_ENI_FOR_LIF - Cannot find an ENI associated
	// with uplink LIF NO_ROUTE - Cannot find route for destination IP
	// NO_ROUTE_TABLE_FOUND - Cannot find associated route table
	// NO_UNDERLAY_ROUTE_FOUND - Cannot find AWS route to destination NOT_VDR_DOWNLINK
	// - Packet is not forwarded to VMC unmanaged VDR downlink NO_VDR_FOUND - VMC
	// unmanaged VDR associated with Edge uplink is not found NO_VDR_ON_HOST - Cannot
	// find VMC unmanaged VDR list on this host NOT_VDR_UPLINK - Packet is not
	// forwarded to VDR uplink SERVICE_INSERT - Packet from guest VM to service VM or
	// from service VM to guest VM is dropped by firewall rule SPOOFGUARD - Packet is
	// blocked by SpoofGuard policy TTL_ZERO - The IPv4 time to live field or the IPv6
	// hop limit field of packet is zero TUNNEL - Overlay tunnel management packet
	// (VNI value of GENEVE header is 0, e.g., BFD) is dropped VLAN - VLAN id of
	// packet is disallowed by the given port VXLAN - VXLAN packet is malformed or
	// cannot find tunnel port for it VXSTT - Unused drop reason VMC_NO_RESPONSE -
	// Failed to query VMC observations as no response from VMC app WRONG_UPLINK -
	// Packet is not routed to the expected Edge uplink by VMC unmanaged VDR FW_STATE
	// - Packet is dropped by stateful firewall NO_MAC - Drop by vswitch as no
	// destination MAC hit MAC Table. FILTERED_UPLINK - Filtering applied at the
	// corresponding UPLINK having no aggregation.
	Reason *TraceflowObservationDroppedReason `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`
}

type TraceflowObservationDroppedArpFailReason string

const TraceflowObservationDroppedArpFailReasonARPCPFAIL TraceflowObservationDroppedArpFailReason = "ARP_CPFAIL"
const TraceflowObservationDroppedArpFailReasonARPFROMCP TraceflowObservationDroppedArpFailReason = "ARP_FROMCP"
const TraceflowObservationDroppedArpFailReasonARPNETDESTROY TraceflowObservationDroppedArpFailReason = "ARP_NETDESTROY"
const TraceflowObservationDroppedArpFailReasonARPPORTDESTROY TraceflowObservationDroppedArpFailReason = "ARP_PORTDESTROY"
const TraceflowObservationDroppedArpFailReasonARPTABLEDESTROY TraceflowObservationDroppedArpFailReason = "ARP_TABLEDESTROY"
const TraceflowObservationDroppedArpFailReasonARPTIMEOUT TraceflowObservationDroppedArpFailReason = "ARP_TIMEOUT"
const TraceflowObservationDroppedArpFailReasonARPUNKNOWN TraceflowObservationDroppedArpFailReason = "ARP_UNKNOWN"

var enumValues_TraceflowObservationDroppedArpFailReason = []interface{}{
	"ARP_UNKNOWN",
	"ARP_TIMEOUT",
	"ARP_CPFAIL",
	"ARP_FROMCP",
	"ARP_PORTDESTROY",
	"ARP_TABLEDESTROY",
	"ARP_NETDESTROY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationDroppedArpFailReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowObservationDroppedArpFailReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowObservationDroppedArpFailReason, v)
	}
	*j = TraceflowObservationDroppedArpFailReason(v)
	return nil
}

type TraceflowObservationDroppedIpsecFailReason string

const TraceflowObservationDroppedIpsecFailReasonIPSECAUTHDGSTMISMATCH TraceflowObservationDroppedIpsecFailReason = "IPSEC_AUTH_DGST_MISMATCH"
const TraceflowObservationDroppedIpsecFailReasonIPSECAUTHDGSTSIZEMISMATCH TraceflowObservationDroppedIpsecFailReason = "IPSEC_AUTH_DGST_SIZE_MISMATCH"
const TraceflowObservationDroppedIpsecFailReasonIPSECAUTHUNSUPPORTEDALGO TraceflowObservationDroppedIpsecFailReason = "IPSEC_AUTH_UNSUPPORTED_ALGO"
const TraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOARGSINV TraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_ARGS_INV"
const TraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOFAIL TraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_FAIL"
const TraceflowObservationDroppedIpsecFailReasonIPSECCRYPTONOBUFSPACE TraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_NO_BUF_SPACE"
const TraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOPROCERROR TraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_PROC_ERROR"
const TraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOPROCINCOMPLETE TraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_PROC_INCOMPLETE"
const TraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOSESSIONINV TraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_SESSION_INV"
const TraceflowObservationDroppedIpsecFailReasonIPSECCRYPTOUNSUPPORTEDCIPHER TraceflowObservationDroppedIpsecFailReason = "IPSEC_CRYPTO_UNSUPPORTED_CIPHER"
const TraceflowObservationDroppedIpsecFailReasonIPSECENQUEUEFAIL TraceflowObservationDroppedIpsecFailReason = "IPSEC_ENQUEUE_FAIL"
const TraceflowObservationDroppedIpsecFailReasonIPSECFRAGNEEDED TraceflowObservationDroppedIpsecFailReason = "IPSEC_FRAG_NEEDED"
const TraceflowObservationDroppedIpsecFailReasonIPSECINNERMALFORMED TraceflowObservationDroppedIpsecFailReason = "IPSEC_INNER_MALFORMED"
const TraceflowObservationDroppedIpsecFailReasonIPSECINNERMALFORMEDIP TraceflowObservationDroppedIpsecFailReason = "IPSEC_INNER_MALFORMED_IP"
const TraceflowObservationDroppedIpsecFailReasonIPSECINNERMALFORMEDTCP TraceflowObservationDroppedIpsecFailReason = "IPSEC_INNER_MALFORMED_TCP"
const TraceflowObservationDroppedIpsecFailReasonIPSECINNERMALFORMEDUDP TraceflowObservationDroppedIpsecFailReason = "IPSEC_INNER_MALFORMED_UDP"
const TraceflowObservationDroppedIpsecFailReasonIPSECMALFORMED TraceflowObservationDroppedIpsecFailReason = "IPSEC_MALFORMED"
const TraceflowObservationDroppedIpsecFailReasonIPSECMALFORMEDINVPADDING TraceflowObservationDroppedIpsecFailReason = "IPSEC_MALFORMED_INV_PADDING"
const TraceflowObservationDroppedIpsecFailReasonIPSECPADDINGREMOVALFAILED TraceflowObservationDroppedIpsecFailReason = "IPSEC_PADDING_REMOVAL_FAILED"
const TraceflowObservationDroppedIpsecFailReasonIPSECPOLICYBLOCK TraceflowObservationDroppedIpsecFailReason = "IPSEC_POLICY_BLOCK"
const TraceflowObservationDroppedIpsecFailReasonIPSECPOLICYERROR TraceflowObservationDroppedIpsecFailReason = "IPSEC_POLICY_ERROR"
const TraceflowObservationDroppedIpsecFailReasonIPSECPOLICYNOMATCH TraceflowObservationDroppedIpsecFailReason = "IPSEC_POLICY_NOMATCH"
const TraceflowObservationDroppedIpsecFailReasonIPSECREPLAYPROCDELAY TraceflowObservationDroppedIpsecFailReason = "IPSEC_REPLAY_PROC_DELAY"
const TraceflowObservationDroppedIpsecFailReasonIPSECREPLAYRECVDELAY TraceflowObservationDroppedIpsecFailReason = "IPSEC_REPLAY_RECV_DELAY"
const TraceflowObservationDroppedIpsecFailReasonIPSECREPLAYSEQNUMREPEAT TraceflowObservationDroppedIpsecFailReason = "IPSEC_REPLAY_SEQ_NUM_REPEAT"
const TraceflowObservationDroppedIpsecFailReasonIPSECSANOTFOUND TraceflowObservationDroppedIpsecFailReason = "IPSEC_SA_NOT_FOUND"
const TraceflowObservationDroppedIpsecFailReasonIPSECSEQROLLOVER TraceflowObservationDroppedIpsecFailReason = "IPSEC_SEQ_ROLLOVER"
const TraceflowObservationDroppedIpsecFailReasonIPSECTUNIFACEDOWN TraceflowObservationDroppedIpsecFailReason = "IPSEC_TUN_IFACE_DOWN"
const TraceflowObservationDroppedIpsecFailReasonIPSECUDPENCSTATEMISMATCH TraceflowObservationDroppedIpsecFailReason = "IPSEC_UDP_ENC_STATE_MISMATCH"
const TraceflowObservationDroppedIpsecFailReasonIPSECUNKNOWN TraceflowObservationDroppedIpsecFailReason = "IPSEC_UNKNOWN"
const TraceflowObservationDroppedIpsecFailReasonIPSECZEROSEQNUMRECVD TraceflowObservationDroppedIpsecFailReason = "IPSEC_ZERO_SEQ_NUM_RECVD"

var enumValues_TraceflowObservationDroppedIpsecFailReason = []interface{}{
	"IPSEC_SA_NOT_FOUND",
	"IPSEC_UDP_ENC_STATE_MISMATCH",
	"IPSEC_SEQ_ROLLOVER",
	"IPSEC_FRAG_NEEDED",
	"IPSEC_TUN_IFACE_DOWN",
	"IPSEC_POLICY_NOMATCH",
	"IPSEC_POLICY_BLOCK",
	"IPSEC_POLICY_ERROR",
	"IPSEC_REPLAY_SEQ_NUM_REPEAT",
	"IPSEC_REPLAY_RECV_DELAY",
	"IPSEC_REPLAY_PROC_DELAY",
	"IPSEC_ZERO_SEQ_NUM_RECVD",
	"IPSEC_ENQUEUE_FAIL",
	"IPSEC_AUTH_DGST_MISMATCH",
	"IPSEC_AUTH_DGST_SIZE_MISMATCH",
	"IPSEC_AUTH_UNSUPPORTED_ALGO",
	"IPSEC_CRYPTO_FAIL",
	"IPSEC_CRYPTO_PROC_INCOMPLETE",
	"IPSEC_CRYPTO_SESSION_INV",
	"IPSEC_CRYPTO_ARGS_INV",
	"IPSEC_CRYPTO_PROC_ERROR",
	"IPSEC_CRYPTO_NO_BUF_SPACE",
	"IPSEC_CRYPTO_UNSUPPORTED_CIPHER",
	"IPSEC_MALFORMED",
	"IPSEC_MALFORMED_INV_PADDING",
	"IPSEC_PADDING_REMOVAL_FAILED",
	"IPSEC_INNER_MALFORMED",
	"IPSEC_INNER_MALFORMED_IP",
	"IPSEC_INNER_MALFORMED_UDP",
	"IPSEC_INNER_MALFORMED_TCP",
	"IPSEC_UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationDroppedIpsecFailReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowObservationDroppedIpsecFailReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowObservationDroppedIpsecFailReason, v)
	}
	*j = TraceflowObservationDroppedIpsecFailReason(v)
	return nil
}

type TraceflowObservationDroppedLogical struct {
	// This field is specified when the traceflow packet matched a L3 firewall rule.
	AclRuleId *int `json:"acl_rule_id,omitempty" yaml:"acl_rule_id,omitempty" mapstructure:"acl_rule_id,omitempty"`

	// This field specifies the ARP fails reason ARP_TIMEOUT - ARP failure due to
	// query control plane timeout ARP_CPFAIL - ARP failure due post ARP query message
	// to control plane failure ARP_FROMCP - ARP failure due to deleting ARP entry
	// from control plane ARP_PORTDESTROY - ARP failure due to port destruction
	// ARP_TABLEDESTROY - ARP failure due to ARP table destruction ARP_NETDESTROY -
	// ARP failure due to overlay network destruction
	ArpFailReason *TraceflowObservationDroppedLogicalArpFailReason `json:"arp_fail_reason,omitempty" yaml:"arp_fail_reason,omitempty" mapstructure:"arp_fail_reason,omitempty"`

	// ComponentId corresponds to the JSON schema field "component_id".
	ComponentId *string `json:"component_id,omitempty" yaml:"component_id,omitempty" mapstructure:"component_id,omitempty"`

	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// This field specifies the IPSec VPN fails reason IPSEC_SA_NOT_FOUND   - IPSec SA
	// required for processing the packet does not exist IPSEC_UDP_ENC_STATE_MISMATCH
	// - ESP packet is UDP encapsulated but IPsec SA does not expect UDP encapsulation
	// IPSEC_SEQ_ROLLOVER   - IPSec SA sequence number has exceeded the maximum value
	// IPSEC_FRAG_NEEDED   - Received packet has DF bit set in IP header but requires
	// fragmentation due to ESP encapsulation IPSEC_TUN_IFACE_DOWN   - IPSec tunnel
	// interface is down IPSEC_POLICY_NOMATCH   - Received packet does not match IPSec
	// policy IPSEC_POLICY_BLOCK   - IPSec packet processing failed IPSEC_POLICY_ERROR
	// - IPSec packet processing failed IPSEC_REPLAY_SEQ_NUM_REPEAT   - IPSec packet
	// is dropped due to replay IPSEC_REPLAY_RECV_DELAY   - IPSec packet is dropped
	// due to replay IPSEC_REPLAY_PROC_DELAY   - IPSec packet is dropped due to replay
	// IPSEC_ZERO_SEQ_NUM_RECVD   - ESP packet is received with sequence number as
	// zero IPSEC_ENQUEUE_FAIL   - Packet processing failed during crypto operation
	// IPSEC_AUTH_DGST_MISMATCH   - Packet integrity check failed due to digest
	// mismatch IPSEC_AUTH_DGST_SIZE_MISMATCH   - Packet integrity check failed due to
	// invalid digest length IPSEC_AUTH_UNSUPPORTED_ALGO   - Packet integrity check
	// failed due to unsupported hash algorithm IPSEC_CRYPTO_FAIL   - Packet
	// processing failed during crypto operation IPSEC_CRYPTO_PROC_INCOMPLETE   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_SESSION_INV   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_ARGS_INV   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_PROC_ERROR   -
	// Packet processing failed during crypto operation IPSEC_CRYPTO_NO_BUF_SPACE   -
	// Packet processing failed during crypto operation
	// IPSEC_CRYPTO_UNSUPPORTED_CIPHER   - Packet processing failed during crypto
	// operation IPSEC_MALFORMED   - Received ESP packet is malformed
	// IPSEC_MALFORMED_INV_PADDING   - Received ESP packet is malformed
	// IPSEC_PADDING_REMOVAL_FAILED   - Received ESP packet is malformed
	// IPSEC_INNER_MALFORMED   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_IP   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_UDP   - IP packet after ESP decryption is malformed
	// IPSEC_INNER_MALFORMED_TCP   - IP packet after ESP decryption is malformed
	// IPSEC_UNKNOWN   - IPSec VPN failure reason is unknown
	IpsecFailReason *TraceflowObservationDroppedLogicalIpsecFailReason `json:"ipsec_fail_reason,omitempty" yaml:"ipsec_fail_reason,omitempty" mapstructure:"ipsec_fail_reason,omitempty"`

	// This field is specified when the traceflow packet matched a jump-to rule.
	JumptoRuleId *int `json:"jumpto_rule_id,omitempty" yaml:"jumpto_rule_id,omitempty" mapstructure:"jumpto_rule_id,omitempty"`

	// This field is specified when the traceflow packet matched a l2 rule.
	L2RuleId *int `json:"l2_rule_id,omitempty" yaml:"l2_rule_id,omitempty" mapstructure:"l2_rule_id,omitempty"`

	// LportId corresponds to the JSON schema field "lport_id".
	LportId *string `json:"lport_id,omitempty" yaml:"lport_id,omitempty" mapstructure:"lport_id,omitempty"`

	// LportName corresponds to the JSON schema field "lport_name".
	LportName *string `json:"lport_name,omitempty" yaml:"lport_name,omitempty" mapstructure:"lport_name,omitempty"`

	// This field is specified when the traceflow packet matched a NAT rule.
	NatRuleId *int `json:"nat_rule_id,omitempty" yaml:"nat_rule_id,omitempty" mapstructure:"nat_rule_id,omitempty"`

	// This field specifies the drop reason of traceflow packet. ARP_FAIL - ARP
	// request fails for some reasons, please refer arp_fail_reason for detail BFD -
	// BFD packet is dropped because traversed by non-operative interface or
	// encountering internal error (e.g., memory insufficient) BROADCAST - Packet is
	// dropped during traversing the interface (e.g., Edge uplink, Edge centralized
	// service port) which disallow ethernet broadcast DHCP - DHCP packet is malformed
	// DLB - The packet is disallowed by distributed load balancing FW_RULE - The
	// packet matches a drop or reject rule of DFW or Edge firewall GENEVE - GENEVE
	// packet is malformed GRE - GRE packet is malformed or traverses a non-operative
	// interface IFACE - Packet traverses a non-operative interface IP - Packet is
	// dropped because of IP related causes (e.g., ICMPv4/ICMPv6 packet is malformed,
	// or DF flag is set but fragment must be performed for the packet) or
	// corresponding interface is not found or inoperative IP_REASS - Packet is
	// dropped during IP reassembly IPSEC - IPsec protocol related packet is dropped
	// IPSEC_VTI - IPsec required SA is not found or traversing inoperative interface
	// cause packet dropped L2VPN - VLAN id of GRE packet is invalid L4PORT - Layer 4
	// packet (e.g., BFD, DHCP) is dropped LB - Packet is dropped by load balancing
	// rule LROUTER - Packet is dropped by logical router LSERVICE - Packet is
	// malformed or traverses inoperative logical service interface LSWITCH - Packet
	// is dropped by logical switch MANAGEMENT - Packet is dropped by Edge datapath
	// MANAGEMENT service port MD_PROXY - Packet is dropped by metadata proxy NAT -
	// Packet is dropped by NAT rule RTEP_TUNNEL - Unused drop reason ND_NS_FAIL -
	// Neighbor Discovery packet fails NEIGH - ARP or Neighbor Discovery packet fails
	// NO_EIP_FOUND - Destination IP is not an elastic IP NO_EIP_ASSOCIATION - Elastic
	// IP is not associated with active edge VDR ENI NO_ENI_FOR_IP - There is no ENI
	// found for the destination IP NO_ENI_FOR_LIF - Cannot find an ENI associated
	// with uplink LIF NO_ROUTE - Cannot find route for destination IP
	// NO_ROUTE_TABLE_FOUND - Cannot find associated route table
	// NO_UNDERLAY_ROUTE_FOUND - Cannot find AWS route to destination NOT_VDR_DOWNLINK
	// - Packet is not forwarded to VMC unmanaged VDR downlink NO_VDR_FOUND - VMC
	// unmanaged VDR associated with Edge uplink is not found NO_VDR_ON_HOST - Cannot
	// find VMC unmanaged VDR list on this host NOT_VDR_UPLINK - Packet is not
	// forwarded to VDR uplink SERVICE_INSERT - Packet from guest VM to service VM or
	// from service VM to guest VM is dropped by firewall rule SPOOFGUARD - Packet is
	// blocked by SpoofGuard policy TTL_ZERO - The IPv4 time to live field or the IPv6
	// hop limit field of packet is zero TUNNEL - Overlay tunnel management packet
	// (VNI value of GENEVE header is 0, e.g., BFD) is dropped VLAN - VLAN id of
	// packet is disallowed by the given port VXLAN - VXLAN packet is malformed or
	// cannot find tunnel port for it VXSTT - Unused drop reason VMC_NO_RESPONSE -
	// Failed to query VMC observations as no response from VMC app WRONG_UPLINK -
	// Packet is not routed to the expected Edge uplink by VMC unmanaged VDR FW_STATE
	// - Packet is dropped by stateful firewall NO_MAC - Drop by vswitch as no
	// destination MAC hit MAC Table. FILTERED_UPLINK - Filtering applied at the
	// corresponding UPLINK having no aggregation.
	Reason *TraceflowObservationDroppedLogicalReason `json:"reason,omitempty" yaml:"reason,omitempty" mapstructure:"reason,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// The index of service path that is a chain of services represents the point
	// where the traceflow packet was dropped.
	ServicePathIndex *int `json:"service_path_index,omitempty" yaml:"service_path_index,omitempty" mapstructure:"service_path_index,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`
}

type TraceflowObservationDroppedLogicalArpFailReason string

const TraceflowObservationDroppedLogicalArpFailReasonARPCPFAIL TraceflowObservationDroppedLogicalArpFailReason = "ARP_CPFAIL"
const TraceflowObservationDroppedLogicalArpFailReasonARPFROMCP TraceflowObservationDroppedLogicalArpFailReason = "ARP_FROMCP"
const TraceflowObservationDroppedLogicalArpFailReasonARPNETDESTROY TraceflowObservationDroppedLogicalArpFailReason = "ARP_NETDESTROY"
const TraceflowObservationDroppedLogicalArpFailReasonARPPORTDESTROY TraceflowObservationDroppedLogicalArpFailReason = "ARP_PORTDESTROY"
const TraceflowObservationDroppedLogicalArpFailReasonARPTABLEDESTROY TraceflowObservationDroppedLogicalArpFailReason = "ARP_TABLEDESTROY"
const TraceflowObservationDroppedLogicalArpFailReasonARPTIMEOUT TraceflowObservationDroppedLogicalArpFailReason = "ARP_TIMEOUT"
const TraceflowObservationDroppedLogicalArpFailReasonARPUNKNOWN TraceflowObservationDroppedLogicalArpFailReason = "ARP_UNKNOWN"

var enumValues_TraceflowObservationDroppedLogicalArpFailReason = []interface{}{
	"ARP_UNKNOWN",
	"ARP_TIMEOUT",
	"ARP_CPFAIL",
	"ARP_FROMCP",
	"ARP_PORTDESTROY",
	"ARP_TABLEDESTROY",
	"ARP_NETDESTROY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationDroppedLogicalArpFailReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowObservationDroppedLogicalArpFailReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowObservationDroppedLogicalArpFailReason, v)
	}
	*j = TraceflowObservationDroppedLogicalArpFailReason(v)
	return nil
}

type TraceflowObservationDroppedLogicalIpsecFailReason string

const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECAUTHDGSTMISMATCH TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_AUTH_DGST_MISMATCH"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECAUTHDGSTSIZEMISMATCH TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_AUTH_DGST_SIZE_MISMATCH"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECAUTHUNSUPPORTEDALGO TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_AUTH_UNSUPPORTED_ALGO"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOARGSINV TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_ARGS_INV"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOFAIL TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_FAIL"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTONOBUFSPACE TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_NO_BUF_SPACE"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOPROCERROR TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_PROC_ERROR"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOPROCINCOMPLETE TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_PROC_INCOMPLETE"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOSESSIONINV TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_SESSION_INV"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECCRYPTOUNSUPPORTEDCIPHER TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_CRYPTO_UNSUPPORTED_CIPHER"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECENQUEUEFAIL TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_ENQUEUE_FAIL"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECFRAGNEEDED TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_FRAG_NEEDED"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECINNERMALFORMED TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_INNER_MALFORMED"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECINNERMALFORMEDIP TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_INNER_MALFORMED_IP"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECINNERMALFORMEDTCP TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_INNER_MALFORMED_TCP"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECINNERMALFORMEDUDP TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_INNER_MALFORMED_UDP"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECMALFORMED TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_MALFORMED"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECMALFORMEDINVPADDING TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_MALFORMED_INV_PADDING"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECPADDINGREMOVALFAILED TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_PADDING_REMOVAL_FAILED"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECPOLICYBLOCK TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_POLICY_BLOCK"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECPOLICYERROR TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_POLICY_ERROR"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECPOLICYNOMATCH TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_POLICY_NOMATCH"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECREPLAYPROCDELAY TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_REPLAY_PROC_DELAY"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECREPLAYRECVDELAY TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_REPLAY_RECV_DELAY"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECREPLAYSEQNUMREPEAT TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_REPLAY_SEQ_NUM_REPEAT"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECSANOTFOUND TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_SA_NOT_FOUND"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECSEQROLLOVER TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_SEQ_ROLLOVER"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECTUNIFACEDOWN TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_TUN_IFACE_DOWN"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECUDPENCSTATEMISMATCH TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_UDP_ENC_STATE_MISMATCH"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECUNKNOWN TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_UNKNOWN"
const TraceflowObservationDroppedLogicalIpsecFailReasonIPSECZEROSEQNUMRECVD TraceflowObservationDroppedLogicalIpsecFailReason = "IPSEC_ZERO_SEQ_NUM_RECVD"

var enumValues_TraceflowObservationDroppedLogicalIpsecFailReason = []interface{}{
	"IPSEC_SA_NOT_FOUND",
	"IPSEC_UDP_ENC_STATE_MISMATCH",
	"IPSEC_SEQ_ROLLOVER",
	"IPSEC_FRAG_NEEDED",
	"IPSEC_TUN_IFACE_DOWN",
	"IPSEC_POLICY_NOMATCH",
	"IPSEC_POLICY_BLOCK",
	"IPSEC_POLICY_ERROR",
	"IPSEC_REPLAY_SEQ_NUM_REPEAT",
	"IPSEC_REPLAY_RECV_DELAY",
	"IPSEC_REPLAY_PROC_DELAY",
	"IPSEC_ZERO_SEQ_NUM_RECVD",
	"IPSEC_ENQUEUE_FAIL",
	"IPSEC_AUTH_DGST_MISMATCH",
	"IPSEC_AUTH_DGST_SIZE_MISMATCH",
	"IPSEC_AUTH_UNSUPPORTED_ALGO",
	"IPSEC_CRYPTO_FAIL",
	"IPSEC_CRYPTO_PROC_INCOMPLETE",
	"IPSEC_CRYPTO_SESSION_INV",
	"IPSEC_CRYPTO_ARGS_INV",
	"IPSEC_CRYPTO_PROC_ERROR",
	"IPSEC_CRYPTO_NO_BUF_SPACE",
	"IPSEC_CRYPTO_UNSUPPORTED_CIPHER",
	"IPSEC_MALFORMED",
	"IPSEC_MALFORMED_INV_PADDING",
	"IPSEC_PADDING_REMOVAL_FAILED",
	"IPSEC_INNER_MALFORMED",
	"IPSEC_INNER_MALFORMED_IP",
	"IPSEC_INNER_MALFORMED_UDP",
	"IPSEC_INNER_MALFORMED_TCP",
	"IPSEC_UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationDroppedLogicalIpsecFailReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowObservationDroppedLogicalIpsecFailReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowObservationDroppedLogicalIpsecFailReason, v)
	}
	*j = TraceflowObservationDroppedLogicalIpsecFailReason(v)
	return nil
}

type TraceflowObservationDroppedLogicalReason string

const TraceflowObservationDroppedLogicalReasonARPFAIL TraceflowObservationDroppedLogicalReason = "ARP_FAIL"
const TraceflowObservationDroppedLogicalReasonBFD TraceflowObservationDroppedLogicalReason = "BFD"
const TraceflowObservationDroppedLogicalReasonBROADCAST TraceflowObservationDroppedLogicalReason = "BROADCAST"
const TraceflowObservationDroppedLogicalReasonDHCP TraceflowObservationDroppedLogicalReason = "DHCP"
const TraceflowObservationDroppedLogicalReasonDLB TraceflowObservationDroppedLogicalReason = "DLB"
const TraceflowObservationDroppedLogicalReasonFILTEREDUPLINK TraceflowObservationDroppedLogicalReason = "FILTERED_UPLINK"
const TraceflowObservationDroppedLogicalReasonFWRULE TraceflowObservationDroppedLogicalReason = "FW_RULE"
const TraceflowObservationDroppedLogicalReasonFWSTATE TraceflowObservationDroppedLogicalReason = "FW_STATE"
const TraceflowObservationDroppedLogicalReasonGENEVE TraceflowObservationDroppedLogicalReason = "GENEVE"
const TraceflowObservationDroppedLogicalReasonGRE TraceflowObservationDroppedLogicalReason = "GRE"
const TraceflowObservationDroppedLogicalReasonIFACE TraceflowObservationDroppedLogicalReason = "IFACE"
const TraceflowObservationDroppedLogicalReasonIP TraceflowObservationDroppedLogicalReason = "IP"
const TraceflowObservationDroppedLogicalReasonIPREASS TraceflowObservationDroppedLogicalReason = "IP_REASS"
const TraceflowObservationDroppedLogicalReasonIPSEC TraceflowObservationDroppedLogicalReason = "IPSEC"
const TraceflowObservationDroppedLogicalReasonIPSECVTI TraceflowObservationDroppedLogicalReason = "IPSEC_VTI"
const TraceflowObservationDroppedLogicalReasonL2VPN TraceflowObservationDroppedLogicalReason = "L2VPN"
const TraceflowObservationDroppedLogicalReasonL4PORT TraceflowObservationDroppedLogicalReason = "L4PORT"
const TraceflowObservationDroppedLogicalReasonLB TraceflowObservationDroppedLogicalReason = "LB"
const TraceflowObservationDroppedLogicalReasonLROUTER TraceflowObservationDroppedLogicalReason = "LROUTER"
const TraceflowObservationDroppedLogicalReasonLSERVICE TraceflowObservationDroppedLogicalReason = "LSERVICE"
const TraceflowObservationDroppedLogicalReasonLSWITCH TraceflowObservationDroppedLogicalReason = "LSWITCH"
const TraceflowObservationDroppedLogicalReasonMANAGEMENT TraceflowObservationDroppedLogicalReason = "MANAGEMENT"
const TraceflowObservationDroppedLogicalReasonMDPROXY TraceflowObservationDroppedLogicalReason = "MD_PROXY"
const TraceflowObservationDroppedLogicalReasonNAT TraceflowObservationDroppedLogicalReason = "NAT"
const TraceflowObservationDroppedLogicalReasonNDNSFAIL TraceflowObservationDroppedLogicalReason = "ND_NS_FAIL"
const TraceflowObservationDroppedLogicalReasonNEIGH TraceflowObservationDroppedLogicalReason = "NEIGH"
const TraceflowObservationDroppedLogicalReasonNOEIPASSOCIATION TraceflowObservationDroppedLogicalReason = "NO_EIP_ASSOCIATION"
const TraceflowObservationDroppedLogicalReasonNOEIPFOUND TraceflowObservationDroppedLogicalReason = "NO_EIP_FOUND"
const TraceflowObservationDroppedLogicalReasonNOENIFORIP TraceflowObservationDroppedLogicalReason = "NO_ENI_FOR_IP"
const TraceflowObservationDroppedLogicalReasonNOENIFORLIF TraceflowObservationDroppedLogicalReason = "NO_ENI_FOR_LIF"
const TraceflowObservationDroppedLogicalReasonNOMAC TraceflowObservationDroppedLogicalReason = "NO_MAC"
const TraceflowObservationDroppedLogicalReasonNOROUTE TraceflowObservationDroppedLogicalReason = "NO_ROUTE"
const TraceflowObservationDroppedLogicalReasonNOROUTETABLEFOUND TraceflowObservationDroppedLogicalReason = "NO_ROUTE_TABLE_FOUND"
const TraceflowObservationDroppedLogicalReasonNOTVDRDOWNLINK TraceflowObservationDroppedLogicalReason = "NOT_VDR_DOWNLINK"
const TraceflowObservationDroppedLogicalReasonNOTVDRUPLINK TraceflowObservationDroppedLogicalReason = "NOT_VDR_UPLINK"
const TraceflowObservationDroppedLogicalReasonNOUNDERLAYROUTEFOUND TraceflowObservationDroppedLogicalReason = "NO_UNDERLAY_ROUTE_FOUND"
const TraceflowObservationDroppedLogicalReasonNOVDRFOUND TraceflowObservationDroppedLogicalReason = "NO_VDR_FOUND"
const TraceflowObservationDroppedLogicalReasonNOVDRONHOST TraceflowObservationDroppedLogicalReason = "NO_VDR_ON_HOST"
const TraceflowObservationDroppedLogicalReasonRTEPTUNNEL TraceflowObservationDroppedLogicalReason = "RTEP_TUNNEL"
const TraceflowObservationDroppedLogicalReasonSERVICEINSERT TraceflowObservationDroppedLogicalReason = "SERVICE_INSERT"
const TraceflowObservationDroppedLogicalReasonSPOOFGUARD TraceflowObservationDroppedLogicalReason = "SPOOFGUARD"
const TraceflowObservationDroppedLogicalReasonTTLZERO TraceflowObservationDroppedLogicalReason = "TTL_ZERO"
const TraceflowObservationDroppedLogicalReasonTUNNEL TraceflowObservationDroppedLogicalReason = "TUNNEL"
const TraceflowObservationDroppedLogicalReasonUNKNOWN TraceflowObservationDroppedLogicalReason = "UNKNOWN"
const TraceflowObservationDroppedLogicalReasonVLAN TraceflowObservationDroppedLogicalReason = "VLAN"
const TraceflowObservationDroppedLogicalReasonVMCNORESPONSE TraceflowObservationDroppedLogicalReason = "VMC_NO_RESPONSE"
const TraceflowObservationDroppedLogicalReasonVXLAN TraceflowObservationDroppedLogicalReason = "VXLAN"
const TraceflowObservationDroppedLogicalReasonVXSTT TraceflowObservationDroppedLogicalReason = "VXSTT"
const TraceflowObservationDroppedLogicalReasonWRONGUPLINK TraceflowObservationDroppedLogicalReason = "WRONG_UPLINK"

var enumValues_TraceflowObservationDroppedLogicalReason = []interface{}{
	"ARP_FAIL",
	"BFD",
	"BROADCAST",
	"DHCP",
	"DLB",
	"FW_RULE",
	"GENEVE",
	"GRE",
	"IFACE",
	"IP",
	"IP_REASS",
	"IPSEC",
	"IPSEC_VTI",
	"L2VPN",
	"L4PORT",
	"LB",
	"LROUTER",
	"LSERVICE",
	"LSWITCH",
	"MANAGEMENT",
	"MD_PROXY",
	"NAT",
	"RTEP_TUNNEL",
	"ND_NS_FAIL",
	"NEIGH",
	"NO_EIP_FOUND",
	"NO_EIP_ASSOCIATION",
	"NO_ENI_FOR_IP",
	"NO_ENI_FOR_LIF",
	"NO_ROUTE",
	"NO_ROUTE_TABLE_FOUND",
	"NO_UNDERLAY_ROUTE_FOUND",
	"NOT_VDR_DOWNLINK",
	"NO_VDR_FOUND",
	"NO_VDR_ON_HOST",
	"NOT_VDR_UPLINK",
	"SERVICE_INSERT",
	"SPOOFGUARD",
	"TTL_ZERO",
	"TUNNEL",
	"VLAN",
	"VXLAN",
	"VXSTT",
	"VMC_NO_RESPONSE",
	"WRONG_UPLINK",
	"FW_STATE",
	"NO_MAC",
	"UNKNOWN",
	"FILTERED_UPLINK",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationDroppedLogicalReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowObservationDroppedLogicalReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowObservationDroppedLogicalReason, v)
	}
	*j = TraceflowObservationDroppedLogicalReason(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationDroppedLogical) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain TraceflowObservationDroppedLogical
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = TraceflowObservationDroppedLogical(plain)
	return nil
}

type TraceflowObservationDroppedReason string

const TraceflowObservationDroppedReasonARPFAIL TraceflowObservationDroppedReason = "ARP_FAIL"
const TraceflowObservationDroppedReasonBFD TraceflowObservationDroppedReason = "BFD"
const TraceflowObservationDroppedReasonBROADCAST TraceflowObservationDroppedReason = "BROADCAST"
const TraceflowObservationDroppedReasonDHCP TraceflowObservationDroppedReason = "DHCP"
const TraceflowObservationDroppedReasonDLB TraceflowObservationDroppedReason = "DLB"
const TraceflowObservationDroppedReasonFILTEREDUPLINK TraceflowObservationDroppedReason = "FILTERED_UPLINK"
const TraceflowObservationDroppedReasonFWRULE TraceflowObservationDroppedReason = "FW_RULE"
const TraceflowObservationDroppedReasonFWSTATE TraceflowObservationDroppedReason = "FW_STATE"
const TraceflowObservationDroppedReasonGENEVE TraceflowObservationDroppedReason = "GENEVE"
const TraceflowObservationDroppedReasonGRE TraceflowObservationDroppedReason = "GRE"
const TraceflowObservationDroppedReasonIFACE TraceflowObservationDroppedReason = "IFACE"
const TraceflowObservationDroppedReasonIP TraceflowObservationDroppedReason = "IP"
const TraceflowObservationDroppedReasonIPREASS TraceflowObservationDroppedReason = "IP_REASS"
const TraceflowObservationDroppedReasonIPSEC TraceflowObservationDroppedReason = "IPSEC"
const TraceflowObservationDroppedReasonIPSECVTI TraceflowObservationDroppedReason = "IPSEC_VTI"
const TraceflowObservationDroppedReasonL2VPN TraceflowObservationDroppedReason = "L2VPN"
const TraceflowObservationDroppedReasonL4PORT TraceflowObservationDroppedReason = "L4PORT"
const TraceflowObservationDroppedReasonLB TraceflowObservationDroppedReason = "LB"
const TraceflowObservationDroppedReasonLROUTER TraceflowObservationDroppedReason = "LROUTER"
const TraceflowObservationDroppedReasonLSERVICE TraceflowObservationDroppedReason = "LSERVICE"
const TraceflowObservationDroppedReasonLSWITCH TraceflowObservationDroppedReason = "LSWITCH"
const TraceflowObservationDroppedReasonMANAGEMENT TraceflowObservationDroppedReason = "MANAGEMENT"
const TraceflowObservationDroppedReasonMDPROXY TraceflowObservationDroppedReason = "MD_PROXY"
const TraceflowObservationDroppedReasonNAT TraceflowObservationDroppedReason = "NAT"
const TraceflowObservationDroppedReasonNDNSFAIL TraceflowObservationDroppedReason = "ND_NS_FAIL"
const TraceflowObservationDroppedReasonNEIGH TraceflowObservationDroppedReason = "NEIGH"
const TraceflowObservationDroppedReasonNOEIPASSOCIATION TraceflowObservationDroppedReason = "NO_EIP_ASSOCIATION"
const TraceflowObservationDroppedReasonNOEIPFOUND TraceflowObservationDroppedReason = "NO_EIP_FOUND"
const TraceflowObservationDroppedReasonNOENIFORIP TraceflowObservationDroppedReason = "NO_ENI_FOR_IP"
const TraceflowObservationDroppedReasonNOENIFORLIF TraceflowObservationDroppedReason = "NO_ENI_FOR_LIF"
const TraceflowObservationDroppedReasonNOMAC TraceflowObservationDroppedReason = "NO_MAC"
const TraceflowObservationDroppedReasonNOROUTE TraceflowObservationDroppedReason = "NO_ROUTE"
const TraceflowObservationDroppedReasonNOROUTETABLEFOUND TraceflowObservationDroppedReason = "NO_ROUTE_TABLE_FOUND"
const TraceflowObservationDroppedReasonNOTVDRDOWNLINK TraceflowObservationDroppedReason = "NOT_VDR_DOWNLINK"
const TraceflowObservationDroppedReasonNOTVDRUPLINK TraceflowObservationDroppedReason = "NOT_VDR_UPLINK"
const TraceflowObservationDroppedReasonNOUNDERLAYROUTEFOUND TraceflowObservationDroppedReason = "NO_UNDERLAY_ROUTE_FOUND"
const TraceflowObservationDroppedReasonNOVDRFOUND TraceflowObservationDroppedReason = "NO_VDR_FOUND"
const TraceflowObservationDroppedReasonNOVDRONHOST TraceflowObservationDroppedReason = "NO_VDR_ON_HOST"
const TraceflowObservationDroppedReasonRTEPTUNNEL TraceflowObservationDroppedReason = "RTEP_TUNNEL"
const TraceflowObservationDroppedReasonSERVICEINSERT TraceflowObservationDroppedReason = "SERVICE_INSERT"
const TraceflowObservationDroppedReasonSPOOFGUARD TraceflowObservationDroppedReason = "SPOOFGUARD"
const TraceflowObservationDroppedReasonTTLZERO TraceflowObservationDroppedReason = "TTL_ZERO"
const TraceflowObservationDroppedReasonTUNNEL TraceflowObservationDroppedReason = "TUNNEL"
const TraceflowObservationDroppedReasonUNKNOWN TraceflowObservationDroppedReason = "UNKNOWN"
const TraceflowObservationDroppedReasonVLAN TraceflowObservationDroppedReason = "VLAN"
const TraceflowObservationDroppedReasonVMCNORESPONSE TraceflowObservationDroppedReason = "VMC_NO_RESPONSE"
const TraceflowObservationDroppedReasonVXLAN TraceflowObservationDroppedReason = "VXLAN"
const TraceflowObservationDroppedReasonVXSTT TraceflowObservationDroppedReason = "VXSTT"
const TraceflowObservationDroppedReasonWRONGUPLINK TraceflowObservationDroppedReason = "WRONG_UPLINK"

var enumValues_TraceflowObservationDroppedReason = []interface{}{
	"ARP_FAIL",
	"BFD",
	"BROADCAST",
	"DHCP",
	"DLB",
	"FW_RULE",
	"GENEVE",
	"GRE",
	"IFACE",
	"IP",
	"IP_REASS",
	"IPSEC",
	"IPSEC_VTI",
	"L2VPN",
	"L4PORT",
	"LB",
	"LROUTER",
	"LSERVICE",
	"LSWITCH",
	"MANAGEMENT",
	"MD_PROXY",
	"NAT",
	"RTEP_TUNNEL",
	"ND_NS_FAIL",
	"NEIGH",
	"NO_EIP_FOUND",
	"NO_EIP_ASSOCIATION",
	"NO_ENI_FOR_IP",
	"NO_ENI_FOR_LIF",
	"NO_ROUTE",
	"NO_ROUTE_TABLE_FOUND",
	"NO_UNDERLAY_ROUTE_FOUND",
	"NOT_VDR_DOWNLINK",
	"NO_VDR_FOUND",
	"NO_VDR_ON_HOST",
	"NOT_VDR_UPLINK",
	"SERVICE_INSERT",
	"SPOOFGUARD",
	"TTL_ZERO",
	"TUNNEL",
	"VLAN",
	"VXLAN",
	"VXSTT",
	"VMC_NO_RESPONSE",
	"WRONG_UPLINK",
	"FW_STATE",
	"NO_MAC",
	"UNKNOWN",
	"FILTERED_UPLINK",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationDroppedReason) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowObservationDroppedReason {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowObservationDroppedReason, v)
	}
	*j = TraceflowObservationDroppedReason(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationDropped) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain TraceflowObservationDropped
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = TraceflowObservationDropped(plain)
	return nil
}

type TraceflowObservationForwarded struct {
	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// Context corresponds to the JSON schema field "context".
	Context *int `json:"context,omitempty" yaml:"context,omitempty" mapstructure:"context,omitempty"`

	// This field will not be always available. Use remote_ip_address when this field
	// is not set.
	DstTransportNodeId *string `json:"dst_transport_node_id,omitempty" yaml:"dst_transport_node_id,omitempty" mapstructure:"dst_transport_node_id,omitempty"`

	// DstTransportNodeName corresponds to the JSON schema field
	// "dst_transport_node_name".
	DstTransportNodeName *string `json:"dst_transport_node_name,omitempty" yaml:"dst_transport_node_name,omitempty" mapstructure:"dst_transport_node_name,omitempty"`

	// LocalIpAddress corresponds to the JSON schema field "local_ip_address".
	LocalIpAddress *IPAddress `json:"local_ip_address,omitempty" yaml:"local_ip_address,omitempty" mapstructure:"local_ip_address,omitempty"`

	// RemoteIpAddress corresponds to the JSON schema field "remote_ip_address".
	RemoteIpAddress *IPAddress `json:"remote_ip_address,omitempty" yaml:"remote_ip_address,omitempty" mapstructure:"remote_ip_address,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`

	// UplinkName corresponds to the JSON schema field "uplink_name".
	UplinkName *string `json:"uplink_name,omitempty" yaml:"uplink_name,omitempty" mapstructure:"uplink_name,omitempty"`

	// VtepLabel corresponds to the JSON schema field "vtep_label".
	VtepLabel *int `json:"vtep_label,omitempty" yaml:"vtep_label,omitempty" mapstructure:"vtep_label,omitempty"`
}

type TraceflowObservationForwardedLogical struct {
	// This field is specified when the traceflow packet matched a L3 firewall rule.
	AclRuleId *int `json:"acl_rule_id,omitempty" yaml:"acl_rule_id,omitempty" mapstructure:"acl_rule_id,omitempty"`

	// ComponentId corresponds to the JSON schema field "component_id".
	ComponentId *string `json:"component_id,omitempty" yaml:"component_id,omitempty" mapstructure:"component_id,omitempty"`

	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// DstComponentId corresponds to the JSON schema field "dst_component_id".
	DstComponentId *string `json:"dst_component_id,omitempty" yaml:"dst_component_id,omitempty" mapstructure:"dst_component_id,omitempty"`

	// DstComponentName corresponds to the JSON schema field "dst_component_name".
	DstComponentName *string `json:"dst_component_name,omitempty" yaml:"dst_component_name,omitempty" mapstructure:"dst_component_name,omitempty"`

	// DstComponentType corresponds to the JSON schema field "dst_component_type".
	DstComponentType *TraceflowComponentType `json:"dst_component_type,omitempty" yaml:"dst_component_type,omitempty" mapstructure:"dst_component_type,omitempty"`

	// This field is specified when the traceflow packet was forwarded through IPSec
	// VPN.
	IpsecVpn *TraceflowObservationIpsecVpn `json:"ipsec_vpn,omitempty" yaml:"ipsec_vpn,omitempty" mapstructure:"ipsec_vpn,omitempty"`

	// This field is specified when the traceflow packet matched a jump-to rule.
	JumptoRuleId *int `json:"jumpto_rule_id,omitempty" yaml:"jumpto_rule_id,omitempty" mapstructure:"jumpto_rule_id,omitempty"`

	// This field is specified when the traceflow packet matched a l2 rule.
	L2RuleId *int `json:"l2_rule_id,omitempty" yaml:"l2_rule_id,omitempty" mapstructure:"l2_rule_id,omitempty"`

	// LportId corresponds to the JSON schema field "lport_id".
	LportId *string `json:"lport_id,omitempty" yaml:"lport_id,omitempty" mapstructure:"lport_id,omitempty"`

	// LportName corresponds to the JSON schema field "lport_name".
	LportName *string `json:"lport_name,omitempty" yaml:"lport_name,omitempty" mapstructure:"lport_name,omitempty"`

	// This field is specified when the traceflow packet matched a NAT rule.
	NatRuleId *int `json:"nat_rule_id,omitempty" yaml:"nat_rule_id,omitempty" mapstructure:"nat_rule_id,omitempty"`

	// This field is specified when the traceflow packet was routed by logical router.
	NextHop *IPAddress `json:"next_hop,omitempty" yaml:"next_hop,omitempty" mapstructure:"next_hop,omitempty"`

	// ARP_UNKNOWN_FROM_CP - Unknown ARP query result emitted by control plane
	// ND_NS_UNKNOWN_FROM_CP - Unknown neighbor solicitation query result emitted by
	// control plane UNKNOWN - Unknown resend type
	ResendType *TraceflowObservationForwardedLogicalResendType `json:"resend_type,omitempty" yaml:"resend_type,omitempty" mapstructure:"resend_type,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// This field is specified when the traceflow packet was routed by logical router.
	RoutePrefix *IPCIDRBlock `json:"route_prefix,omitempty" yaml:"route_prefix,omitempty" mapstructure:"route_prefix,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// ServiceIndex corresponds to the JSON schema field "service_index".
	ServiceIndex *int `json:"service_index,omitempty" yaml:"service_index,omitempty" mapstructure:"service_index,omitempty"`

	// ServicePathIndex corresponds to the JSON schema field "service_path_index".
	ServicePathIndex *int `json:"service_path_index,omitempty" yaml:"service_path_index,omitempty" mapstructure:"service_path_index,omitempty"`

	// ServiceTtl corresponds to the JSON schema field "service_ttl".
	ServiceTtl *int `json:"service_ttl,omitempty" yaml:"service_ttl,omitempty" mapstructure:"service_ttl,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// This field specified the prefix IP address a traceflow packet matched in the
	// whitelist in spoofguard.
	SpoofguardIp *IPCIDRBlock `json:"spoofguard_ip,omitempty" yaml:"spoofguard_ip,omitempty" mapstructure:"spoofguard_ip,omitempty"`

	// The source MAC address of form: "^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$".
	// For example: 00:00:00:00:00:00.
	SpoofguardMac *MACAddress `json:"spoofguard_mac,omitempty" yaml:"spoofguard_mac,omitempty" mapstructure:"spoofguard_mac,omitempty"`

	// This field specified the VLAN id a traceflow packet matched in the whitelist in
	// spoofguard.
	SpoofguardVlanId *VlanID `json:"spoofguard_vlan_id,omitempty" yaml:"spoofguard_vlan_id,omitempty" mapstructure:"spoofguard_vlan_id,omitempty"`

	// MAC address of nexthop for service insertion(SI) in service VM(SVM) where the
	// traceflow packet was received.
	SvcNhMac *string `json:"svc_nh_mac,omitempty" yaml:"svc_nh_mac,omitempty" mapstructure:"svc_nh_mac,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TranslatedDstIp corresponds to the JSON schema field "translated_dst_ip".
	TranslatedDstIp *IPAddress `json:"translated_dst_ip,omitempty" yaml:"translated_dst_ip,omitempty" mapstructure:"translated_dst_ip,omitempty"`

	// TranslatedSrcIp corresponds to the JSON schema field "translated_src_ip".
	TranslatedSrcIp *IPAddress `json:"translated_src_ip,omitempty" yaml:"translated_src_ip,omitempty" mapstructure:"translated_src_ip,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`

	// This field is specified when the traceflow packet was forwarded by a VLAN
	// logical network.
	Vlan *VlanID `json:"vlan,omitempty" yaml:"vlan,omitempty" mapstructure:"vlan,omitempty"`

	// This field is specified when the traceflow packet was forwarded by an overlay
	// logical network.
	Vni *int `json:"vni,omitempty" yaml:"vni,omitempty" mapstructure:"vni,omitempty"`
}

type TraceflowObservationForwardedLogicalResendType string

const TraceflowObservationForwardedLogicalResendTypeARPUNKNOWNFROMCP TraceflowObservationForwardedLogicalResendType = "ARP_UNKNOWN_FROM_CP"
const TraceflowObservationForwardedLogicalResendTypeNDNSUNKNWONFROMCP TraceflowObservationForwardedLogicalResendType = "ND_NS_UNKNWON_FROM_CP"
const TraceflowObservationForwardedLogicalResendTypeUNKNOWN TraceflowObservationForwardedLogicalResendType = "UNKNOWN"

var enumValues_TraceflowObservationForwardedLogicalResendType = []interface{}{
	"UNKNOWN",
	"ARP_UNKNOWN_FROM_CP",
	"ND_NS_UNKNWON_FROM_CP",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationForwardedLogicalResendType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowObservationForwardedLogicalResendType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowObservationForwardedLogicalResendType, v)
	}
	*j = TraceflowObservationForwardedLogicalResendType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationForwardedLogical) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain TraceflowObservationForwardedLogical
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = TraceflowObservationForwardedLogical(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationForwarded) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain TraceflowObservationForwarded
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = TraceflowObservationForwarded(plain)
	return nil
}

// IPSec VPN traceflow observation.
type TraceflowObservationIpsecVpn struct {
	// Inner destination IP Address.
	InnerDstIp *IPAddress `json:"inner_dst_ip,omitempty" yaml:"inner_dst_ip,omitempty" mapstructure:"inner_dst_ip,omitempty"`

	// Inner source IP Address.
	InnerSrcIp *IPAddress `json:"inner_src_ip,omitempty" yaml:"inner_src_ip,omitempty" mapstructure:"inner_src_ip,omitempty"`

	// Local VPN endpoint IP Address.
	LocalIp *IPAddress `json:"local_ip,omitempty" yaml:"local_ip,omitempty" mapstructure:"local_ip,omitempty"`

	// IPSec tunnel interface universally unique identifier in case of Policy-based
	// IPSec VPN.
	PolicyId *string `json:"policy_id,omitempty" yaml:"policy_id,omitempty" mapstructure:"policy_id,omitempty"`

	// Peer VPN endpoint IP Address.
	RemoteIp *IPAddress `json:"remote_ip,omitempty" yaml:"remote_ip,omitempty" mapstructure:"remote_ip,omitempty"`

	// IPSec VPN session universally unique identifier.
	SessionId *string `json:"session_id,omitempty" yaml:"session_id,omitempty" mapstructure:"session_id,omitempty"`

	// Security Parameter Index is used to uniquely identify a particular IPSec
	// Security Association.
	Spi *int `json:"spi,omitempty" yaml:"spi,omitempty" mapstructure:"spi,omitempty"`

	// Virtual tunnel interface universally unique identifier in case of Route-based
	// IPSec VPN.
	VtiId *string `json:"vti_id,omitempty" yaml:"vti_id,omitempty" mapstructure:"vti_id,omitempty"`
}

type TraceflowObservationProtected struct {
	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// Holding the type of observation before converted to protected type.
	OriginalType *TraceflowObservationType `json:"original_type,omitempty" yaml:"original_type,omitempty" mapstructure:"original_type,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationProtected) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain TraceflowObservationProtected
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = TraceflowObservationProtected(plain)
	return nil
}

type TraceflowObservationReceived struct {
	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// LocalIpAddress corresponds to the JSON schema field "local_ip_address".
	LocalIpAddress *IPAddress `json:"local_ip_address,omitempty" yaml:"local_ip_address,omitempty" mapstructure:"local_ip_address,omitempty"`

	// RemoteIpAddress corresponds to the JSON schema field "remote_ip_address".
	RemoteIpAddress *IPAddress `json:"remote_ip_address,omitempty" yaml:"remote_ip_address,omitempty" mapstructure:"remote_ip_address,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`

	// UplinkName corresponds to the JSON schema field "uplink_name".
	UplinkName *string `json:"uplink_name,omitempty" yaml:"uplink_name,omitempty" mapstructure:"uplink_name,omitempty"`

	// VtepLabel corresponds to the JSON schema field "vtep_label".
	VtepLabel *int `json:"vtep_label,omitempty" yaml:"vtep_label,omitempty" mapstructure:"vtep_label,omitempty"`
}

type TraceflowObservationReceivedLogical struct {
	// ComponentId corresponds to the JSON schema field "component_id".
	ComponentId *string `json:"component_id,omitempty" yaml:"component_id,omitempty" mapstructure:"component_id,omitempty"`

	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// This field is specified when the traceflow packet was received on IPSec VPN.
	IpsecVpn *TraceflowObservationIpsecVpn `json:"ipsec_vpn,omitempty" yaml:"ipsec_vpn,omitempty" mapstructure:"ipsec_vpn,omitempty"`

	// LportId corresponds to the JSON schema field "lport_id".
	LportId *string `json:"lport_id,omitempty" yaml:"lport_id,omitempty" mapstructure:"lport_id,omitempty"`

	// LportName corresponds to the JSON schema field "lport_name".
	LportName *string `json:"lport_name,omitempty" yaml:"lport_name,omitempty" mapstructure:"lport_name,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// SrcComponentId corresponds to the JSON schema field "src_component_id".
	SrcComponentId *string `json:"src_component_id,omitempty" yaml:"src_component_id,omitempty" mapstructure:"src_component_id,omitempty"`

	// SrcComponentName corresponds to the JSON schema field "src_component_name".
	SrcComponentName *string `json:"src_component_name,omitempty" yaml:"src_component_name,omitempty" mapstructure:"src_component_name,omitempty"`

	// SrcComponentType corresponds to the JSON schema field "src_component_type".
	SrcComponentType *TraceflowComponentType `json:"src_component_type,omitempty" yaml:"src_component_type,omitempty" mapstructure:"src_component_type,omitempty"`

	// MAC address of SAN volume controller for service insertion(SI) in service
	// VM(SVM) where the traceflow packet was received.
	SvcMac *string `json:"svc_mac,omitempty" yaml:"svc_mac,omitempty" mapstructure:"svc_mac,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`

	// This field is specified when the traceflow packet was received by a VLAN
	// logical network.
	Vlan *VlanID `json:"vlan,omitempty" yaml:"vlan,omitempty" mapstructure:"vlan,omitempty"`

	// This field is specified when the traceflow packet was received by an overlay
	// logical network.
	Vni *int `json:"vni,omitempty" yaml:"vni,omitempty" mapstructure:"vni,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationReceivedLogical) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain TraceflowObservationReceivedLogical
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = TraceflowObservationReceivedLogical(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationReceived) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain TraceflowObservationReceived
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = TraceflowObservationReceived(plain)
	return nil
}

type TraceflowObservationRelayedLogical struct {
	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// This field specified the IP address of the destination which the packet will be
	// relayed.
	DstServerAddress *IPAddress `json:"dst_server_address,omitempty" yaml:"dst_server_address,omitempty" mapstructure:"dst_server_address,omitempty"`

	// This field specified the logical component that relay service located.
	LogicalCompUuid *string `json:"logical_comp_uuid,omitempty" yaml:"logical_comp_uuid,omitempty" mapstructure:"logical_comp_uuid,omitempty"`

	// This field specified the message type of the relay service REQUEST - The relay
	// service will relay a request message to the destination server REPLY - The
	// relay service will relay a reply message to the client
	MessageType TraceflowObservationRelayedLogicalMessageType `json:"message_type,omitempty" yaml:"message_type,omitempty" mapstructure:"message_type,omitempty"`

	// This field specified the IP address of the relay service.
	RelayServerAddress *IPAddress `json:"relay_server_address,omitempty" yaml:"relay_server_address,omitempty" mapstructure:"relay_server_address,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`
}

type TraceflowObservationRelayedLogicalMessageType string

const TraceflowObservationRelayedLogicalMessageTypeREPLY TraceflowObservationRelayedLogicalMessageType = "REPLY"
const TraceflowObservationRelayedLogicalMessageTypeREQUEST TraceflowObservationRelayedLogicalMessageType = "REQUEST"

var enumValues_TraceflowObservationRelayedLogicalMessageType = []interface{}{
	"REQUEST",
	"REPLY",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationRelayedLogicalMessageType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowObservationRelayedLogicalMessageType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowObservationRelayedLogicalMessageType, v)
	}
	*j = TraceflowObservationRelayedLogicalMessageType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationRelayedLogical) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain TraceflowObservationRelayedLogical
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["message_type"]; !ok || v == nil {
		plain.MessageType = "REQUEST"
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = TraceflowObservationRelayedLogical(plain)
	return nil
}

type TraceflowObservationReplicationLogical struct {
	// ComponentName corresponds to the JSON schema field "component_name".
	ComponentName *string `json:"component_name,omitempty" yaml:"component_name,omitempty" mapstructure:"component_name,omitempty"`

	// ComponentSubType corresponds to the JSON schema field "component_sub_type".
	ComponentSubType *TraceflowComponentSubType `json:"component_sub_type,omitempty" yaml:"component_sub_type,omitempty" mapstructure:"component_sub_type,omitempty"`

	// ComponentType corresponds to the JSON schema field "component_type".
	ComponentType *TraceflowComponentType `json:"component_type,omitempty" yaml:"component_type,omitempty" mapstructure:"component_type,omitempty"`

	// LocalIpAddress corresponds to the JSON schema field "local_ip_address".
	LocalIpAddress *IPAddress `json:"local_ip_address,omitempty" yaml:"local_ip_address,omitempty" mapstructure:"local_ip_address,omitempty"`

	// This field specifies the type of replication message TX_VTEP - Transmit
	// replication to all VTEPs TX_MTEP - Transmit replication to all MTEPs RX -
	// Receive replication
	ReplicationType *TraceflowObservationReplicationLogicalReplicationType `json:"replication_type,omitempty" yaml:"replication_type,omitempty" mapstructure:"replication_type,omitempty"`

	// ResourceType corresponds to the JSON schema field "resource_type".
	ResourceType TraceflowObservationType `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// the hop count for observations on the transport node that a traceflow packet is
	// injected in will be 0. The hop count is incremented each time a subsequent
	// transport node receives the traceflow packet. The sequence number of 999
	// indicates that the hop count could not be determined for the containing
	// observation.
	SequenceNo *int `json:"sequence_no,omitempty" yaml:"sequence_no,omitempty" mapstructure:"sequence_no,omitempty"`

	// This field contains the site path where this observation was generated.
	SitePath *string `json:"site_path,omitempty" yaml:"site_path,omitempty" mapstructure:"site_path,omitempty"`

	// Timestamp when the observation was created by the transport node (milliseconds
	// epoch)
	Timestamp *EpochMsTimestamp `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// Timestamp when the observation was created by the transport node (microseconds
	// epoch)
	TimestampMicro *int `json:"timestamp_micro,omitempty" yaml:"timestamp_micro,omitempty" mapstructure:"timestamp_micro,omitempty"`

	// TransportNodeId corresponds to the JSON schema field "transport_node_id".
	TransportNodeId *string `json:"transport_node_id,omitempty" yaml:"transport_node_id,omitempty" mapstructure:"transport_node_id,omitempty"`

	// TransportNodeName corresponds to the JSON schema field "transport_node_name".
	TransportNodeName *string `json:"transport_node_name,omitempty" yaml:"transport_node_name,omitempty" mapstructure:"transport_node_name,omitempty"`

	// TransportNodeType corresponds to the JSON schema field "transport_node_type".
	TransportNodeType *TransportNodeType `json:"transport_node_type,omitempty" yaml:"transport_node_type,omitempty" mapstructure:"transport_node_type,omitempty"`

	// UplinkName corresponds to the JSON schema field "uplink_name".
	UplinkName *string `json:"uplink_name,omitempty" yaml:"uplink_name,omitempty" mapstructure:"uplink_name,omitempty"`

	// VtepLabel corresponds to the JSON schema field "vtep_label".
	VtepLabel *int `json:"vtep_label,omitempty" yaml:"vtep_label,omitempty" mapstructure:"vtep_label,omitempty"`
}

type TraceflowObservationReplicationLogicalReplicationType string

const TraceflowObservationReplicationLogicalReplicationTypeRX TraceflowObservationReplicationLogicalReplicationType = "RX"
const TraceflowObservationReplicationLogicalReplicationTypeTXMTEP TraceflowObservationReplicationLogicalReplicationType = "TX_MTEP"
const TraceflowObservationReplicationLogicalReplicationTypeTXVTEP TraceflowObservationReplicationLogicalReplicationType = "TX_VTEP"

var enumValues_TraceflowObservationReplicationLogicalReplicationType = []interface{}{
	"TX_VTEP",
	"TX_MTEP",
	"RX",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationReplicationLogicalReplicationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowObservationReplicationLogicalReplicationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowObservationReplicationLogicalReplicationType, v)
	}
	*j = TraceflowObservationReplicationLogicalReplicationType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationReplicationLogical) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain TraceflowObservationReplicationLogical
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["resource_type"]; !ok || v == nil {
		plain.ResourceType = "TraceflowObservationReceived"
	}
	*j = TraceflowObservationReplicationLogical(plain)
	return nil
}

type TraceflowObservationType string

const TraceflowObservationTypeTraceflowObservationDelivered TraceflowObservationType = "TraceflowObservationDelivered"
const TraceflowObservationTypeTraceflowObservationDropped TraceflowObservationType = "TraceflowObservationDropped"
const TraceflowObservationTypeTraceflowObservationDroppedLogical TraceflowObservationType = "TraceflowObservationDroppedLogical"
const TraceflowObservationTypeTraceflowObservationForwarded TraceflowObservationType = "TraceflowObservationForwarded"
const TraceflowObservationTypeTraceflowObservationForwardedLogical TraceflowObservationType = "TraceflowObservationForwardedLogical"
const TraceflowObservationTypeTraceflowObservationProtected TraceflowObservationType = "TraceflowObservationProtected"
const TraceflowObservationTypeTraceflowObservationReceived TraceflowObservationType = "TraceflowObservationReceived"
const TraceflowObservationTypeTraceflowObservationReceivedLogical TraceflowObservationType = "TraceflowObservationReceivedLogical"
const TraceflowObservationTypeTraceflowObservationRelayedLogical TraceflowObservationType = "TraceflowObservationRelayedLogical"
const TraceflowObservationTypeTraceflowObservationReplicationLogical TraceflowObservationType = "TraceflowObservationReplicationLogical"

var enumValues_TraceflowObservationType = []interface{}{
	"TraceflowObservationForwarded",
	"TraceflowObservationDropped",
	"TraceflowObservationDelivered",
	"TraceflowObservationReceived",
	"TraceflowObservationForwardedLogical",
	"TraceflowObservationDroppedLogical",
	"TraceflowObservationReceivedLogical",
	"TraceflowObservationReplicationLogical",
	"TraceflowObservationRelayedLogical",
	"TraceflowObservationProtected",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TraceflowObservationType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TraceflowObservationType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TraceflowObservationType, v)
	}
	*j = TraceflowObservationType(v)
	return nil
}

type TransportNodeType string

const TransportNodeTypeCENTOSCONTAINER TransportNodeType = "CENTOSCONTAINER"
const TransportNodeTypeCENTOSKVM TransportNodeType = "CENTOSKVM"
const TransportNodeTypeCENTOSSERVER TransportNodeType = "CENTOSSERVER"
const TransportNodeTypeEDGE TransportNodeType = "EDGE"
const TransportNodeTypeESX TransportNodeType = "ESX"
const TransportNodeTypeHYPERV TransportNodeType = "HYPERV"
const TransportNodeTypeOELSERVER TransportNodeType = "OELSERVER"
const TransportNodeTypeOTHERS TransportNodeType = "OTHERS"
const TransportNodeTypePUBLICCLOUDGATEWAYNODE TransportNodeType = "PUBLIC_CLOUD_GATEWAY_NODE"
const TransportNodeTypeRHELCONTAINER TransportNodeType = "RHELCONTAINER"
const TransportNodeTypeRHELKVM TransportNodeType = "RHELKVM"
const TransportNodeTypeRHELSERVER TransportNodeType = "RHELSERVER"
const TransportNodeTypeRHELSMARTNIC TransportNodeType = "RHELSMARTNIC"
const TransportNodeTypeSLESKVM TransportNodeType = "SLESKVM"
const TransportNodeTypeSLESSERVER TransportNodeType = "SLESSERVER"
const TransportNodeTypeUBUNTUKVM TransportNodeType = "UBUNTUKVM"
const TransportNodeTypeUBUNTUSERVER TransportNodeType = "UBUNTUSERVER"
const TransportNodeTypeUBUNTUSMARTNIC TransportNodeType = "UBUNTUSMARTNIC"
const TransportNodeTypeWINDOWSSERVER TransportNodeType = "WINDOWSSERVER"

var enumValues_TransportNodeType = []interface{}{
	"ESX",
	"RHELKVM",
	"UBUNTUKVM",
	"CENTOSKVM",
	"RHELCONTAINER",
	"CENTOSCONTAINER",
	"RHELSERVER",
	"UBUNTUSERVER",
	"CENTOSSERVER",
	"SLESKVM",
	"SLESSERVER",
	"WINDOWSSERVER",
	"RHELSMARTNIC",
	"OELSERVER",
	"UBUNTUSMARTNIC",
	"EDGE",
	"PUBLIC_CLOUD_GATEWAY_NODE",
	"OTHERS",
	"HYPERV",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *TransportNodeType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_TransportNodeType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_TransportNodeType, v)
	}
	*j = TransportNodeType(v)
	return nil
}

type TransportProtocolHeader struct {
	// DhcpHeader corresponds to the JSON schema field "dhcp_header".
	DhcpHeader *DhcpHeader `json:"dhcp_header,omitempty" yaml:"dhcp_header,omitempty" mapstructure:"dhcp_header,omitempty"`

	// Dhcpv6Header corresponds to the JSON schema field "dhcpv6_header".
	Dhcpv6Header *Dhcpv6Header `json:"dhcpv6_header,omitempty" yaml:"dhcpv6_header,omitempty" mapstructure:"dhcpv6_header,omitempty"`

	// DnsHeader corresponds to the JSON schema field "dns_header".
	DnsHeader *DnsHeader `json:"dns_header,omitempty" yaml:"dns_header,omitempty" mapstructure:"dns_header,omitempty"`

	// IcmpEchoRequestHeader corresponds to the JSON schema field
	// "icmp_echo_request_header".
	IcmpEchoRequestHeader *IcmpEchoRequestHeader `json:"icmp_echo_request_header,omitempty" yaml:"icmp_echo_request_header,omitempty" mapstructure:"icmp_echo_request_header,omitempty"`

	// NdpHeader corresponds to the JSON schema field "ndp_header".
	NdpHeader *NdpHeader `json:"ndp_header,omitempty" yaml:"ndp_header,omitempty" mapstructure:"ndp_header,omitempty"`

	// TcpHeader corresponds to the JSON schema field "tcp_header".
	TcpHeader *TcpHeader `json:"tcp_header,omitempty" yaml:"tcp_header,omitempty" mapstructure:"tcp_header,omitempty"`

	// UdpHeader corresponds to the JSON schema field "udp_header".
	UdpHeader *UdpHeader `json:"udp_header,omitempty" yaml:"udp_header,omitempty" mapstructure:"udp_header,omitempty"`
}

type UdpHeader struct {
	// DstPort corresponds to the JSON schema field "dst_port".
	DstPort int `json:"dst_port,omitempty" yaml:"dst_port,omitempty" mapstructure:"dst_port,omitempty"`

	// SrcPort corresponds to the JSON schema field "src_port".
	SrcPort int `json:"src_port,omitempty" yaml:"src_port,omitempty" mapstructure:"src_port,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *UdpHeader) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain UdpHeader
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["dst_port"]; !ok || v == nil {
		plain.DstPort = 0.0
	}
	if v, ok := raw["src_port"]; !ok || v == nil {
		plain.SrcPort = 0.0
	}
	*j = UdpHeader(plain)
	return nil
}

type UnboundedKeyValuePair struct {
	// Key corresponds to the JSON schema field "key".
	Key *string `json:"key,omitempty" yaml:"key,omitempty" mapstructure:"key,omitempty"`

	// Value corresponds to the JSON schema field "value".
	Value *string `json:"value,omitempty" yaml:"value,omitempty" mapstructure:"value,omitempty"`
}

type VirtualMachine struct {
	// Timestamp of last modification
	LastSyncTime *EpochMsTimestamp `json:"_last_sync_time,omitempty" yaml:"_last_sync_time,omitempty" mapstructure:"_last_sync_time,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// ComputeIds corresponds to the JSON schema field "compute_ids".
	ComputeIds []string `json:"compute_ids,omitempty" yaml:"compute_ids,omitempty" mapstructure:"compute_ids,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// ExternalId corresponds to the JSON schema field "external_id".
	ExternalId *string `json:"external_id,omitempty" yaml:"external_id,omitempty" mapstructure:"external_id,omitempty"`

	// Guest virtual machine details include OS name, computer name of guest VM.
	// Currently this is supported for guests on ESXi that have VMware Tools
	// installed.
	GuestInfo *GuestInfo `json:"guest_info,omitempty" yaml:"guest_info,omitempty" mapstructure:"guest_info,omitempty"`

	// HostId corresponds to the JSON schema field "host_id".
	HostId *string `json:"host_id,omitempty" yaml:"host_id,omitempty" mapstructure:"host_id,omitempty"`

	// LocalIdOnHost corresponds to the JSON schema field "local_id_on_host".
	LocalIdOnHost *string `json:"local_id_on_host,omitempty" yaml:"local_id_on_host,omitempty" mapstructure:"local_id_on_host,omitempty"`

	// PowerState corresponds to the JSON schema field "power_state".
	PowerState *VirtualMachinePowerState `json:"power_state,omitempty" yaml:"power_state,omitempty" mapstructure:"power_state,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Specifies runtime details of virtual machine.
	RuntimeInfo *VirtualMachineRuntimeInfo `json:"runtime_info,omitempty" yaml:"runtime_info,omitempty" mapstructure:"runtime_info,omitempty"`

	// Specifies list of scope of discovered resource. e.g. if VHC path is associated
	// with principal identity, who owns the discovered resource, then scope id will
	// be VHC path and scope type will be VHC.
	Scope []DiscoveredResourceScope `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// Source corresponds to the JSON schema field "source".
	Source *ResourceReference `json:"source,omitempty" yaml:"source,omitempty" mapstructure:"source,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Type corresponds to the JSON schema field "type".
	Type *VirtualMachineType `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`

	// If UPT enabled is true for any virtual network interface of the virtual
	// machine, then this property is true for the virtual machine.
	Uptv2Enabled *bool `json:"uptv2_enabled,omitempty" yaml:"uptv2_enabled,omitempty" mapstructure:"uptv2_enabled,omitempty"`
}

type VirtualMachinePowerState string

const VirtualMachinePowerStateUNKNOWN VirtualMachinePowerState = "UNKNOWN"
const VirtualMachinePowerStateVMRUNNING VirtualMachinePowerState = "VM_RUNNING"
const VirtualMachinePowerStateVMSTOPPED VirtualMachinePowerState = "VM_STOPPED"
const VirtualMachinePowerStateVMSUSPENDED VirtualMachinePowerState = "VM_SUSPENDED"

var enumValues_VirtualMachinePowerState = []interface{}{
	"VM_RUNNING",
	"VM_STOPPED",
	"VM_SUSPENDED",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualMachinePowerState) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VirtualMachinePowerState {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VirtualMachinePowerState, v)
	}
	*j = VirtualMachinePowerState(v)
	return nil
}

// Specifies details of runtime for a virtual machine
type VirtualMachineRuntimeInfo struct {
	// Specifies list of runtime details of virtual network interfaces of virtual
	// machine.
	VifRuntimeInfo []VirtualNetworkInterfaceRuntimeInfo `json:"vif_runtime_info,omitempty" yaml:"vif_runtime_info,omitempty" mapstructure:"vif_runtime_info,omitempty"`
}

type VirtualMachineType string

const VirtualMachineTypeEDGE VirtualMachineType = "EDGE"
const VirtualMachineTypeINTELLIGENCE VirtualMachineType = "INTELLIGENCE"
const VirtualMachineTypeMP VirtualMachineType = "MP"
const VirtualMachineTypeREGULAR VirtualMachineType = "REGULAR"
const VirtualMachineTypeSERVICE VirtualMachineType = "SERVICE"
const VirtualMachineTypeUNKNOWN VirtualMachineType = "UNKNOWN"
const VirtualMachineTypeVCSYSTEM VirtualMachineType = "VC_SYSTEM"

var enumValues_VirtualMachineType = []interface{}{
	"EDGE",
	"SERVICE",
	"REGULAR",
	"MP",
	"INTELLIGENCE",
	"VC_SYSTEM",
	"UNKNOWN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualMachineType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VirtualMachineType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VirtualMachineType, v)
	}
	*j = VirtualMachineType(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualMachine) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VirtualMachine
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = VirtualMachine(plain)
	return nil
}

type VirtualNetworkInterface struct {
	// Timestamp of last modification
	LastSyncTime *EpochMsTimestamp `json:"_last_sync_time,omitempty" yaml:"_last_sync_time,omitempty" mapstructure:"_last_sync_time,omitempty"`

	// The server will populate this field when returing the resource. Ignored on PUT
	// and POST.
	Links []ResourceLink `json:"_links,omitempty" yaml:"_links,omitempty" mapstructure:"_links,omitempty"`

	// Schema corresponds to the JSON schema field "_schema".
	Schema *string `json:"_schema,omitempty" yaml:"_schema,omitempty" mapstructure:"_schema,omitempty"`

	// Self corresponds to the JSON schema field "_self".
	Self *SelfResourceLink `json:"_self,omitempty" yaml:"_self,omitempty" mapstructure:"_self,omitempty"`

	// Description corresponds to the JSON schema field "description".
	Description *string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// DeviceKey corresponds to the JSON schema field "device_key".
	DeviceKey *string `json:"device_key,omitempty" yaml:"device_key,omitempty" mapstructure:"device_key,omitempty"`

	// DeviceName corresponds to the JSON schema field "device_name".
	DeviceName *string `json:"device_name,omitempty" yaml:"device_name,omitempty" mapstructure:"device_name,omitempty"`

	// Defaults to Id if not set
	DisplayName *string `json:"display_name,omitempty" yaml:"display_name,omitempty" mapstructure:"display_name,omitempty"`

	// ExternalId corresponds to the JSON schema field "external_id".
	ExternalId *string `json:"external_id,omitempty" yaml:"external_id,omitempty" mapstructure:"external_id,omitempty"`

	// HostId corresponds to the JSON schema field "host_id".
	HostId *string `json:"host_id,omitempty" yaml:"host_id,omitempty" mapstructure:"host_id,omitempty"`

	// IpAddressInfo corresponds to the JSON schema field "ip_address_info".
	IpAddressInfo []IpAddressInfo `json:"ip_address_info,omitempty" yaml:"ip_address_info,omitempty" mapstructure:"ip_address_info,omitempty"`

	// LportAttachmentId corresponds to the JSON schema field "lport_attachment_id".
	LportAttachmentId *string `json:"lport_attachment_id,omitempty" yaml:"lport_attachment_id,omitempty" mapstructure:"lport_attachment_id,omitempty"`

	// MacAddress corresponds to the JSON schema field "mac_address".
	MacAddress *string `json:"mac_address,omitempty" yaml:"mac_address,omitempty" mapstructure:"mac_address,omitempty"`

	// OwnerVmId corresponds to the JSON schema field "owner_vm_id".
	OwnerVmId *string `json:"owner_vm_id,omitempty" yaml:"owner_vm_id,omitempty" mapstructure:"owner_vm_id,omitempty"`

	// OwnerVmType corresponds to the JSON schema field "owner_vm_type".
	OwnerVmType *VirtualNetworkInterfaceOwnerVmType `json:"owner_vm_type,omitempty" yaml:"owner_vm_type,omitempty" mapstructure:"owner_vm_type,omitempty"`

	// The type of this resource.
	ResourceType *string `json:"resource_type,omitempty" yaml:"resource_type,omitempty" mapstructure:"resource_type,omitempty"`

	// Specifies list of scope of discovered resource. e.g. if VHC path is associated
	// with principal identity, who owns the discovered resource, then scope id will
	// be VHC path and scope type will be VHC.
	Scope []DiscoveredResourceScope `json:"scope,omitempty" yaml:"scope,omitempty" mapstructure:"scope,omitempty"`

	// Tags corresponds to the JSON schema field "tags".
	Tags []Tag `json:"tags,omitempty" yaml:"tags,omitempty" mapstructure:"tags,omitempty"`

	// Specifies if UPTv2 (Universal Pass-through version 2) compatibility is enabled
	// for the virtual network interface or not.
	Uptv2Enabled *bool `json:"uptv2_enabled,omitempty" yaml:"uptv2_enabled,omitempty" mapstructure:"uptv2_enabled,omitempty"`

	// VmLocalIdOnHost corresponds to the JSON schema field "vm_local_id_on_host".
	VmLocalIdOnHost *string `json:"vm_local_id_on_host,omitempty" yaml:"vm_local_id_on_host,omitempty" mapstructure:"vm_local_id_on_host,omitempty"`
}

type VirtualNetworkInterfaceOwnerVmType string

const VirtualNetworkInterfaceOwnerVmTypeEDGE VirtualNetworkInterfaceOwnerVmType = "EDGE"
const VirtualNetworkInterfaceOwnerVmTypeREGULAR VirtualNetworkInterfaceOwnerVmType = "REGULAR"
const VirtualNetworkInterfaceOwnerVmTypeSERVICE VirtualNetworkInterfaceOwnerVmType = "SERVICE"

var enumValues_VirtualNetworkInterfaceOwnerVmType = []interface{}{
	"EDGE",
	"SERVICE",
	"REGULAR",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualNetworkInterfaceOwnerVmType) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VirtualNetworkInterfaceOwnerVmType {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VirtualNetworkInterfaceOwnerVmType, v)
	}
	*j = VirtualNetworkInterfaceOwnerVmType(v)
	return nil
}

// Runtime details of virtual network interface of virtual machine.
type VirtualNetworkInterfaceRuntimeInfo struct {
	// ExternalId corresponds to the JSON schema field "external_id".
	ExternalId *string `json:"external_id,omitempty" yaml:"external_id,omitempty" mapstructure:"external_id,omitempty"`

	// This flag specifies whether UPTv2 (Universal Pass-through version 2) is active
	// on the virtual network interface or not. If TRUE, then the virtual network
	// interface works in the pass-through mode. If FALSE, then the virtual network
	// interface still has network connectivity but works in emulated mode and
	// pass-through is not enabled. This flag is NONE, if it is not applicable.
	Uptv2Active *VirtualNetworkInterfaceRuntimeInfoUptv2Active `json:"uptv2_active,omitempty" yaml:"uptv2_active,omitempty" mapstructure:"uptv2_active,omitempty"`
}

type VirtualNetworkInterfaceRuntimeInfoUptv2Active string

const VirtualNetworkInterfaceRuntimeInfoUptv2ActiveNONE VirtualNetworkInterfaceRuntimeInfoUptv2Active = "NONE"

var enumValues_VirtualNetworkInterfaceRuntimeInfoUptv2Active = []interface{}{
	"NONE",
	true,
	false,
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualNetworkInterfaceRuntimeInfoUptv2Active) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VirtualNetworkInterfaceRuntimeInfoUptv2Active {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VirtualNetworkInterfaceRuntimeInfoUptv2Active, v)
	}
	*j = VirtualNetworkInterfaceRuntimeInfoUptv2Active(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VirtualNetworkInterface) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VirtualNetworkInterface
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.Description != nil && len(*plain.Description) > 1024 {
		return fmt.Errorf("field %s length: must be <= %d", "description", 1024)
	}
	if plain.DisplayName != nil && len(*plain.DisplayName) > 255 {
		return fmt.Errorf("field %s length: must be <= %d", "display_name", 255)
	}
	if len(plain.Tags) > 30 {
		return fmt.Errorf("field %s length: must be <= %d", "tags", 30)
	}
	*j = VirtualNetworkInterface(plain)
	return nil
}

type VlanID int

type VrfEvpnL2VniConfig struct {
	// This is used to enable or disable the creation of vtep groups. Each vtep group
	// is used to group vteps with the same MAC for L2 ECMP usage.
	EnableVtepGroups bool `json:"enable_vtep_groups,omitempty" yaml:"enable_vtep_groups,omitempty" mapstructure:"enable_vtep_groups,omitempty"`

	// Define L2 VNI and its related route distinguiser and route targets.
	L2VniConfigs []VrfL2VniConfig `json:"l2_vni_configs,omitempty" yaml:"l2_vni_configs,omitempty" mapstructure:"l2_vni_configs,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrfEvpnL2VniConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VrfEvpnL2VniConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["enable_vtep_groups"]; !ok || v == nil {
		plain.EnableVtepGroups = false
	}
	if plain.L2VniConfigs != nil && len(plain.L2VniConfigs) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "l2_vni_configs", 1)
	}
	if len(plain.L2VniConfigs) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "l2_vni_configs", 1)
	}
	*j = VrfEvpnL2VniConfig(plain)
	return nil
}

type VrfL2VniConfig struct {
	// L2 VNI associated with the VRF. It must be unique and available from the VNI
	// pool defined for EVPN service.
	L2Vni *int `json:"l2_vni,omitempty" yaml:"l2_vni,omitempty" mapstructure:"l2_vni,omitempty"`

	// This is a 64 bit number which disambiguates overlapping logical networks, with
	// format in IPAddress:<number> or ASN:<number>.
	RouteDistinguisher *string `json:"route_distinguisher,omitempty" yaml:"route_distinguisher,omitempty" mapstructure:"route_distinguisher,omitempty"`

	// Route targets.
	RouteTargets []VrfRouteTargets `json:"route_targets,omitempty" yaml:"route_targets,omitempty" mapstructure:"route_targets,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrfL2VniConfig) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VrfL2VniConfig
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if plain.RouteTargets != nil && len(plain.RouteTargets) < 1 {
		return fmt.Errorf("field %s length: must be >= %d", "route_targets", 1)
	}
	if len(plain.RouteTargets) > 1 {
		return fmt.Errorf("field %s length: must be <= %d", "route_targets", 1)
	}
	*j = VrfL2VniConfig(plain)
	return nil
}

// Vrf Route Targets for import/export.
type VrfRouteTargets struct {
	// Address family.
	AddressFamily VrfRouteTargetsAddressFamily `json:"address_family,omitempty" yaml:"address_family,omitempty" mapstructure:"address_family,omitempty"`

	// Export route targets with format in ASN:<number>.
	ExportRouteTargets []string `json:"export_route_targets,omitempty" yaml:"export_route_targets,omitempty" mapstructure:"export_route_targets,omitempty"`

	// Import route targets with format in ASN:<number>.
	ImportRouteTargets []string `json:"import_route_targets,omitempty" yaml:"import_route_targets,omitempty" mapstructure:"import_route_targets,omitempty"`
}

type VrfRouteTargetsAddressFamily string

const VrfRouteTargetsAddressFamilyL2VPNEVPN VrfRouteTargetsAddressFamily = "L2VPN_EVPN"

var enumValues_VrfRouteTargetsAddressFamily = []interface{}{
	"L2VPN_EVPN",
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrfRouteTargetsAddressFamily) UnmarshalJSON(b []byte) error {
	var v string
	if err := json.Unmarshal(b, &v); err != nil {
		return err
	}
	var ok bool
	for _, expected := range enumValues_VrfRouteTargetsAddressFamily {
		if reflect.DeepEqual(v, expected) {
			ok = true
			break
		}
	}
	if !ok {
		return fmt.Errorf("invalid value (expected one of %#v): %#v", enumValues_VrfRouteTargetsAddressFamily, v)
	}
	*j = VrfRouteTargetsAddressFamily(v)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *VrfRouteTargets) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain VrfRouteTargets
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["address_family"]; !ok || v == nil {
		plain.AddressFamily = "L2VPN_EVPN"
	}
	*j = VrfRouteTargets(plain)
	return nil
}
