https://lucacamarda.wordpress.com/2020/08/20/exporting-the-nsx-t-dfw-configuration-via-the-policy-api/

the starting point of the process is the NSX hierarchical API. It natively stores the entire NSX configuration in a structured data model.
Each configuration object is part of a tree whose parent-child relationships represent actual object dependencies.
The Policy API provides the ability to filter certain types of objects via regular expressions.
We can leverage this functionality to retrieve only the objects related to the distributed firewall configuration.

curl -k --user admin --request GET 'https://nsxmgr-01a/policy/api/v1/infra?filter=Type-Domain%7CGroup%7CSecurityPolicy%7CRule%7CPolicyContextProfile%7CService' > dfw_config.json

The filter in the example collects all the objects of the following types:

    Domain
    Group
    Security Policy
    Rule
    PolicyContextProfile
    Service


 system owned objects are all the default services (SSH, HTTP, etc.) and context profile (SMB, SSL, NTP, etc.) that are part of the NSX configuration.    


 --------------------------------------------------------------------

 
 End-user push Policy API representation of the desired state in a Git repository. 
 The end-user will use the NSX Policy API Hierarchical structure to describe the required topology.
 
 https://github.com/lcamarda/blog/blob/master/policy_api_with_jenkins.json



 ------------------------------------------------------------------------

 
 Github repository used in the demo
 https://github.com/lcamarda/terraform-jenkins

 Dependencies between NSX-T and vSphere providers

The Terraform configuration is split into multiple files. This is not necessary from a Terraform perspective, I could have just put all the configurations in a single .tf file, 
but it makes my life easier to manage the settings of the different components separately. Terraform works at the folder level. It will consider all the .tf files in the working folder 
evaluating the dependencies between all the defined objects for a single IaaS provider. When we are working with multiple providers, in this case, NSX-T and vSphere, 
eventual dependencies must be made explicit by the user. In our case, the dependency I had to specify is around the logical switch where the virtual machine is connected.


https://lucacamarda.wordpress.com/2019/12/05/adding-terraform-nsx-configurations-to-a-multibranch-ci-cd-pipeline/

The logical switch must be created before the virtual machine can be connected to it. The problem here is that I cannot configure the VM resource in Terraform to connect to an NSX-T logical switch resource, as the two objects are managed by different providers. What I can do is set the virtual machine to connect to an existing opaque network in vCenter. The opaque network appears in vCenter after the logical switch has bed created. What I needed to do here is telling Terraform to discover the “existing” opaque network after the NSX-T logical switch has been created. See below:

data "vsphere_network" "terraform_web" {
    name = "${nsxt_logical_switch.web.display_name}"
    datacenter_id = "${data.vsphere_datacenter.dc.id}"
    depends_on = ["nsxt_logical_switch.web"]
}

resource "nsxt_logical_switch" "web" {
  admin_state       = "UP"
  description       = "LS created by Terraform"
  display_name      = "OV-Web-Terraform-${var.tenant_name}"
  transport_zone_id = "${data.nsxt_transport_zone.overlay_tz.id}"
  replication_mode  = "MTEP"
}

https://www.terraform.io/docs/providers/nsxt/index.html
https://www.terraform.io/docs/providers/vsphere/index.html

https://blogs.vmware.com/networkvirtualization/2018/04/nsx-t-automation-with-terraform.html/